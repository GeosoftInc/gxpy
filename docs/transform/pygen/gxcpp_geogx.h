#pragma once
#define C_MICROSOFT
#include <gx_extern.h>
#include <gx_lib.h>

#include "stdint.h"
#include <assert.h>
#include <memory>
#include <string>
#include <vector>
#include <exception>
#include <functional>

#ifdef _UNICODE
typedef wchar_t gx_string_char_type;
#define gx_string_len(a) ::wcslen(a)
typedef std::wstring gx_string_type;
#define STRING_CHAR_SIZE 2
#define gx_string_literal(x) L ## x
#else
typedef char gx_string_char_type;
#define gx_string_len(a) ::strlen(a)
typedef std::string gx_string_type;
#define STRING_CHAR_SIZE 1
#define gx_string_literal(x) x
#endif

#ifdef GXPYTHON
np::ndarray make_ndarray(size_t elements, bp::object dtype_obj, int32_t& gs_type, size_t& total_size);
np::ndarray validate_and_make_contiguous_ndarray(np::ndarray np_array, size_t& elements, int32_t& gs_type, size_t& total_size);
np::ndarray validate_and_make_2d_contiguous_ndarray(np::ndarray np_array, size_t& num_rows, size_t& num_columns, int32_t& gs_type, size_t& total_size);
#endif

namespace geosoft
{
    namespace gx
    {
        namespace geogx
        {

            enum DATE_FORMAT
            {
                DATE_FORMAT_YYYYMMDD = 1,
                DATE_FORMAT_DDMMYYYY = 2,
                DATE_FORMAT_MMDDYYYY = 3
            };

            enum GEO_STRING_SIZE
            {
                STR_DEFAULT = 128,
                STR_DEFAULT_SHORT = 64,
                STR_DEFAULT_LONG = 1024,
                STR_ERROR = 2048,
                STR_VERY_LONG = 16384,
                STR_VIEW = 2080,
                STR_GROUP = 1040,
                STR_VIEW_GROUP = 2080,
                STR_FILE = 1040,
                STR_MULTI_FILE = 16384,
                STR_DB_SYMBOL = 64,
                STR_GXF = 160,
                STR_MAX_PATH = 1040,
                STR_MULTI_PATH = 16384,
                GS_MAX_PATH = STR_FILE,
                GS_MULTI_PATH = STR_MULTI_FILE
            };

            enum GEO_VAR
            {
                GS_INT = 0,
                GS_REAL = 1
            };

            enum GS_FORMATS
            {
                FORMAT_DECIMAL = 0,
                FORMAT_SIG_DIG = 5,
                FORMAT_EXP = 1,
                FORMAT_TIME_COLON = 2,
                FORMAT_TIME_HMS = 8,
                FORMAT_TIME_HHMMSS = 9,
                FORMAT_DATE_YYYYMMDD = 3,
                FORMAT_DATE_DDMMYYYY = 6,
                FORMAT_DATE_MMDDYYYY = 7,
                FORMAT_GEOGRAPHIC = 4,
                FORMAT_GEOGRAPHIC_1 = 10,
                FORMAT_GEOGRAPHIC_2 = 11,
                FORMAT_GEOGRAPHIC_3 = 12
            };

            enum GS_TYPES
            {
                GS_BYTE = 0,
                GS_USHORT = 1,
                GS_SHORT = 2,
                GS_LONG = 3,
                GS_FLOAT = 4,
                GS_DOUBLE = 5,
                GS_UBYTE = 6,
                GS_ULONG = 7,
                GS_LONG64 = 8,
                GS_ULONG64 = 9,
                GS_FLOAT3D = 10,
                GS_MAXTYPE = 10,
                GS_TYPE_DEFAULT = -32767
            };

            enum TIME_FORMAT
            {
                TIME_FORMAT_COLON = 1,
                TIME_FORMAT_HMS = 2
            };

            enum GEO3DV_OPEN
            {
                GEO3DV_MVIEW_READ = 0,
                GEO3DV_MVIEW_WRITEOLD = 2
            };

            enum ACQUIRE_SEL
            {
                ACQUIRE_SEL_HOLES = 0,
                ACQUIRE_SEL_POINT = 1
            };

            enum ARC_SELTBL_TYPE
            {
                ARC_SELTBL_STANDALONE = 0,
                ARC_SELTBL_FEATURELAYER = 1,
                ARC_SELTBL_CANCELED = -1
            };

            enum ARCMAP_LOAD_FLAGS
            {
                ARCMAP_LOAD_DELFRAME = 1,
                ARCMAP_LOAD_DELLAYER = 2,
                ARCMAP_LOAD_EXISTFRAME = 4,
                ARCMAP_LOAD_COPYLAYER = 8,
                ARCMAP_LOAD_HIDESIBLINGS = 16,
                ARCMAP_LOAD_PREFIXMAPFRAME = 32,
                ARCMAP_LOAD_PREFIXMAPLAYER = 64,
                ARCMAP_LOAD_MERGETOSINGLEVIEW = 128,
                ARCMAP_LOAD_INTOCURRENTFRAME = 256,
                ARCMAP_LOAD_NOMAPLAYERS = 512,
                ARCMAP_LOAD_ACTIVATE = 1024,
                ARCMAP_LOAD_NEW = 2048,
                ARCMAP_LOAD_NAMETAGISPREFIX = 4096
            };

            enum CHIMERA_PLOT
            {
                CHIMERA_PLOT_ROSE = 0,
                CHIMERA_PLOT_PIE = 1,
                CHIMERA_PLOT_BAR = 2
            };

            enum COM_BAUD
            {
                COM_BAUD_110 = 0,
                COM_BAUD_300 = 1,
                COM_BAUD_600 = 2,
                COM_BAUD_1200 = 3,
                COM_BAUD_2400 = 4,
                COM_BAUD_4800 = 5,
                COM_BAUD_9600 = 6,
                COM_BAUD_14400 = 7,
                COM_BAUD_19200 = 8,
                COM_BAUD_56000 = 9,
                COM_BAUD_57600 = 10,
                COM_BAUD_115200 = 11,
                COM_BAUD_128000 = 12,
                COM_BAUD_256000 = 13,
                COM_BAUD_38400 = 14
            };

            enum COM_DATASIZE
            {
                COM_DATASIZE_FIVE = 5,
                COM_DATASIZE_SIX = 6,
                COM_DATASIZE_SEVEN = 7,
                COM_DATASIZE_EIGHT = 8
            };

            enum COM_FLOWCONTROL
            {
                COM_FLOWCONTROL_NONE = 0,
                COM_FLOWCONTROL_RTS_CTS = 1,
                COM_FLOWCONTROL_DTR_DSR = 2,
                COM_FLOWCONTROL_XON_XOFF = 3
            };

            enum COM_PARITY
            {
                COM_PARITY_EVEN = 0,
                COM_PARITY_NARK = 1,
                COM_PARITY_NONE = 2,
                COM_PARITY_ODD = 3,
                COM_PARITY_SPACE = 4
            };

            enum COM_STOPBITS
            {
                COM_STOPBITS_ONE = 0,
                COM_STOPBITS_ONE5 = 1,
                COM_STOPBITS_TWO = 2
            };

            enum CSYMB_COLOR
            {
                CSYMB_COLOR_EDGE = 0,
                CSYMB_COLOR_FILL = 1
            };

            enum DGW_OBJECT
            {
                DGW_LABEL = 0,
                DGW_TEXT = 1,
                DGW_PATH = 2,
                DGW_FILEPATH = 3,
                DGW_LISTVAL = 4,
                DGW_LISTALIAS = 5,
                DGW_EXT = 7,
                DGW_HIDE = 8
            };

            enum DH_COMP_CHOICE
            {
                DH_COMP_DONE = 0,
                DH_COMP_CANCEL = -1,
                DH_COMP_SELECT = 1,
                DH_COMP_REFRESH = 2
            };

            enum DH_COMPSTDB_HOLSEL
            {
                DH_COMPSTDB_HOLSEL_ALL = 0,
                DH_COMPSTDB_HOLSEL_SELECTED = 1
            };

            enum DH_COMPSTDB_INTSEL
            {
                DH_COMPSTDB_INTSEL_FIXED = 0,
                DH_COMPSTDB_INTSEL_LITHOLOGY = 1,
                DH_COMPSTDB_INTSEL_BESTFITLITH = 2,
                DH_COMPSTDB_INTSEL_INTFILE = 3
            };

            enum DH_DATA
            {
                DH_DATA_DIPAZIMUTH = 0,
                DH_DATA_EASTNORTH = 1,
                DH_DATA_FROMTO = 2,
                DH_DATA_POINT = 3,
                DH_DATA_COLLAR = 4,
                DH_DATA_UNKNOWN = 100
            };

            enum DH_EXP
            {
                DH_EXP_CSV = 0,
                DH_EXP_ASCII = 1,
                DH_EXP_ACCESS = 2,
                DH_EXP_SHP = 3,
                DH_EXP_SURPAC = 4,
                DH_EXP_SHP_TRACES = 5
            };

            enum DH_HOLES
            {
                DH_HOLES_ALL = 0,
                DH_HOLES_SELECTED = 1
            };

            enum DH_MASK
            {
                DH_MASK_APPEND = 0,
                DH_MASK_NEW = 1
            };

            enum DH_PLOT
            {
                DH_PLOT_PLAN = 0,
                DH_PLOT_SECTION = 1,
                DH_PLOT_STRIPLOG = 2,
                DH_PLOT_HOLE_TRACES = 3,
                DH_PLOT_3D = 4,
                DH_PLOT_SECTION_STACK = 5,
                DH_PLOT_SECTION_FENCE = 6,
                DH_PLOT_SECTION_CROOKED = 7
            };

            enum DH_SECT_PAGE
            {
                DH_SECT_PAGE_SECTION = 1
            };

            enum DH_SURFACE
            {
                DH_SURFACE_FIRST_LAYER_FROM = 0,
                DH_SURFACE_FIRST_LAYER_TO = 1,
                DH_SURFACE_SECOND_LAYER_FROM = 2,
                DH_SURFACE_SECOND_LAYER_TO = 3,
                DH_SURFACE_LAST_LAYER_FROM = 4,
                DH_SURFACE_LAST_LAYER_TO = 5
            };

            enum DIP_CONVENTION
            {
                DIP_CONVENTION_NEGATIVE = -1,
                DIP_CONVENTION_POSITIVE = 1
            };

            enum DOCU_OPEN
            {
                DOCU_OPEN_VIEW = 0,
                DOCU_OPEN_EDIT = 1
            };

            enum DB_DUP
            {
                DB_DUP_FIRST = 1,
                DB_DUP_AVERAGE = 2,
                DB_DUP_MINIMUM = 3,
                DB_DUP_MAXIMUM = 4,
                DB_DUP_MEDIAN = 5,
                DB_DUP_LAST = 6
            };

            enum DB_DUPEDIT
            {
                DB_DUPEDIT_SINGLE = 0,
                DB_DUPEDIT_ALL = 1
            };

            enum DU_CHANNELS
            {
                DU_CHANNELS_DISPLAYED = 0,
                DU_CHANNELS_ALL = 1
            };

            enum DU_EXPORT
            {
                DU_EXPORT_CSV = 0,
                DU_EXPORT_ODDF = 1,
                DU_EXPORT_POST_PC = 2,
                DU_EXPORT_POST_UNIX = 3
            };

            enum DU_FILL
            {
                DU_FILL_INSIDE = 0,
                DU_FILL_OUTSIDE = 1
            };

            enum DU_IMPORT
            {
                DU_IMPORT_APPEND = 0,
                DU_IMPORT_REPLACE = 1,
                DU_IMPORT_MERGE = 2,
                DU_IMPORT_MERGE_APPEND = 3
            };

            enum DU_INTERP
            {
                DU_INTERP_NEAREST = 1,
                DU_INTERP_LINEAR = 2,
                DU_INTERP_CUBIC = 3,
                DU_INTERP_AKIMA = 4,
                DU_INTERP_PREDICT = 5
            };

            enum DU_INTERP_EDGE
            {
                DU_INTERP_EDGE_NONE = 0,
                DU_INTERP_EDGE_SAME = 1,
                DU_INTERP_EDGE_NEAREST = 2,
                DU_INTERP_EDGE_LINEAR = 3
            };

            enum DU_LAB_TYPE
            {
                DU_LAB_TYPE_FREE = 1,
                DU_LAB_TYPE_COMMA = 2
            };

            enum DU_LEVEL
            {
                DU_LEVEL_LINES = 0,
                DU_LEVEL_TIES = 1,
                DU_LEVEL_ALL = 2
            };

            enum DU_LINEOUT
            {
                DU_LINEOUT_SINGLE = 0,
                DU_LINEOUT_MULTIPLE = 1
            };

            enum DU_FEATURE_TYPE_OUTPUT
            {
                DU_FEATURE_TYPE_OUTPUT_POINT = 0,
                DU_FEATURE_TYPE_OUTPUT_LINE = 1
            };

            enum DU_GEODATABASE_EXPORT_TYPE
            {
                DU_GEODATABASE_EXPORT_TYPE_OVERWRITE_GEODATABASE = 0,
                DU_GEODATABASE_EXPORT_TYPE_OVERWRITE_FEATURECLASS = 1,
                DU_GEODATABASE_EXPORT_TYPE_APPEND = 2
            };

            enum DU_LINES
            {
                DU_LINES_DISPLAYED = 0,
                DU_LINES_SELECTED = 1,
                DU_LINES_ALL = 2
            };

            enum DU_LOADLTB
            {
                DU_LOADLTB_REPLACE = 0,
                DU_LOADLTB_APPEND = 1
            };

            enum DU_LOOKUP
            {
                DU_LOOKUP_EXACT = 0,
                DU_LOOKUP_NEAREST = 1,
                DU_LOOKUP_INTERPOLATE = 2,
                DU_LOOKUP_NEARESTCLOSE = 3,
                DU_LOOKUP_INTERPCLOSE = 4,
                DU_LOOKUP_INTERPOLATE_DUMMYOUTSIDE = 5,
                DU_LOOKUP_INTERPOLATE_CONSTOUTSIDE = 6,
                DU_LOOKUP_INTERPOLATE_EXTPLOUTSIDE = 7,
                DU_LOOKUP_MAXOPTION = 8
            };

            enum DU_MASK
            {
                DU_MASK_INSIDE = 0,
                DU_MASK_OUTSIDE = 1
            };

            enum DU_MERGE
            {
                DU_MERGE_APPEND = 0
            };

            enum DU_MODFID
            {
                DU_MODFID_INSERT = 0,
                DU_MODFID_DELETE = 1,
                DU_MODFID_APPEND = 2
            };

            enum DU_MOVE
            {
                DU_MOVE_ABSOLUTE = 0,
                DU_MOVE_MINUS = 1,
                DU_MOVE_PLUS = 2,
                DU_MOVE_INTERP = 3
            };

            enum DU_REFID
            {
                DU_REFID_LINEAR = 0,
                DU_REFID_MINCUR = 1,
                DU_REFID_AKIMA = 2,
                DU_REFID_NEAREST = 3
            };

            enum DU_SORT
            {
                DU_SORT_ASCENDING = 0,
                DU_SORT_DESCENDING = 1
            };

            enum DU_SPLITLINE
            {
                DU_SPLITLINE_XYPOSITION = 0,
                DU_SPLITLINE_SEQUENTIAL = 1,
                DU_SPLITLINE_TOVERSIONS = 2
            };

            enum DU_STORAGE
            {
                DU_STORAGE_LINE = 0,
                DU_STORAGE_GROUP = 1
            };

            enum QC_PLAN_TYPE
            {
                QC_PLAN_SURVEYLINE = 0,
                QC_PLAN_TIELINE = 1,
                QC_PLAN_BOTHLINES = 2
            };

            enum DU_DISTANCE_CHANNEL_TYPE
            {
                DU_DISTANCE_CHANNEL_MAINTAIN_DIRECTION = 0,
                DU_DISTANCE_CHANNEL_CARTESIAN_COORDINATES = 1
            };

            enum DU_DIRECTGRID_METHOD
            {
                DU_DIRECTGRID_MIN = 0,
                DU_DIRECTGRID_MAX = 1,
                DU_DIRECTGRID_MEAN = 2
            };

            enum EDB_PATH
            {
                EDB_PATH_FULL = 0,
                EDB_PATH_DIR = 1,
                EDB_PATH_NAME_EXT = 2,
                EDB_PATH_NAME = 3
            };

            enum EDB_PROF
            {
                EDB_PROF_I_CHANNEL = 0,
                EDB_PROF_I_LINE_STYLE = 1,
                EDB_PROF_I_LINE_WEIGHT = 2,
                EDB_PROF_I_SYMBOL = 3,
                EDB_PROF_I_SYMBOL_WEIGHT = 4,
                EDB_PROF_I_COLOR = 5,
                EDB_PROF_I_WRAP = 6,
                EDB_PROF_I_BREAK_ON_DUMMY = 7,
                EDB_PROF_I_GRID_LINE = 8,
                EDB_PROF_R_GRID_LINE_INTERVAL = 9,
                EDB_PROF_I_LOG = 10,
                EDB_PROF_R_LOG_MINIMUM = 11,
                EDB_PROF_I_SAMESCALE = 12,
                EDB_PROF_I_SOURCELINE = 13,
                EDB_PROF_I_SCALEOPTION = 14,
                EDB_PROF_I_SAMERANGE = 15
            };

            enum EDB_PROFILE_SCALE
            {
                EDB_PROFILE_SCALE_LINEAR = 0,
                EDB_PROFILE_SCALE_LOG = 1,
                EDB_PROFILE_SCALE_LOGLINEAR = 2
            };

            enum EDB_REMOVE
            {
                EDB_REMOVE_SAVE = 0,
                EDB_REMOVE_PROMPT = 1,
                EDB_REMOVE_DISCARD = 2
            };

            enum EDB_UNLOAD
            {
                EDB_UNLOAD_NO_PROMPT = 0,
                EDB_UNLOAD_SINGLE_PROMPT = 1,
                EDB_UNLOAD_MULTI_PROMPT = 2
            };

            enum EDB_WINDOW_POSITION
            {
                EDB_WINDOW_POSITION_DOCKED = 0,
                EDB_WINDOW_POSITION_FLOATING = 1
            };

            enum EDB_WINDOW_STATE
            {
                EDB_WINDOW_RESTORE = 0,
                EDB_WINDOW_MINIMIZE = 1,
                EDB_WINDOW_MAXIMIZE = 2
            };

            enum EDB_YAXIS_DIRECTION
            {
                EDB_YAXIS_NORMAL = 0,
                EDB_YAXIS_INVERTED = 1
            };

            enum EDOC_PATH
            {
                EDOC_PATH_FULL = 0,
                EDOC_PATH_DIR = 1,
                EDOC_PATH_NAME_EXT = 2,
                EDOC_PATH_NAME = 3
            };

            enum EDOC_TYPE
            {
                EDOC_TYPE_GMS3D = 0,
                EDOC_TYPE_VOXEL = 1,
                EDOC_TYPE_VOXEL_INVERSION = 2,
                EDOC_TYPE_GMS2D = 3
            };

            enum EDOC_UNLOAD
            {
                EDOC_UNLOAD_NO_PROMPT = 0,
                EDOC_UNLOAD_PROMPT = 1
            };

            enum EDOC_WINDOW_POSITION
            {
                EDOC_WINDOW_POSITION_DOCKED = 0,
                EDOC_WINDOW_POSITION_FLOATING = 1
            };

            enum EDOC_WINDOW_STATE
            {
                EDOC_WINDOW_RESTORE = 0,
                EDOC_WINDOW_MINIMIZE = 1,
                EDOC_WINDOW_MAXIMIZE = 2
            };

            enum GMS3D_MODELTYPE
            {
                GMS3D_MODELTYPE_DEPTH = 0,
                GMS3D_MODELTYPE_TIME = 1
            };

            enum GMS2D_MODELTYPE
            {
                GMS2D_MODELTYPE_DEPTH = 0,
                GMS2D_MODELTYPE_TIME = 1
            };

            enum EMAP_FONT
            {
                EMAP_FONT_TT = 0,
                EMAP_FONT_GFN = 1
            };

            enum EMAP_PATH
            {
                EMAP_PATH_FULL = 0,
                EMAP_PATH_DIR = 1,
                EMAP_PATH_NAME_EXT = 2,
                EMAP_PATH_NAME = 3
            };

            enum EMAP_REDRAW
            {
                EMAP_REDRAW_NO = 0,
                EMAP_REDRAW_YES = 1
            };

            enum EMAP_REMOVE
            {
                EMAP_REMOVE_SAVE = 0,
                EMAP_REMOVE_PROMPT = 1,
                EMAP_REMOVE_DISCARD = 2
            };

            enum EMAP_TRACK
            {
                EMAP_TRACK_ERASE = 1,
                EMAP_TRACK_RMENU = 2,
                EMAP_TRACK_CYCLE = 4
            };

            enum EMAP_VIEWPORT
            {
                EMAP_VIEWPORT_NORMAL = 0,
                EMAP_VIEWPORT_BROWSEZOOM = 1,
                EMAP_VIEWPORT_BROWSEAOI = 2
            };

            enum EMAP_WINDOW_POSITION
            {
                EMAP_WINDOW_POSITION_DOCKED = 0,
                EMAP_WINDOW_POSITION_FLOATING = 1
            };

            enum EMAP_WINDOW_STATE
            {
                EMAP_WINDOW_RESTORE = 0,
                EMAP_WINDOW_MINIMIZE = 1,
                EMAP_WINDOW_MAXIMIZE = 2
            };

            enum LAYOUT_VIEW_UNITS
            {
                LAYOUT_VIEW_MM = 0,
                LAYOUT_VIEW_CM = 1,
                LAYOUT_VIEW_IN = 2
            };

            enum EMAPTEMPLATE_PATH
            {
                EMAPTEMPLATE_PATH_FULL = 0,
                EMAPTEMPLATE_PATH_DIR = 1,
                EMAPTEMPLATE_PATH_NAME_EXT = 2,
                EMAPTEMPLATE_PATH_NAME = 3
            };

            enum EMAPTEMPLATE_TRACK
            {
                EMAPTEMPLATE_TRACK_ERASE = 1,
                EMAPTEMPLATE_TRACK_RMENU = 2,
                EMAPTEMPLATE_TRACK_CYCLE = 4
            };

            enum EMAPTEMPLATE_WINDOW_POSITION
            {
                EMAPTEMPLATE_WINDOW_POSITION_DOCKED = 0,
                EMAPTEMPLATE_WINDOW_POSITION_FLOATING = 1
            };

            enum EMAPTEMPLATE_WINDOW_STATE
            {
                EMAPTEMPLATE_WINDOW_RESTORE = 0,
                EMAPTEMPLATE_WINDOW_MINIMIZE = 1,
                EMAPTEMPLATE_WINDOW_MAXIMIZE = 2
            };

            enum EUL3_RESULT
            {
                EUL3_RESULT_X = 1,
                EUL3_RESULT_Y = 2,
                EUL3_RESULT_DEPTH = 3,
                EUL3_RESULT_BACKGROUND = 4,
                EUL3_RESULT_DEPTHERROR = 5,
                EUL3_RESULT_LOCATIONERROR = 6,
                EUL3_RESULT_WINDOWX = 7,
                EUL3_RESULT_WINDOWY = 8
            };

            enum FFT_DETREND
            {
                FFT_DETREND_NONE = 0,
                FFT_DETREND_ENDS = 1,
                FFT_DETREND_ALL = 2,
                FFT_DETREND_MEAN = 3
            };

            enum FFT2_PG
            {
                FFT2_PG_FORWARD = 0,
                FFT2_PG_INVERSE = 1
            };

            enum GD_STATUS
            {
                GD_STATUS_READONLY = 0,
                GD_STATUS_NEW = 1,
                GD_STATUS_OLD = 2
            };

            enum EM_ERR
            {
                EM_ERR_UNSCALED = 0,
                EM_ERR_LOGSCALING = 1
            };

            enum EM_INV
            {
                EM_INV_INPHASE = 0,
                EM_INV_QUADRATURE = 1,
                EM_INV_BOTH = 2
            };

            enum EMPLATE_DOMAIN
            {
                EMPLATE_FREQUENCY = 1,
                EMPLATE_TIME = 9
            };

            enum EMPLATE_TX
            {
                EMPLATE_TX_X = 1,
                EMPLATE_TX_Y = 2,
                EMPLATE_TX_Z = 3
            };

            enum GU_DAARC500_DATATYPE
            {
                GU_DAARC500_UNKNOWN = 0,
                GU_DAARC500_GENERIC_ASCII = 1,
                GU_DAARC500_GPS = 2,
                GU_DAARC500_GR820_256D = 3,
                GU_DAARC500_GR820_256DU = 4,
                GU_DAARC500_GR820_512DU = 5,
                GU_DAARC500_NAV = 6
            };

            enum PEAKEULER_XY
            {
                PEAKEULER_XY_NOFIT = 0,
                PEAKEULER_XY_FIT = 1
            };

            enum AOI_RETURN_STATE
            {
                AOI_RETURN_CANCEL = -1,
                AOI_RETURN_NODEFINE = 0,
                AOI_RETURN_DEFINE = 1
            };

            enum COORDSYS_MODE
            {
                COORDSYS_MODE_ALL = 0,
                COORDSYS_MODE_GCS = 1,
                COORDSYS_MODE_PCS = 2,
                COORDSYS_MODE_GCS_PCS = 3,
                COORDSYS_MODE_PCS_UNKNOWN = 4
            };

            enum DAT_TYPE
            {
                DAT_TYPE_GRID = 0,
                DAT_TYPE_IMAGE = 1,
                DAT_TYPE_GRID_AND_IMAGE = 2
            };

            enum FILE_FILTER
            {
                FILE_FILTER_ALL = 1,
                FILE_FILTER_GDB = 2,
                FILE_FILTER_GX = 3,
                FILE_FILTER_GS = 4,
                FILE_FILTER_INI = 5,
                FILE_FILTER_OMN = 6,
                FILE_FILTER_VU = 7,
                FILE_FILTER_MAP = 8,
                FILE_FILTER_PRJ = 9,
                FILE_FILTER_CON = 10,
                FILE_FILTER_MNU = 11,
                FILE_FILTER_PDF = 12,
                FILE_FILTER_PLT = 13,
                FILE_FILTER_GWS = 14,
                FILE_FILTER_AGG = 15,
                FILE_FILTER_TBL = 16,
                FILE_FILTER_ZON = 17,
                FILE_FILTER_ITR = 18,
                FILE_FILTER_DXF = 19,
                FILE_FILTER_TIF = 20,
                FILE_FILTER_EMF = 21,
                FILE_FILTER_BMP = 22,
                FILE_FILTER_LUT = 23,
                FILE_FILTER_PNG = 24,
                FILE_FILTER_JPG = 25,
                FILE_FILTER_PCX = 26,
                FILE_FILTER_GIF = 27,
                FILE_FILTER_GRD = 28,
                FILE_FILTER_ERS = 29,
                FILE_FILTER_EPS = 30,
                FILE_FILTER_SHP = 31,
                FILE_FILTER_CGM = 32,
                FILE_FILTER_TAB = 33,
                FILE_FILTER_COMPS = 34,
                FILE_FILTER_CSV = 35,
                FILE_FILTER_GPF = 36,
                FILE_FILTER_PLY = 37,
                FILE_FILTER_STM = 38,
                FILE_FILTER_TTM = 39,
                FILE_FILTER_XYZ = 40,
                FILE_FILTER_BAR = 41,
                FILE_FILTER_GEOSOFT_LICENSE = 42,
                FILE_FILTER_XML = 43,
                FILE_FILTER_GXNET = 44,
                FILE_FILTER_ECW = 45,
                FILE_FILTER_J2K = 46,
                FILE_FILTER_JP2 = 47,
                FILE_FILTER_SEL = 48,
                FILE_FILTER_SVG = 49,
                FILE_FILTER_SVZ = 50,
                FILE_FILTER_WRP = 51,
                FILE_FILTER_MAPPLOT = 52,
                FILE_FILTER_DTM = 53,
                FILE_FILTER_VOXEL = 54,
                FILE_FILTER_MAPTEMPLATE = 55,
                FILE_FILTER_ACTION = 56,
                FILE_FILTER_DM = 57,
                FILE_FILTER_KML = 58,
                FILE_FILTER_KMZ = 59,
                FILE_FILTER_TARGET_PLAN = 60,
                FILE_FILTER_TARGET_SECTION = 61,
                FILE_FILTER_TARGET_STRIPLOG = 62,
                FILE_FILTER_TARGET_3D = 63,
                FILE_FILTER_ARGIS_LYR = 64,
                FILE_FILTER_ARGIS_MXD = 65,
                FILE_FILTER_GOCAD_TS = 66,
                FILE_FILTER_LST = 67,
                FILE_FILTER_ECS = 68,
                FILE_FILTER_TARGET_FENCE = 69,
                FILE_FILTER_GMS3D = 70,
                FILE_FILTER_BT2 = 71,
                FILE_FILTER_BPR = 72,
                FILE_FILTER_BPR2 = 73,
                FILE_FILTER_XLS = 74,
                FILE_FILTER_XLSX = 75,
                FILE_FILTER_MDB = 76,
                FILE_FILTER_ACCDB = 77,
                FILE_FILTER_INTERSECTION_TBL = 78,
                FILE_FILTER_UBC_CON = 79,
                FILE_FILTER_UBC_CHG = 80,
                FILE_FILTER_UBC_MSH = 81,
                FILE_FILTER_UBC_MSH_DAT = 82,
                FILE_FILTER_UBC_TOPO_DAT = 83,
                FILE_FILTER_UBC_TOPO_XYZ = 84,
                FILE_FILTER_XYZ_TEMPLATE_I0 = 85,
                FILE_FILTER_PICO_TEMPLATE_I1 = 86,
                FILE_FILTER_BB_TEMPLATE_I2 = 87,
                FILE_FILTER_ASCII_TEMPLATE_I3 = 88,
                FILE_FILTER_ODBC_TEMPLATE_I4 = 89,
                FILE_FILTER_EXP = 90,
                FILE_FILTER_SEGY = 91,
                FILE_FILTER_DAARC500 = 92,
                FILE_FILTER_TXT = 93,
                FILE_FILTER_VOXEL_INVERSION = 94,
                FILE_FILTER_GMS = 95,
                FILE_FILTER_FLT3D = 96,
                FILE_FILTER_RESOURCE_PACK = 97,
                FILE_FILTER_GEOSTRING = 98,
                FILE_FILTER_GEOSURFACE = 99,
                FILE_FILTER_GEOSOFT3DV = 100,
                FILE_FILTER_VECTORVOXEL = 101,
                FILE_FILTER_FLT = 102,
                FILE_FILTER_XYZ_TEMPLATE_O0 = 103,
                FILE_FILTER_GMS2D = 104,
                FILE_FILTER_IP_DATABASE_TEMPLATE = 105,
                FILE_FILTER_GEOSOFT_RESOURCE_MODULE = 106,
                FILE_FILTER_VT = 107,
                FILE_FILTER_INT = 108,
                FILE_FILTER_SGT = 109,
                FILE_FILTER_IMGVIEW = 110,
                FILE_FILTER_ZIP = 111,
                FILE_FILTER_GPS_TABLE = 112,
                FILE_FILTER_VULCAN_TRIANGULATION = 113,
                FILE_FILTER_VULCAN_BLOCK_MODEL = 114,
                FILE_FILTER_PRJVIEW = 115,
                FILE_FILTER_LEAPFROG_MODEL = 116,
                FILE_FILTER_IOGAS = 117,
                FILE_FILTER_ASEG_ESF = 118,
                FILE_FILTER_LACOSTE_DAT = 119,
                FILE_FILTER_VAR = 120,
                FILE_FILTER_P190 = 121,
                FILE_FILTER_UBC_OBS_DAT = 122,
                FILE_FILTER_UBC_LOC = 123
            };

            enum FILE_FORM
            {
                FILE_FORM_OPEN = 0,
                FILE_FORM_SAVE = 1
            };

            enum GS_DIRECTORY
            {
                GS_DIRECTORY_NONE = 0,
                GS_DIRECTORY_GEOSOFT = 1,
                GS_DIRECTORY_BIN = 2,
                GS_DIRECTORY_GER = 3,
                GS_DIRECTORY_OMN = 4,
                GS_DIRECTORY_TBL = 5,
                GS_DIRECTORY_FONTS = 6,
                GS_DIRECTORY_GX = 7,
                GS_DIRECTORY_GS = 8,
                GS_DIRECTORY_APPS = 9,
                GS_DIRECTORY_ETC = 10,
                GS_DIRECTORY_HLP = 11,
                GS_DIRECTORY_GXDEV = 12,
                GS_DIRECTORY_COMPONENT = 13,
                GS_DIRECTORY_CSV = 14,
                GS_DIRECTORY_LIC = 15,
                GS_DIRECTORY_INI = 16,
                GS_DIRECTORY_TEMP = 17,
                GS_DIRECTORY_UETC = 18,
                GS_DIRECTORY_UMAPTEMPLATE = 19,
                GS_DIRECTORY_COMPONENT_SCRIPTS = 50,
                GS_DIRECTORY_COMPONENT_HTML = 51,
                GS_DIRECTORY_IMG = 52,
                GS_DIRECTORY_BAR = 53,
                GS_DIRECTORY_GXNET = 54,
                GS_DIRECTORY_MAPTEMPLATE = 55
            };

            enum IMPCH_TYPE
            {
                IMPCH_TYPE_DATA = 0,
                IMPCH_TYPE_ASSAY = 1
            };

            enum WINDOW_STATE
            {
                WINDOW_RESTORE = 0,
                WINDOW_MINIMIZE = 1,
                WINDOW_MAXIMIZE = 2
            };

            enum XTOOL_ALIGN
            {
                XTOOL_ALIGN_LEFT = 1,
                XTOOL_ALIGN_TOP = 2,
                XTOOL_ALIGN_RIGHT = 4,
                XTOOL_ALIGN_BOTTOM = 8,
                XTOOL_ALIGN_ANY = 15
            };

            enum XTOOL_DOCK
            {
                XTOOL_DOCK_TOP = 1,
                XTOOL_DOCK_LEFT = 2,
                XTOOL_DOCK_RIGHT = 3,
                XTOOL_DOCK_BOTTOM = 4,
                XTOOL_DOCK_FLOAT = 5
            };

            enum IP_ARRAY
            {
                IP_ARRAY_DPDP = 0,
                IP_ARRAY_PLDP = 1,
                IP_ARRAY_PLPL = 2,
                IP_ARRAY_GRAD = 3,
                IP_ARRAY_WENNER = 5,
                IP_ARRAY_SCHLUMBERGER = 6,
                IP_ARRAY_UNKNOWN = 7,
                IP_ARRAY_3D = 9,
                IP_ARRAY_3D_PLDP = 10,
                IP_ARRAY_3D_PLPL = 11
            };

            enum IP_CHANNELS
            {
                IP_CHANNELS_DISPLAYED = 0,
                IP_CHANNELS_SELECTED = 1,
                IP_CHANNELS_ALL = 2
            };

            enum IP_DOMAIN
            {
                IP_DOMAIN_NONE = -1,
                IP_DOMAIN_TIME = 0,
                IP_DOMAIN_FREQUENCY = 1,
                IP_DOMAIN_BOTH = 2
            };

            enum IP_DUPLICATE
            {
                IP_DUPLICATE_APPEND = 0,
                IP_DUPLICATE_OVERWRITE = 1
            };

            enum IP_FILTER
            {
                IP_FILTER_PANTLEG = 1,
                IP_FILTER_PANTLEGP = 2,
                IP_FILTER_PYRIAMID = 3,
                IP_FILTER_PYRIAMIDP = 4
            };

            enum IP_I2XIMPMODE
            {
                IP_I2XIMPMODE_REPLACE = 0,
                IP_I2XIMPMODE_MERGE = 1
            };

            enum IP_I2XINV
            {
                IP_I2XINV_IMAGE = 0,
                IP_I2XINV_ZONGE = 1
            };

            enum IP_LINES
            {
                IP_LINES_DISPLAYED = 0,
                IP_LINES_SELECTED = 1,
                IP_LINES_ALL = 2
            };

            enum IP_PLOT
            {
                IP_PLOT_PSEUDOSECTION = 0,
                IP_PLOT_STACKEDSECTION = 1
            };

            enum IP_STACK_TYPE
            {
                IP_STACK_TYPE_MAP = 0,
                IP_STACK_TYPE_EQUAL = 1,
                IP_STACK_TYPE_GEOGRAPHIC = 2
            };

            enum IP_STNSCALE
            {
                IP_STNSCALE_NONE = 0,
                IP_STNSCALE_ASPACE = 1,
                IP_STNSCALE_VALUE = 2,
                IP_STNSCALE_FILE = 3
            };

            enum IP_SYS
            {
                IP_SYS_IPDATA = 0,
                IP_SYS_IP2 = 1,
                IP_SYS_IP6 = 2,
                IP_SYS_IP10 = 3,
                IP_SYS_SYSCALR2 = 4,
                IP_SYS_IPR11 = 5,
                IP_SYS_IPR12 = 6,
                IP_SYS_PHOENIX = 7,
                IP_SYS_PHOENIX_V2 = 8,
                IP_SYS_ELREC_PRO = 9
            };

            enum IP_UBC_CONTROL
            {
                IP_UBC_CONTROL_NONE = -1,
                IP_UBC_CONTROL_DEFAULT = 0,
                IP_UBC_CONTROL_FILE = 1,
                IP_UBC_CONTROL_VALUE = 2,
                IP_UBC_CONTROL_LENGTH = 3
            };

            enum IP_PLDP_CONV
            {
                IP_PLDP_CONV_CLOSE_RX = 0,
                IP_PLDP_CONV_MID_RX = 1,
                IP_PLDP_CONV_DISTANT_RX = 2
            };

            enum MVG_DRAW
            {
                MVG_DRAW_POLYLINE = 0,
                MVG_DRAW_POLYGON = 1
            };

            enum MVG_GRID
            {
                MVG_GRID_DOT = 0,
                MVG_GRID_LINE = 1,
                MVG_GRID_CROSS = 2
            };

            enum MVG_LABEL_BOUND
            {
                MVG_LABEL_BOUND_NO = 0,
                MVG_LABEL_BOUND_YES = 1
            };

            enum MVG_LABEL_JUST
            {
                MVG_LABEL_JUST_TOP = 0,
                MVG_LABEL_JUST_BOTTOM = 1,
                MVG_LABEL_JUST_LEFT = 2,
                MVG_LABEL_JUST_RIGHT = 3
            };

            enum MVG_LABEL_ORIENT
            {
                MVG_LABEL_ORIENT_HORIZONTAL = 0,
                MVG_LABEL_ORIENT_TOP_RIGHT = 1,
                MVG_LABEL_ORIENT_TOP_LEFT = 2
            };

            enum MVG_SCALE
            {
                MVG_SCALE_LINEAR = 0,
                MVG_SCALE_LOG = 1,
                MVG_SCALE_LOGLINEAR = 2
            };

            enum MVG_WRAP
            {
                MVG_WRAP_NO = 0,
                MVG_WRAP_YES = 1
            };

            enum BLAKEY_TEST
            {
                BLAKEY_TEST_ONESIDE = 1,
                BLAKEY_TEST_TWOSIDE = 2,
                BLAKEY_TEST_THREESIDE = 3,
                BLAKEY_TEST_FOURSIDE = 4
            };

            enum PGU_CORR
            {
                PGU_CORR_SIMPLE = 0,
                PGU_CORR_PEARSON = 1
            };

            enum PGU_DIRECTGRID
            {
                PGU_DIRECTGRID_MINIMUM = 0,
                PGU_DIRECTGRID_MAXIMUM = 1,
                PGU_DIRECTGRID_MEAN = 2,
                PGU_DIRECTGRID_ITEMS = 3
            };

            enum PGU_DIRECTION
            {
                PGU_FORWARD = 0,
                PGU_BACKWARD = 1
            };

            enum PGU_TRANS
            {
                PGU_TRANS_NONE = 0,
                PGU_TRANS_LOG = 1
            };

            enum PGU_INTERP_ORDER
            {
                PGU_INTERP_ORDER_XYZ = 0,
                PGU_INTERP_ORDER_XZY = 1,
                PGU_INTERP_ORDER_YXZ = 2,
                PGU_INTERP_ORDER_YZX = 3,
                PGU_INTERP_ORDER_ZXY = 4,
                PGU_INTERP_ORDER_ZYX = 5
            };

            enum COMMAND_ENV
            {
                COMMAND_ENV_NORMAL = 0,
                COMMAND_ENV_IN3DVIEWER = 1
            };

            enum TOOL_TYPE
            {
                TOOL_TYPE_DEFAULT = 0,
                TOOL_TYPE_AUXILIARY = 1,
                TOOL_TYPE_ALL = 2
            };

            enum PROJ_DISPLAY
            {
                PROJ_DISPLAY_NO = 0,
                PROJ_DISPLAY_YES = 1,
                PROJ_DISPLAY_ALWAYS = 2
            };

            enum SEMPLOT_EXPORT
            {
                SEMPLOT_EXPORT_NORMAL = 0,
                SEMPLOT_EXPORT_NOEXTRA = 1
            };

            enum SEMPLOT_EXT
            {
                SEMPLOT_EXT_ALL = 0,
                SEMPLOT_EXT_SEMPLOT = 1,
                SEMPLOT_EXT_CHIMERA = 2
            };

            enum SEMPLOT_PLOT
            {
                SEMPLOT_PLOT_ALL = 0,
                SEMPLOT_PLOT_XYPLOT = 1,
                SEMPLOT_PLOT_TRIPLOT = 2,
                SEMPLOT_PLOT_UNKNOWN = 3
            };

            enum SHP_GEOM_TYPE
            {
                SHP_GEOM_TYPE_POINT = 1,
                SHP_GEOM_TYPE_ARC = 3,
                SHP_GEOM_TYPE_POLYGON = 5,
                SHP_GEOM_TYPE_POINTZ = 11,
                SHP_GEOM_TYPE_ARCZ = 13,
                SHP_GEOM_TYPE_POLYGONZ = 15
            };

            enum MFCSQL_DRIVER
            {
                MFCSQL_DRIVER_NOPROMPT = 0,
                MFCSQL_DRIVER_COMPLETE = 1,
                MFCSQL_DRIVER_PROMPT = 2,
                MFCSQL_DRIVER_COMPLETE_REQUIRED = 3
            };

            enum STK_AXIS
            {
                STK_AXIS_X = 0,
                STK_AXIS_Y = 1
            };

            enum STK_FLAG
            {
                STK_FLAG_PROFILE = 0,
                STK_FLAG_FID = 1,
                STK_FLAG_SYMBOL = 2,
                STK_FLAG_XBAR = 3,
                STK_FLAG_XLABEL = 4,
                STK_FLAG_XTITLE = 5,
                STK_FLAG_YBAR = 6,
                STK_FLAG_YLABEL = 7,
                STK_FLAG_YTITLE = 8,
                STK_FLAG_GRID1 = 9,
                STK_FLAG_GRID2 = 10
            };

            enum STK_GRID
            {
                STK_GRID_PRIMARY = 0,
                STK_GRID_SECONDARY = 1
            };

            enum TC_OPT
            {
                TC_OPT_NONE = 0,
                TC_OPT_MAX = 1
            };

            enum TC_SURVEYTYPE
            {
                TC_SURVEYTYPE_GROUND = 0,
                TC_SURVEYTYPE_SHIPBORNE = 1,
                TC_SURVEYTYPE_AIRBORNE = 2
            };

            enum GG_ELEMENT
            {
                GG_ELEMENT_XX = 0,
                GG_ELEMENT_YY = 1,
                GG_ELEMENT_XY = 2,
                GG_ELEMENT_XZ = 3,
                GG_ELEMENT_YZ = 4
            };

            enum TRND_NODE
            {
                TRND_MIN = 0,
                TRND_MAX = 1
            };

            enum UTF8
            {
                UTF8_MAX_CHAR = 5
            };

            enum VAU_PRUNE
            {
                VAU_PRUNE_DUMMY = 0,
                VAU_PRUNE_VALID = 1
            };

            enum QC_CRITERION
            {
                QC_CRITERION_1 = 0,
                QC_CRITERION_2 = 1,
                QC_CRITERION_12 = 2
            };

            enum TEM_ARRAY
            {
                TEM_ARRAY_VERTICALSOUNDING = 0,
                TEM_ARRAY_PROFILING = 1,
                TEM_ARRAY_BOREHOLE = 2
            };

            enum VV_DUP
            {
                VV_DUP_AVERAGE = 0,
                VV_DUP_1 = 1,
                VV_DUP_2 = 2,
                VV_DUP_DUMMY = 3,
                VV_DUP_SAMPLE = 4
            };

            enum VV_XYDUP
            {
                VV_XYDUP_AVERAGE = 0,
                VV_XYDUP_SUM = 1
            };

            enum VVU_CASE
            {
                VVU_CASE_TOLERANT = 0,
                VVU_CASE_SENSITIVE = 1
            };

            enum VVU_CLIP
            {
                VVU_CLIP_DUMMY = 0,
                VVU_CLIP_LIMIT = 1
            };

            enum VVU_DUMMYREPEAT
            {
                VVU_DUMMYREPEAT_FIRST = 0,
                VVU_DUMMYREPEAT_LAST = 1,
                VVU_DUMMYREPEAT_MIDDLE = 2
            };

            enum VVU_INTERP
            {
                VVU_INTERP_NEAREST = 1,
                VVU_INTERP_LINEAR = 2,
                VVU_INTERP_CUBIC = 3,
                VVU_INTERP_AKIMA = 4,
                VVU_INTERP_PREDICT = 5
            };

            enum VVU_INTERP_EDGE
            {
                VVU_INTERP_EDGE_NONE = 0,
                VVU_INTERP_EDGE_SAME = 1,
                VVU_INTERP_EDGE_NEAREST = 2,
                VVU_INTERP_EDGE_LINEAR = 3
            };

            enum VVU_LINE
            {
                LINE_2_POINTS = 0,
                LINE_POINT_AZIMUTH = 1
            };

            enum VVU_MASK
            {
                VVU_MASK_INSIDE = 0,
                VVU_MASK_OUTSIDE = 1
            };

            enum VVU_MATCH
            {
                VVU_MATCH_FULL_STRINGS = 0,
                VVU_MATCH_INPUT_LENGTH = 1
            };

            enum VVU_MODE
            {
                VVU_MODE_MEAN = 0,
                VVU_MODE_MEDIAN = 1,
                VVU_MODE_MAXIMUM = 2,
                VVU_MODE_MINIMUM = 3
            };

            enum VVU_OFFSET
            {
                VVU_OFFSET_FORWARD = 0,
                VVU_OFFSET_BACKWARD = 1,
                VVU_OFFSET_RIGHT = 2,
                VVU_OFFSET_LEFT = 3
            };

            enum VVU_PRUNE
            {
                VVU_PRUNE_DUMMY = 0,
                VVU_PRUNE_VALID = 1
            };

            enum VVU_SPL
            {
                VVU_SPL_LINEAR = 0,
                VVU_SPL_CUBIC = 1,
                VVU_SPL_AKIMA = 2,
                VVU_SPL_NEAREST = 3
            };

            enum VVU_SRCHREPL_CASE
            {
                VVU_SRCHREPL_CASE_TOLERANT = 0,
                VVU_SRCHREPL_CASE_SENSITIVE = 1
            };

            enum AGG_LAYER_ZONE
            {
                AGG_LAYER_ZONE_DEFAULT = 0,
                AGG_LAYER_ZONE_LINEAR = 1,
                AGG_LAYER_ZONE_NORMAL = 2,
                AGG_LAYER_ZONE_EQUALAREA = 3,
                AGG_LAYER_ZONE_SHADE = 4,
                AGG_LAYER_ZONE_LOGLINEAR = 5,
                AGG_LAYER_ZONE_LAST = 6
            };

            enum AGG_MODEL
            {
                AGG_MODEL_HSV = 1,
                AGG_MODEL_RGB = 2,
                AGG_MODEL_CMY = 3
            };

            enum AGG_RENDER
            {
                AGG_RENDER_ADD = 0,
                AGG_RENDER_BLEND = 1,
                AGG_RENDER_BLEND_ALL = 2,
                AGG_RENDER_FADE = 3
            };

            enum BF_BYTEORDER
            {
                BF_BYTEORDER_LSB = 256,
                BF_BYTEORDER_MSB = 512
            };

            enum BF_CLOSE
            {
                BF_KEEP = 0,
                BF_DELETE = 1
            };

            enum BF_ENCODE
            {
                BF_ENCODE_ANSI = 0,
                BF_ENCODE_UTF8 = 1
            };

            enum BF_OPEN_MODE
            {
                BF_READ = 0,
                BF_READWRITE_NEW = 1,
                BF_READWRITE_OLD = 2,
                BF_READWRITE_APP = 4
            };

            enum BF_SEEK
            {
                BF_SEEK_START = 0,
                BF_SEEK_CURRENT = 1,
                BF_SEEK_EOF = 2
            };

            enum DAT_FILE
            {
                DAT_FILE_GRID = 1,
                DAT_FILE_IMAGE = 2
            };

            enum DAT_FILE_FORM
            {
                DAT_FILE_FORM_OPEN = 0,
                DAT_FILE_FORM_SAVE = 1
            };

            enum DAT_XGD
            {
                DAT_XGD_READ = 0,
                DAT_XGD_NEW = 1,
                DAT_XGD_WRITE = 2
            };

            enum GIS_DMTYPE
            {
                GIS_DMTYPE_STRING = 2,
                GIS_DMTYPE_WIREFRAME_TR = 8,
                GIS_DMTYPE_DTM = 16,
                GIS_DMTYPE_BLOCKMODEL = 32,
                GIS_DMTYPE_WIREFRAME_PT = 64,
                GIS_DMTYPE_POINTDATA = 1024
            };

            enum DB_CATEGORY_BLOB
            {
                DB_CATEGORY_BLOB_NORMAL = 0
            };

            enum DB_CATEGORY_CHAN
            {
                DB_CATEGORY_CHAN_BYTE = GS_BYTE,
                DB_CATEGORY_CHAN_USHORT = GS_USHORT,
                DB_CATEGORY_CHAN_SHORT = GS_SHORT,
                DB_CATEGORY_CHAN_LONG = GS_LONG,
                DB_CATEGORY_CHAN_FLOAT = GS_FLOAT,
                DB_CATEGORY_CHAN_DOUBLE = GS_DOUBLE,
                DB_CATEGORY_CHAN_UBYTE = GS_UBYTE,
                DB_CATEGORY_CHAN_ULONG = GS_ULONG,
                DB_CATEGORY_CHAN_LONG64 = GS_LONG64,
                DB_CATEGORY_CHAN_ULONG64 = GS_ULONG64
            };

            enum DB_CATEGORY_LINE
            {
                DB_CATEGORY_LINE_FLIGHT = 100,
                DB_CATEGORY_LINE_GROUP = 200,
                DB_CATEGORY_LINE_NORMAL = DB_CATEGORY_LINE_FLIGHT
            };

            enum DB_CATEGORY_USER
            {
                DB_CATEGORY_USER_NORMAL = 0
            };

            enum DB_CHAN_FORMAT
            {
                DB_CHAN_FORMAT_NORMAL = FORMAT_DECIMAL,
                DB_CHAN_FORMAT_EXP = FORMAT_EXP,
                DB_CHAN_FORMAT_TIME = FORMAT_TIME_COLON,
                DB_CHAN_FORMAT_DATE = FORMAT_DATE_YYYYMMDD,
                DB_CHAN_FORMAT_GEOGR = FORMAT_GEOGRAPHIC,
                DB_CHAN_FORMAT_SIGDIG = FORMAT_SIG_DIG,
                DB_CHAN_FORMAT_HEX = 6
            };

            enum DB_CHAN_PROTECTION
            {
                DB_CHAN_UNPROTECTED = 0,
                DB_CHAN_PROTECTED = 1
            };

            enum DB_CHAN_SYMBOL
            {
                DB_CHAN_X = 0,
                DB_CHAN_Y = 1,
                DB_CHAN_Z = 2
            };

            enum DB_COMP
            {
                DB_COMP_NONE = 0,
                DB_COMP_SPEED = 1,
                DB_COMP_SIZE = 2
            };

            enum DB_COORDPAIR
            {
                DB_COORDPAIR_NONE = 0,
                DB_COORDPAIR_X = 1,
                DB_COORDPAIR_Y = 2
            };

            enum DB_INFO
            {
                DB_INFO_BLOBS_MAX = 0,
                DB_INFO_LINES_MAX = 1,
                DB_INFO_CHANS_MAX = 2,
                DB_INFO_USERS_MAX = 3,
                DB_INFO_BLOBS_USED = 4,
                DB_INFO_LINES_USED = 5,
                DB_INFO_CHANS_USED = 6,
                DB_INFO_USERS_USED = 7,
                DB_INFO_PAGE_SIZE = 8,
                DB_INFO_DATA_SIZE = 9,
                DB_INFO_LOST_SIZE = 10,
                DB_INFO_FREE_SIZE = 11,
                DB_INFO_COMP_LEVEL = 16,
                DB_INFO_BLOB_SIZE = 19,
                DB_INFO_FILE_SIZE = 17,
                DB_INFO_INDEX_SIZE = 18,
                DB_INFO_MAX_BLOCK_SIZE = 20,
                DB_INFO_CHANGESLOST = 21
            };

            enum DB_LINE_LABEL_FORMAT
            {
                DB_LINE_LABEL_FORMAT_LINE = 1,
                DB_LINE_LABEL_FORMAT_VERSION = 2,
                DB_LINE_LABEL_FORMAT_TYPE = 4,
                DB_LINE_LABEL_FORMAT_FLIGHT = 8,
                DB_LINE_LABEL_FORMAT_FULL = 15,
                DB_LINE_LABEL_FORMAT_DATE = 16,
                DB_LINE_LABEL_FORMAT_LINK = 7
            };

            enum DB_LINE_SELECT
            {
                DB_LINE_SELECT_INCLUDE = 0,
                DB_LINE_SELECT_EXCLUDE = 1
            };

            enum DB_LINE_TYPE
            {
                DB_LINE_TYPE_NORMAL = 0,
                DB_LINE_TYPE_BASE = 1,
                DB_LINE_TYPE_TIE = 2,
                DB_LINE_TYPE_TEST = 3,
                DB_LINE_TYPE_TREND = 4,
                DB_LINE_TYPE_SPECIAL = 5,
                DB_LINE_TYPE_RANDOM = 6
            };

            enum DB_LOCK
            {
                DB_LOCK_NONE = -1,
                DB_LOCK_READONLY = 0,
                DB_LOCK_READWRITE = 1
            };

            enum DB_NAME
            {
                DB_NAME_FILE = 0
            };

            enum DB_OWN
            {
                DB_OWN_SHARED = 0,
                DB_OWN_USER = 1
            };

            enum DB_SYMB_TYPE
            {
                DB_SYMB_BLOB = 0,
                DB_SYMB_LINE = 1,
                DB_SYMB_CHAN = 2,
                DB_SYMB_USER = 3
            };

            enum DB_WAIT
            {
                DB_WAIT_NONE = 0,
                DB_WAIT_INFINITY = -1
            };

            enum DB_ARRAY_BASETYPE
            {
                DB_ARRAY_BASETYPE_NONE = 0,
                DB_ARRAY_BASETYPE_TIME_WINDOWS = 1,
                DB_ARRAY_BASETYPE_TIMES = 2,
                DB_ARRAY_BASETYPE_FREQUENCIES = 3,
                DB_ARRAY_BASETYPE_ELEVATIONS = 4,
                DB_ARRAY_BASETYPE_DEPTHS = 5,
                DB_ARRAY_BASETYPE_VELOCITIES = 6,
                DB_ARRAY_BASETYPE_DISCRETE_TIME_WINDOWS = 7
            };

            enum DSEL_PICTURE_QUALITY
            {
                DSEL_PICTURE_QUALITY_DEFAULT = 0,
                DSEL_PICTURE_QUALITY_LOSSLESS = 1,
                DSEL_PICTURE_QUALITY_SEMILOSSY = 2,
                DSEL_PICTURE_QUALITY_LOSSY = 3,
                DSEL_PICTURE_QUALITY_NATIVE = 4,
                DSEL_PICTURE_QUALITY_ECW = 5,
                DSEL_PICTURE_QUALITY_JPG = 6,
                DSEL_PICTURE_QUALITY_PNG = 7,
                DSEL_PICTURE_QUALITY_BMP = 8,
                DSEL_PICTURE_QUALITY_TIF = 9
            };

            enum GEOSTRING_OPEN
            {
                GEOSTRING_OPEN_READ = 0,
                GEOSTRING_OPEN_READWRITE = 1
            };

            enum SECTION_ORIENTATION
            {
                SECTION_ORIENTATION_UNKNOWN = 0,
                SECTION_ORIENTATION_PLAN = 1,
                SECTION_ORIENTATION_SECTION = 2,
                SECTION_ORIENTATION_CROOKED = 2,
                SECTION_ORIENTATION_GMSYS = 2
            };

            enum GIS_MAP2D
            {
                GIS_MAP2D_PLAN = 0,
                GIS_MAP2D_EWSECTION = 1,
                GIS_MAP2D_NSSECTION = 2
            };

            enum GIS_TYPE
            {
                GIS_TYPE_MAPINFO = 1,
                GIS_TYPE_ARCVIEW = 2,
                GIS_TYPE_DGN = 3,
                GIS_TYPE_SURPAC = 4,
                GIS_TYPE_DATAMINE = 5,
                GIS_TYPE_GEMCOM = 6,
                GIS_TYPE_MICROMINE = 7,
                GIS_TYPE_MINESIGHT = 8
            };

            enum IMG_FILE
            {
                IMG_FILE_READONLY = 0,
                IMG_FILE_READWRITE = 2,
                IMG_FILE_READORWRITE = 3
            };

            enum IMG_QUERY
            {
                IMG_QUERY_iWRITE = 0,
                IMG_QUERY_iPG = 1,
                IMG_QUERY_iWRITEPG = 2,
                IMG_QUERY_iIMGTYPE = 3,
                IMG_QUERY_iDATTYPE = 4,
                IMG_QUERY_iRENDER = 5,
                IMG_QUERY_iKX = 6,
                IMG_QUERY_iNX = 7,
                IMG_QUERY_iNY = 8,
                IMG_QUERY_iNV = 9,
                IMG_QUERY_iNE = 10,
                IMG_QUERY_rXO = 11,
                IMG_QUERY_rYO = 12,
                IMG_QUERY_rDX = 13,
                IMG_QUERY_rDY = 14,
                IMG_QUERY_rROT = 15,
                IMG_QUERY_rBASE = 16,
                IMG_QUERY_rMULT = 17,
                IMG_QUERY_rCOMPRESSION_RATIO = 18
            };

            enum IMG_RELOCATE
            {
                IMG_RELOCATE_FIT = 0,
                IMG_RELOCATE_ASPECT = 1
            };

            enum IMU_BOOL_OLAP
            {
                IMU_BOOL_OLAP_AVE = 0,
                IMU_BOOL_OLAP_1 = 1,
                IMU_BOOL_OLAP_2 = 2
            };

            enum IMU_BOOL_OPT
            {
                IMU_BOOL_OPT_AND = 0,
                IMU_BOOL_OPT_OR = 1,
                IMU_BOOL_OPT_XOR = 2
            };

            enum IMU_BOOL_SIZING
            {
                IMU_BOOL_SIZING_MIN = 0,
                IMU_BOOL_SIZING_0 = 1,
                IMU_BOOL_SIZING_1 = 2,
                IMU_BOOL_SIZING_MAX = 3
            };

            enum IMU_DOUBLE_CRC_BITS
            {
                IMU_DOUBLE_CRC_BITS_EXACT = 0,
                IMU_DOUBLE_CRC_BITS_DEFAULT = 10,
                IMU_DOUBLE_CRC_BITS_MAX = 51
            };

            enum IMU_EXPAND_SHAPE
            {
                IMU_EXPAND_SHAPE_RECTANGLE = 0,
                IMU_EXPAND_SHAPE_SQUARE = 1
            };

            enum IMU_FILL_ROLLOPT
            {
                IMU_FILL_ROLLOPT_LINEAR = 1,
                IMU_FILL_ROLLOPT_SQUARE = 2
            };

            enum IMU_FILT_DUMMY
            {
                IMU_FILT_DUMMY_NO = 0,
                IMU_FILT_DUMMY_YES = 1
            };

            enum IMU_FILT_FILE
            {
                IMU_FILT_FILE_NO = 0,
                IMU_FILT_FILE_YES = 1
            };

            enum IMU_FILT_HZDRV
            {
                IMU_FILT_HZDRV_NO = 0,
                IMU_FILT_HZDRV_X = 1,
                IMU_FILT_HZDRV_Y = 2
            };

            enum IMU_FLOAT_CRC_BITS
            {
                IMU_FLOAT_CRC_BITS_EXACT = 0,
                IMU_FLOAT_CRC_BITS_DEFAULT = 7,
                IMU_FLOAT_CRC_BITS_MAX = 22
            };

            enum IMU_MASK
            {
                IMU_MASK_INSIDE = 0,
                IMU_MASK_OUTSIDE = 1
            };

            enum IMU_STAT_FORCED
            {
                IMU_STAT_FORCED_NO = 0,
                IMU_STAT_FORCED_YES = 1
            };

            enum IMU_TRANS
            {
                IMU_TRANS_DEFAULT = 0,
                IMU_TRANS_Y = 1,
                IMU_TRANS_X = -1
            };

            enum IMU_TREND
            {
                IMU_TREND_ALL = 0,
                IMU_TREND_EDGE = 1
            };

            enum IMU_WIND_COORD
            {
                IMU_WIND_GRID = 0,
                IMU_WIND_GROUND = 1
            };

            enum IMU_WIND_DUMMIES
            {
                IMU_WIND_DUMMY = 0,
                IMU_WIND_CLIP = 1
            };

            enum IMU_XYZ_INDEX
            {
                IMU_XYZ_INDEX_NO = 0,
                IMU_XYZ_INDEX_YES = 1
            };

            enum IMU_XYZ_LABEL
            {
                IMU_XYZ_LABEL_NO = 1,
                IMU_XYZ_LABEL_YES = 0
            };

            enum IPJ_3D_FLAG
            {
                IPJ_3D_FLAG_NONE = 0,
                IPJ_3D_FLAG_INVERTANGLES = 1,
                IPJ_3D_FLAG_INVERTZ = 2,
                IPJ_3D_FLAG_ORDER_ROTATION = 4
            };

            enum IPJ_3D_ROTATE
            {
                IPJ_3D_ROTATE_DEFAULT = 0,
                IPJ_3D_ROTATE_XYZ = 1,
                IPJ_3D_ROTATE_XZY = 2,
                IPJ_3D_ROTATE_YXZ = 3,
                IPJ_3D_ROTATE_YZX = 4,
                IPJ_3D_ROTATE_ZXY = 5,
                IPJ_3D_ROTATE_ZYX = 6
            };

            enum IPJ_CSP
            {
                IPJ_CSP_SCALE = 0,
                IPJ_CSP_FALSEEAST = 1,
                IPJ_CSP_FALSENORTH = 2,
                IPJ_CSP_LATORIGIN = 3,
                IPJ_CSP_LONORIGIN = 4,
                IPJ_CSP_PARALLEL_1 = 5,
                IPJ_CSP_PARALLEL_2 = 6,
                IPJ_CSP_AZIMUTH = 7,
                IPJ_CSP_ANGLE = 8,
                IPJ_CSP_POINTLAT_1 = 9,
                IPJ_CSP_POINTLON_1 = 10,
                IPJ_CSP_POINTLAT_2 = 11,
                IPJ_CSP_POINTLON_2 = 12
            };

            enum IPJ_NAME
            {
                IPJ_NAME_PCS = 0,
                IPJ_NAME_PROJECTION = 1,
                IPJ_NAME_METHOD = 2,
                IPJ_NAME_DATUM = 3,
                IPJ_NAME_ELLIPSOID = 4,
                IPJ_NAME_LDATUM = 5,
                IPJ_NAME_UNIT_ABBR = 6,
                IPJ_NAME_UNIT_FULL = 7,
                IPJ_NAME_TYPE = 8,
                IPJ_NAME_LLDATUM = 9,
                IPJ_NAME_METHOD_PARMS = 10,
                IPJ_NAME_METHOD_LABEL = 11,
                IPJ_NAME_DATUM_PARMS = 12,
                IPJ_NAME_LDATUM_PARMS = 13,
                IPJ_NAME_GEOID = 14,
                IPJ_NAME_LDATUMDESCRIPTION = 15,
                IPJ_NAME_METHOD_PARMS_NATIVE = 16,
                IPJ_NAME_ORIENTATION_PARMS = 17
            };

            enum IPJ_ORIENT
            {
                IPJ_ORIENT_DEFAULT = 0,
                IPJ_ORIENT_PLAN = 1,
                IPJ_ORIENT_SECTION = 2,
                IPJ_ORIENT_SECTION_NORMAL = 5,
                IPJ_ORIENT_DEPTH_SECTION = 3,
                IPJ_ORIENT_3D = 4,
                IPJ_ORIENT_3D_MATRIX = 7,
                IPJ_ORIENT_SECTION_CROOKED = 6
            };

            enum IPJ_PARM_LST
            {
                IPJ_PARM_LST_COORDINATESYSTEM = 0,
                IPJ_PARM_LST_DATUM = 1,
                IPJ_PARM_LST_PROJECTION = 2,
                IPJ_PARM_LST_UNITS = 3,
                IPJ_PARM_LST_LOCALDATUMDESCRIPTION = 4,
                IPJ_PARM_LST_LOCALDATUMNAME = 5,
                IPJ_PARM_LST_UNITSDESCRIPTION = 6
            };

            enum IPJ_TYPE
            {
                IPJ_TYPE_PRJ = 0,
                IPJ_TYPE_PCS = 1,
                IPJ_TYPE_GCS = 2,
                IPJ_TYPE_ANY = 3,
                IPJ_TYPE_NONE = 4,
                IPJ_TYPE_WRP = 5,
                IPJ_TYPE_TEST = 6
            };

            enum IPJ_UNIT
            {
                IPJ_UNIT_ABBREVIATION = 0,
                IPJ_UNIT_FULLNAME = 1
            };

            enum IPJ_WARP
            {
                IPJ_WARP_MATRIX = -1,
                IPJ_WARP_NONE = 0,
                IPJ_WARP_TRANS1 = 1,
                IPJ_WARP_TRANS2 = 2,
                IPJ_WARP_TRANS3 = 3,
                IPJ_WARP_QUAD = 4,
                IPJ_WARP_MULTIPOINT = 5,
                IPJ_WARP_LOG = 6,
                IPJ_WARP_MULTIPOINT_Y = 7
            };

            enum ITR_COLOR_MODEL
            {
                ITR_COLOR_MODEL_HSV = 1,
                ITR_COLOR_MODEL_RGB = 2,
                ITR_COLOR_MODEL_CMY = 3
            };

            enum ITR_POWER
            {
                ITR_POWER_10 = 0,
                ITR_POWER_EXP = 1
            };

            enum ITR_ZONE
            {
                ITR_ZONE_DEFAULT = 0,
                ITR_ZONE_LINEAR = 1,
                ITR_ZONE_NORMAL = 2,
                ITR_ZONE_EQUALAREA = 3,
                ITR_ZONE_SHADE = 4,
                ITR_ZONE_LOGLINEAR = 5
            };

            enum ITR_ZONE_MODEL
            {
                ITR_ZONE_MODEL_NOZONE = -1,
                ITR_ZONE_MODEL_NONE = 0,
                ITR_ZONE_MODEL_LINEAR = 1,
                ITR_ZONE_MODEL_NORMAL = 2,
                ITR_ZONE_MODEL_EQUAL = 3,
                ITR_MODEL_LOGLIN = 4
            };

            enum LAYOUT_CONSTR
            {
                LAYOUT_CONSTR_LEFT = 0,
                LAYOUT_CONSTR_RIGHT = 1,
                LAYOUT_CONSTR_TOP = 2,
                LAYOUT_CONSTR_BOTTOM = 3,
                LAYOUT_CONSTR_WIDTH = 4,
                LAYOUT_CONSTR_HEIGHT = 5,
                LAYOUT_CONSTR_HCENTER = 6,
                LAYOUT_CONSTR_VCENTER = 7,
                LAYOUT_CONSTR_MOVEL = 8,
                LAYOUT_CONSTR_MOVER = 9,
                LAYOUT_CONSTR_MOVET = 10,
                LAYOUT_CONSTR_MOVEB = 11
            };

            enum LST_ITEM
            {
                LST_ITEM_NAME = 0,
                LST_ITEM_VALUE = 1
            };

            enum LTB_CASE
            {
                LTB_CASE_INSENSITIVE = 0,
                LTB_CASE_SENSITIVE = 1
            };

            enum LTB_CONLST
            {
                LTB_CONLST_EXACT = 0,
                LTB_CONLST_ANY = 1
            };

            enum LTB_DELIM
            {
                LTB_DELIM_SPACE = 0,
                LTB_DELIM_COMMA = 1,
                LTB_DELIM_SPACECOMMA = 2
            };

            enum LTB_TYPE
            {
                LTB_TYPE_HEADER = 0,
                LTB_TYPE_NOHEADER = 1
            };

            enum DUPMAP
            {
                DUPMAP_BLANK = 0,
                DUPMAP_COPY = 1,
                DUPMAP_COPY_PRE62 = 2
            };

            enum MAP_EXPORT_BITS
            {
                MAP_EXPORT_BITS_24 = 24,
                MAP_EXPORT_BITS_GREY8 = 9,
                MAP_EXPORT_BITS_8 = 8,
                MAP_EXPORT_BITS_GREY4 = 5,
                MAP_EXPORT_BITS_4 = 4,
                MAP_EXPORT_BITS_GREY1 = 1,
                MAP_EXPORT_BITS_DEFAULT = 0
            };

            enum MAP_EXPORT_METHOD
            {
                MAP_EXPORT_METHOD_STANDARD = 0,
                MAP_EXPORT_METHOD_DIFFUSE = 1,
                MAP_EXPORT_METHOD_NONE = 2
            };

            enum MAP_LIST_MODE
            {
                MAP_LIST_MODE_ALL = 0,
                MAP_LIST_MODE_3D = 1,
                MAP_LIST_MODE_NOT3D = 2
            };

            enum MAP_OPEN
            {
                MAP_WRITENEW = 1,
                MAP_WRITEOLD = 2
            };

            enum MAPTEMPLATE_OPEN
            {
                MAPTEMPLATE_WRITENEW = 0,
                MAPTEMPLATE_EXIST = 1
            };

            enum META_CORE_ATTRIB
            {
                META_CORE_ATTRIB_Class_Description = -300,
                META_CORE_ATTRIB_Class_Application = -301,
                META_CORE_ATTRIB_Class_ReferenceURL = -302,
                META_CORE_ATTRIB_Class_Type = -303,
                META_CORE_ATTRIB_Type_Description = -304,
                META_CORE_ATTRIB_Type_ReferenceURL = -305,
                META_CORE_ATTRIB_Type_FixedSize = -306,
                META_CORE_ATTRIB_Type_ByteOrder = -307,
                META_CORE_ATTRIB_Type_MinValue = -308,
                META_CORE_ATTRIB_Type_MaxValue = -309,
                META_CORE_ATTRIB_Type_MaxSize = -310,
                META_CORE_ATTRIB_Type_ObjectClass = -311,
                META_CORE_ATTRIB_Type_hCreatS_Func = -312,
                META_CORE_ATTRIB_Type_sSerial_Func = -313,
                META_CORE_ATTRIB_Type_Enum_Value = -314,
                META_CORE_ATTRIB_Attrib_Visible = -315,
                META_CORE_ATTRIB_Attrib_Editable = -316,
                META_CORE_ATTRIB_Attrib_FlatName = -317
            };

            enum META_CORE_CLASS
            {
                META_CORE_CLASS_Base = -100,
                META_CORE_CLASS_Predefined = -101,
                META_CORE_CLASS_Attributes = -102,
                META_CORE_CLASS_ClassAttributes = -103,
                META_CORE_CLASS_TypeAttributes = -104,
                META_CORE_CLASS_ObjectAttributes = -105,
                META_CORE_CLASS_EnumAttributes = -106,
                META_CORE_CLASS_AttributeAttributes = -107,
                META_CORE_CLASS_ItemAttributes = -108,
                META_CORE_CLASS_Types = -109,
                META_CORE_CLASS_Enums = -110,
                META_CORE_CLASS_Enum_Bool = -111,
                META_CORE_CLASS_Enum_ClassType = -112
            };

            enum META_CORE_TYPE
            {
                META_CORE_TYPE_Bytes = -200,
                META_CORE_TYPE_Bool = -201,
                META_CORE_TYPE_I1 = -202,
                META_CORE_TYPE_U1 = -203,
                META_CORE_TYPE_I2 = -204,
                META_CORE_TYPE_U2 = -205,
                META_CORE_TYPE_I4 = -206,
                META_CORE_TYPE_U4 = -207,
                META_CORE_TYPE_I8 = -208,
                META_CORE_TYPE_U8 = -209,
                META_CORE_TYPE_R4 = -210,
                META_CORE_TYPE_R8 = -211,
                META_CORE_TYPE_String = -212,
                META_CORE_TYPE_Object = -213,
                META_CORE_TYPE_Enum = -214,
                META_CORE_TYPE_ClassType = -215
            };

            enum MAKER
            {
                MAKER_GX = 0
            };

            enum MVIEW_CLIP
            {
                CLIP_ON = 1,
                CLIP_OFF = 0
            };

            enum MVIEW_COLOR
            {
                C_BLACK = 33554432,
                C_RED = 33554687,
                C_GREEN = 33619712,
                C_BLUE = 50266112,
                C_CYAN = 50331903,
                C_MAGENTA = 50396928,
                C_YELLOW = 67043328,
                C_GREY = 41975936,
                C_LT_RED = 54542336,
                C_LT_GREEN = 54526016,
                C_LT_BLUE = 50348096,
                C_LT_CYAN = 50331712,
                C_LT_MAGENTA = 50348032,
                C_LT_YELLOW = 54525952,
                C_LT_GREY = 54542400,
                C_GREY10 = 51910680,
                C_GREY25 = 54542400,
                C_GREY50 = 41975936,
                C_WHITE = 50331648,
                C_TRANSPARENT = 0
            };

            enum MVIEW_CYLINDER3D
            {
                MVIEW_CYLINDER3D_OPEN = 0,
                MVIEW_CYLINDER3D_CLOSESTART = 1,
                MVIEW_CYLINDER3D_CLOSEEND = 2,
                MVIEW_CYLINDER3D_CLOSEALL = 3
            };

            enum MVIEW_DRAW
            {
                MVIEW_DRAW_POLYLINE = 0,
                MVIEW_DRAW_POLYGON = 1
            };

            enum MVIEW_DRAWOBJ3D_ENTITY
            {
                MVIEW_DRAWOBJ3D_ENTITY_POINTS = 0,
                MVIEW_DRAWOBJ3D_ENTITY_LINES = 1,
                MVIEW_DRAWOBJ3D_ENTITY_LINE_STRIPS = 2,
                MVIEW_DRAWOBJ3D_ENTITY_LINE_LOOPS = 3,
                MVIEW_DRAWOBJ3D_ENTITY_TRIANGLES = 4,
                MVIEW_DRAWOBJ3D_ENTITY_TRIANGLE_STRIPS = 5,
                MVIEW_DRAWOBJ3D_ENTITY_TRIANGLE_FANS = 6,
                MVIEW_DRAWOBJ3D_ENTITY_QUADS = 7,
                MVIEW_DRAWOBJ3D_ENTITY_QUADS_STRIPS = 8,
                MVIEW_DRAWOBJ3D_ENTITY_POLYGONS = 9
            };

            enum MVIEW_DRAWOBJ3D_MODE
            {
                MVIEW_DRAWOBJ3D_MODE_FLAT = 0,
                MVIEW_DRAWOBJ3D_MODE_SMOOTH = 1
            };

            enum MVIEW_EXTENT
            {
                MVIEW_EXTENT_ALL = 0,
                MVIEW_EXTENT_CLIP = 1,
                MVIEW_EXTENT_MAP = 2,
                MVIEW_EXTENT_VISIBLE = 3
            };

            enum MVIEW_FIT
            {
                MVIEW_FIT_MAP = 0,
                MVIEW_FIT_VIEW = 1
            };

            enum MVIEW_FONT_WEIGHT
            {
                MVIEW_FONT_WEIGHT_NORMAL = 0,
                MVIEW_FONT_WEIGHT_ULTRALIGHT = 1,
                MVIEW_FONT_WEIGHT_LIGHT = 2,
                MVIEW_FONT_WEIGHT_MEDIUM = 3,
                MVIEW_FONT_WEIGHT_BOLD = 4,
                MVIEW_FONT_WEIGHT_XBOLD = 5,
                MVIEW_FONT_WEIGHT_XXBOLD = 6
            };

            enum MVIEW_GRID
            {
                MVIEW_GRID_DOT = 0,
                MVIEW_GRID_LINE = 1,
                MVIEW_GRID_CROSS = 2
            };

            enum MVIEW_GROUP
            {
                MVIEW_GROUP_NEW = 1,
                MVIEW_GROUP_APPEND = 0
            };

            enum MVIEW_GROUP_LIST
            {
                MVIEW_GROUP_LIST_ALL = 0,
                MVIEW_GROUP_LIST_MARKED = 1,
                MVIEW_GROUP_LIST_VISIBLE = 2
            };

            enum MVIEW_HIDE
            {
                HIDE_ON = 1,
                HIDE_OFF = 0
            };

            enum MVIEW_IS
            {
                MVIEW_IS_AGG = 0,
                MVIEW_IS_MOVABLE = 3,
                MVIEW_IS_CSYMB = 4,
                MVIEW_IS_LINKED = 5,
                MVIEW_IS_MADE = 6,
                MVIEW_IS_HIDDEN = 7,
                MVIEW_IS_CLIPPED = 8,
                MVIEW_IS_META = 9,
                MVIEW_IS_VOXD = 10
            };

            enum MVIEW_LABEL_BOUND
            {
                MVIEW_LABEL_BOUND_NO = 0,
                MVIEW_LABEL_BOUND_YES = 1
            };

            enum MVIEW_LABEL_JUST
            {
                MVIEW_LABEL_JUST_TOP = 0,
                MVIEW_LABEL_JUST_BOTTOM = 1,
                MVIEW_LABEL_JUST_LEFT = 2,
                MVIEW_LABEL_JUST_RIGHT = 3
            };

            enum MVIEW_LABEL_ORIENT
            {
                MVIEW_LABEL_ORIENT_HORIZONTAL = 0,
                MVIEW_LABEL_ORIENT_TOP_RIGHT = 1,
                MVIEW_LABEL_ORIENT_TOP_LEFT = 2
            };

            enum MVIEW_OPEN
            {
                MVIEW_READ = 0,
                MVIEW_WRITENEW = 1,
                MVIEW_WRITEOLD = 2
            };

            enum MVIEW_PJ
            {
                MVIEW_PJ_OFF = 0,
                MVIEW_PJ_LOCATION = 1,
                MVIEW_PJ_ALL = 2,
                MVIEW_PJ_ON = 3
            };

            enum MVIEW_RELOCATE
            {
                MVIEW_RELOCATE_FIT = 0,
                MVIEW_RELOCATE_ASPECT = 1,
                MVIEW_RELOCATE_ASPECT_CENTER = 2
            };

            enum MVIEW_SMOOTH
            {
                MVIEW_SMOOTH_NEAREST = 0,
                MVIEW_SMOOTH_CUBIC = 1,
                MVIEW_SMOOTH_AKIMA = 2
            };

            enum MVIEW_TILE
            {
                MVIEW_TILE_RECTANGULAR = 0,
                MVIEW_TILE_DIAGONAL = 1,
                MVIEW_TILE_TRIANGULAR = 2,
                MVIEW_TILE_RANDOM = 3
            };

            enum MVIEW_UNIT
            {
                MVIEW_UNIT_VIEW = 0,
                MVIEW_UNIT_PLOT = 1,
                MVIEW_UNIT_MM = 2,
                MVIEW_UNIT_VIEW_UNWARPED = 3
            };

            enum MVIEW_EXTENT_UNIT
            {
                MVIEW_EXTENT_UNIT_VIEW = MVIEW_UNIT_VIEW,
                MVIEW_EXTENT_UNIT_PLOT = MVIEW_UNIT_PLOT,
                MVIEW_EXTENT_UNIT_MM = MVIEW_UNIT_MM,
                MVIEW_EXTENT_UNIT_VIEW_UNWARPED = MVIEW_UNIT_VIEW_UNWARPED
            };

            enum TEXT_REF
            {
                TEXT_REF_BOTTOM_LEFT = 0,
                TEXT_REF_BOTTOM_CENTER = 1,
                TEXT_REF_BOTTOM_RIGHT = 2,
                TEXT_REF_MIDDLE_LEFT = 3,
                TEXT_REF_MIDDLE_CENTER = 4,
                TEXT_REF_MIDDLE_RIGHT = 5,
                TEXT_REF_TOP_LEFT = 6,
                TEXT_REF_TOP_CENTER = 7,
                TEXT_REF_TOP_RIGHT = 8
            };

            enum MVIEW_3D_RENDER
            {
                MVIEW_3D_RENDER_BACKFACES = 1,
                MVIEW_3D_DONT_SCALE_GEOMETRY = 2
            };

            enum EMLAY_GEOMETRY
            {
                EMLAY_V_COPLANAR = 0,
                EMLAY_H_COPLANAR = 1,
                EMLAY_V_COAXIAL = 2
            };

            enum ARROW_ALIGNMENT
            {
                ARROW_ALIGNMENT_HORIZONTAL = 0,
                ARROW_ALIGNMENT_VERTICAL = 1
            };

            enum BARCHART_LABEL
            {
                BARCHART_LABEL_NO = 0,
                BARCHART_LABEL_BELOWX = 1,
                BARCHART_LABEL_ABOVEX = 2,
                BARCHART_LABEL_PEND = 3,
                BARCHART_LABEL_NEND = 4,
                BARCHART_LABEL_ALTERNAT1 = 5,
                BARCHART_LABEL_ALTERNAT2 = 6
            };

            enum COLORBAR_LABEL
            {
                COLORBAR_LABEL_HORIZONTAL = 0,
                COLORBAR_LABEL_VERTICAL = 1
            };

            enum COLORBAR_STYLE
            {
                COLORBAR_STYLE_NONE = 0,
                COLORBAR_STYLE_MAXMIN = 1
            };

            enum MVU_ORIENTATION
            {
                MVU_ORIENTATION_VERTICAL = 0,
                MVU_ORIENTATION_HORIZONTAL = 1
            };

            enum MVU_DIVISION_STYLE
            {
                MVU_DIVISION_STYLE_NONE = 0,
                MVU_DIVISION_STYLE_LINES = 1,
                MVU_DIVISION_STYLE_TICS = 2
            };

            enum MVU_ARROW
            {
                MVU_ARROW_SOLID = 1,
                MVU_ARROW_FIXED = 2
            };

            enum MVU_FLIGHT_COMPASS
            {
                MVU_FLIGHT_COMPASS_NONE = -1,
                MVU_FLIGHT_COMPASS_EAST = 0,
                MVU_FLIGHT_COMPASS_NORTH = 1,
                MVU_FLIGHT_COMPASS_WEST = 2,
                MVU_FLIGHT_COMPASS_SOUTH = 3
            };

            enum MVU_FLIGHT_DUMMIES
            {
                MVU_FLIGHT_DUMMIES_NOTINCLUDED = 0,
                MVU_FLIGHT_DUMMIES_INCLUDED = 1
            };

            enum MVU_FLIGHT_LOCATE
            {
                MVU_FLIGHT_LOCATE_NONE = 0,
                MVU_FLIGHT_LOCATE_END = 1,
                MVU_FLIGHT_LOCATE_ABOVE = 2,
                MVU_FLIGHT_LOCATE_BELOW = 3,
                MVU_FLIGHT_DIRECTION = 8
            };

            enum MVU_VOX_SURFACE_METHOD
            {
                MVU_VOX_SURFACE_METHOD_MARCHING_CUBES = 0
            };

            enum MVU_VOX_SURFACE_OPTION
            {
                MVU_VOX_SURFACE_OPTION_OPEN = 0,
                MVU_VOX_SURFACE_OPTION_CLOSED = 1
            };

            enum MVU_TEXTBOX
            {
                MVU_TEXTBOX_LEFT = 0,
                MVU_TEXTBOX_CENTER = 1,
                MVU_TEXTBOX_RIGHT = 2
            };

            enum MVU_VPOINT
            {
                MVU_VPOINT_SHARP = 0,
                MVU_VPOINT_MEDIUM = 1,
                MVU_VPOINT_BLUNT = 2
            };

            enum MVU_VPOS
            {
                MVU_VPOS_HEAD = 0,
                MVU_VPOS_MIDDLE = 1,
                MVU_VPOS_TAIL = 2
            };

            enum MVU_VSIZE
            {
                MVU_VSIZE_NOHEAD = 0,
                MVU_VSIZE_SMALLHEAD = 1,
                MVU_VSIZE_MEDIUMHEAD = 2,
                MVU_VSIZE_LARGEHEAD = 3,
                MVU_VSIZE_NOTAIL = 4
            };

            enum MVU_VSTYLE
            {
                MVU_VSTYLE_LINES = 0,
                MVU_VSTYLE_BARB = 1,
                MVU_VSTYLE_TRIANGLE = 2
            };

            enum PG_3D_DIR
            {
                PG_3D_DIR_XYZ = 0,
                PG_3D_DIR_YXZ = 1,
                PG_3D_DIR_XZY = 2,
                PG_3D_DIR_YZX = 3,
                PG_3D_DIR_ZXY = 4,
                PG_3D_DIR_ZYX = 5
            };

            enum PG_BF_CONV
            {
                PG_BF_CONV_NONE = 0,
                PG_BF_CONV_SWAP = 1
            };

            enum PJ_ELEVATION
            {
                PJ_ELEVATION_NONE = 0,
                PJ_ELEVATION_GEOCENTRIC = 1,
                PJ_ELEVATION_GEOID = 2
            };

            enum PJ_RECT
            {
                PJ_RECT_XY2LL = 0,
                PJ_RECT_LL2XY = 1
            };

            enum PLY_CLIP
            {
                PLY_CLIP_NO_INTERSECT = 0,
                PLY_CLIP_INTERSECT = 1,
                PLY_CLIP_A_IN_B = 2,
                PLY_CLIP_B_IN_A = 3
            };

            enum PLY_LINE_CLIP
            {
                PLY_LINE_CLIP_INSIDE = 0,
                PLY_LINE_CLIP_NO_INTERSECT = 0,
                PLY_LINE_CLIP_OUTSIDE = 1,
                PLY_LINE_CLIP_ERROR = 2
            };

            enum REG_MERGE
            {
                REG_MERGE_REPLACE = 0,
                REG_MERGE_ADD = 1
            };

            enum SBF_OPEN
            {
                SBF_READ = 0,
                SBF_READWRITE_NEW = 1,
                SBF_READWRITE_OLD = 2
            };

            enum SBF_TYPE
            {
                SBF_TYPE_DIRS = 1,
                SBF_TYPE_FILES = 2,
                SBF_TYPE_BOTH = 3
            };

            enum ST_INFO
            {
                ST_ITEMS = 0,
                ST_NPOS = 1,
                ST_NZERO = 22,
                ST_DUMMIES = 2,
                ST_MIN = 3,
                ST_MAX = 4,
                ST_RANGE = 5,
                ST_MEAN = 6,
                ST_MEDIAN = 7,
                ST_MODE = 8,
                ST_GEOMEAN = 9,
                ST_VARIANCE = 10,
                ST_STDDEV = 11,
                ST_STDERR = 12,
                ST_SKEW = 13,
                ST_KURTOSIS = 14,
                ST_BASE = 15,
                ST_SUM = 16,
                ST_SUM2 = 17,
                ST_SUM3 = 18,
                ST_SUM4 = 19,
                ST_MINPOS = 21,
                ST_HIST_MAXCOUNT = 100
            };

            enum ST2_CORRELATION
            {
                ST2_CORR = 0,
                ST2_PCORR = 1
            };

            enum FILE_EXT
            {
                FILE_EXT_ADD_IF_NONE = 0,
                FILE_EXT_FORCE = 1
            };

            enum STR_CASE
            {
                STR_CASE_TOLERANT = 0,
                STR_CASE_SENSITIVE = 1
            };

            enum STR_ESCAPE
            {
                ESCAPE_CONVERT = 0,
                ESCAPE_REPLACE = 1
            };

            enum STR_FILE_PART
            {
                STR_FILE_PART_NAME = 0,
                STR_FILE_PART_EXTENSION = 1,
                STR_FILE_PART_DIRECTORY = 2,
                STR_FILE_PART_VOLUME = 3,
                STR_FILE_PART_QUALIFIERS = 4,
                STR_FILE_PART_NAME_EXTENSION = 5,
                STR_FILE_PART_FULLPATH_NO_QUALIFIERS = 6
            };

            enum STR_JUSTIFY
            {
                STR_JUSTIFY_LEFT = 0,
                STR_JUSTIFY_CENTER = 1,
                STR_JUSTIFY_RIGHT = 2
            };

            enum STR_TRIM
            {
                STR_TRIMRIGHT = 1,
                STR_TRIMLEFT = 2,
                STR_TRIMBOTH = 3
            };

            enum SURFACE_OPEN
            {
                SURFACE_OPEN_READ = 0,
                SURFACE_OPEN_READWRITE = 1
            };

            enum SURFACERENDER_MODE
            {
                SURFACERENDER_SMOOTH = 0,
                SURFACERENDER_FILL = 1,
                SURFACERENDER_EDGES = 2
            };

            enum ARC_LICENSE
            {
                ARC_LICENSE_ENGINENOTPRESENT = 0,
                ARC_LICENSE_DESKTOPENGINE = 1,
                ARC_LICENSE_ARCVIEW = 2,
                ARC_LICENSE_ARCEDITOR = 3,
                ARC_LICENSE_ARCINFO = 4,
                ARC_LICENSE_ARCSERVER = 5
            };

            enum GEO_DIRECTORY
            {
                GEO_DIRECTORY_NONE = 0,
                GEO_DIRECTORY_GEOSOFT = 1,
                GEO_DIRECTORY_BIN = 2,
                GEO_DIRECTORY_GER = 3,
                GEO_DIRECTORY_OMN = 4,
                GEO_DIRECTORY_TBL = 5,
                GEO_DIRECTORY_FONTS = 6,
                GEO_DIRECTORY_GX = 7,
                GEO_DIRECTORY_GS = 8,
                GEO_DIRECTORY_APPS = 9,
                GEO_DIRECTORY_ETC = 10,
                GEO_DIRECTORY_HLP = 11,
                GEO_DIRECTORY_USER_CSV = 14,
                GEO_DIRECTORY_USER_LIC = 15,
                GEO_DIRECTORY_USER_INI = 16,
                GEO_DIRECTORY_USER_TEMP = 17,
                GEO_DIRECTORY_USER_ETC = 18,
                GEO_DIRECTORY_IMG = 19,
                GEO_DIRECTORY_BAR = 20,
                GEO_DIRECTORY_MAPTEMPLATE = 22,
                GEO_DIRECTORY_USER_MAPTEMPLATE = 23,
                GEO_DIRECTORY_PYGX = 24,
                GEO_DIRECTORY_USER_PYGX = 25,
                GEO_DIRECTORY_USER_GX = 26
            };

            enum REG_DOMAIN
            {
                REG_DOMAIN_MACHINE = 0,
                REG_DOMAIN_USER = 1
            };

            enum SHELL_EXECUTE
            {
                SHELL_SW_HIDE = 0,
                SHELL_SW_SHOWNORMAL = 1,
                SHELL_SW_SHOWMINIMIZED = 2,
                SHELL_SW_SHOWMAXIMIZED = 3,
                SHELL_SW_SHOWNOACTIVATE = 4,
                SHELL_SW_SHOW = 5,
                SHELL_SW_MINIMIZE = 6,
                SHELL_SW_SHOWMINNOACTIVE = 7,
                SHELL_SW_SHOWNA = 8,
                SHELL_SW_RESTORE = 9,
                SHELL_SW_SHOWDEFAULT = 10,
                SHELL_SW_FORCEMINIMIZE = 11
            };

            enum SYS_DIR
            {
                SYS_DIR_LOCAL = 0,
                SYS_DIR_GEOSOFT = 1,
                SYS_DIR_USER = 2,
                SYS_DIR_GEOTEMP = 3,
                SYS_DIR_WINDOWS = 4,
                SYS_DIR_SYSTEM = 5,
                SYS_DIR_LICENSE = 6,
                SYS_DIR_RESOURCEFILES = 7,
                SYS_DIR_GEOSOFT_BAR = 100,
                SYS_DIR_GEOSOFT_BIN = 101,
                SYS_DIR_GEOSOFT_CSV = 102,
                SYS_DIR_GEOSOFT_CSV_ALIASES = 103,
                SYS_DIR_GEOSOFT_DATA = 104,
                SYS_DIR_GEOSOFT_DBG = 105,
                SYS_DIR_GEOSOFT_ENCRYPTEDFILES = 106,
                SYS_DIR_GEOSOFT_ETC = 107,
                SYS_DIR_GEOSOFT_FONTS = 108,
                SYS_DIR_GEOSOFT_GER = 109,
                SYS_DIR_GEOSOFT_GS = 110,
                SYS_DIR_GEOSOFT_GX = 111,
                SYS_DIR_GEOSOFT_HLP = 112,
                SYS_DIR_GEOSOFT_IMG = 113,
                SYS_DIR_GEOSOFT_INI = 114,
                SYS_DIR_GEOSOFT_MAPTEMPLATE = 115,
                SYS_DIR_GEOSOFT_OMN = 116,
                SYS_DIR_GEOSOFT_PAGE = 117,
                SYS_DIR_GEOSOFT_SCHEMA = 118,
                SYS_DIR_GEOSOFT_SPEC_INI = 119,
                SYS_DIR_GEOSOFT_STYLESHEETS = 120,
                SYS_DIR_GEOSOFT_TBL = 121,
                SYS_DIR_USER_CSV = 200,
                SYS_DIR_USER_ETC = 201,
                SYS_DIR_USER_GS = 202,
                SYS_DIR_USER_HLP = 203,
                SYS_DIR_USER_INI = 204,
                SYS_DIR_USER_LIC = 205,
                SYS_DIR_USER_MAPTEMPLATE = 206,
                SYS_DIR_USER_OMN = 207,
                SYS_DIR_USER_BAR = 214,
                SYS_DIR_USER_IMG = 215,
                SYS_DIR_USER_STACKS = 209,
                SYS_DIR_USER_TEMP = 210,
                SYS_DIR_USER_SERVICES = 211,
                SYS_DIR_USER_STYLESHEETS = 212
            };

            enum SYS_FONT
            {
                SYS_FONT_GFN = 1,
                SYS_FONT_TT = 0
            };

            enum SYS_INFO
            {
                SYS_INFO_VERSION_MAJOR = 0,
                SYS_INFO_VERSION_MINOR = 1,
                SYS_INFO_VERSION_SP = 2,
                SYS_INFO_BUILD_NUMBER = 3,
                SYS_INFO_BUILD_LABEL = 4,
                SYS_INFO_VERSION_LABEL = 5,
                SYS_INFO_PRODUCTNAME = 6,
                SYS_INFO_SERVERNAME = 7,
                SYS_INFO_LEGALCOPYRIGHT = 8,
                SYS_INFO_REGISTRY = 9,
                SYS_INFO_REGISTRY_ENVIRONMENT = 10,
                SYS_INFO_REGISTRY_SUPPORT = 11,
                SYS_INFO_REGISTRY_INTERAPP = 12,
                SYS_INFO_OIS_REGISTRY = 13,
                SYS_INFO_TEST_REGISTRY = 14
            };

            enum SYS_LINEAGE_SOURCE
            {
                SYS_LINEAGE_SOURCE_MAP = 0,
                SYS_LINEAGE_SOURCE_MXD = 1,
                SYS_LINEAGE_SOURCE_DB = 2,
                SYS_LINEAGE_SOURCE_MAPTEMPLATE = 3,
                SYS_LINEAGE_SOURCE_GRID = 4,
                SYS_LINEAGE_SOURCE_VOXEL = 5
            };

            enum SYS_MENU_CLEAR
            {
                SYS_MENU_CLEAR_ALL = 0,
                SYS_MENU_CLEAR_DEFAULT = 1
            };

            enum SYS_PATH
            {
                SYS_PATH_LOCAL = 0,
                SYS_PATH_GEOSOFT = 1,
                SYS_PATH_GEOSOFT_USER = 2,
                SYS_PATH_GEOTEMP = 3,
                SYS_PATH_WINDOWS = 4,
                SYS_PATH_SYSTEM = 5,
                SYS_PATH_LICENSE = 6,
                SYS_PATH_RESOURCEFILES = 7,
                SYS_PATH_GEOSOFT_BAR = 100,
                SYS_PATH_GEOSOFT_BIN = 101,
                SYS_PATH_GEOSOFT_CSV = 102,
                SYS_PATH_GEOSOFT_CSV_ALIASES = 103,
                SYS_PATH_GEOSOFT_DATA = 104,
                SYS_PATH_GEOSOFT_DBG = 105,
                SYS_PATH_GEOSOFT_ENCRYPTEDFILES = 106,
                SYS_PATH_GEOSOFT_ETC = 107,
                SYS_PATH_GEOSOFT_FONTS = 108,
                SYS_PATH_GEOSOFT_GER = 109,
                SYS_PATH_GEOSOFT_GS = 110,
                SYS_PATH_GEOSOFT_PYGX = 126,
                SYS_PATH_GEOSOFT_GX = 111,
                SYS_PATH_GEOSOFT_HLP = 112,
                SYS_PATH_GEOSOFT_IMG = 113,
                SYS_PATH_GEOSOFT_INI = 114,
                SYS_PATH_GEOSOFT_MAPTEMPLATE = 115,
                SYS_PATH_GEOSOFT_OMN = 116,
                SYS_PATH_GEOSOFT_PAGE = 117,
                SYS_PATH_GEOSOFT_SCHEMA = 118,
                SYS_PATH_GEOSOFT_SPEC_INI = 119,
                SYS_PATH_GEOSOFT_STYLESHEETS = 120,
                SYS_PATH_GEOSOFT_TBL = 121,
                SYS_PATH_GEOSOFT_USER_CSV = 200,
                SYS_PATH_GEOSOFT_USER_ETC = 201,
                SYS_PATH_GEOSOFT_USER_GS = 202,
                SYS_PATH_GEOSOFT_USER_GX = 217,
                SYS_PATH_GEOSOFT_USER_PYGX = 216,
                SYS_PATH_GEOSOFT_USER_HLP = 203,
                SYS_PATH_GEOSOFT_USER_INI = 204,
                SYS_PATH_GEOSOFT_USER_LIC = 205,
                SYS_PATH_GEOSOFT_USER_MAPTEMPLATE = 206,
                SYS_PATH_GEOSOFT_USER_OMN = 207,
                SYS_PATH_GEOSOFT_USER_STACKS = 209,
                SYS_PATH_GEOSOFT_USER_TEMP = 210,
                SYS_PATH_USER_SERVICES = 211,
                SYS_PATH_USER_STYLESHEETS = 212
            };

            enum SYS_RUN_DISPLAY
            {
                SYS_RUN_DISPLAY_WINDOW = 0,
                SYS_RUN_DISPLAY_MINIMIZE = 8,
                SYS_RUN_DISPLAY_FULLSCREEN = 16
            };

            enum SYS_RUN_HOLD
            {
                SYS_RUN_HOLD_NEVER = 0,
                SYS_RUN_HOLD_ONERROR = 512,
                SYS_RUN_HOLD_ALWAYS = 1024
            };

            enum SYS_RUN_TYPE
            {
                SYS_RUN_TYPE_DOS = 1,
                SYS_RUN_TYPE_EXE = 0,
                SYS_RUN_TYPE_WINDOWS = 2
            };

            enum SYS_RUN_WIN
            {
                SYS_RUN_WIN_NOWAIT = 0,
                SYS_RUN_WIN_WAIT = 2048
            };

            enum SYS_SEARCH_PATH
            {
                FIND_LOCAL_GEOSOFT = 0,
                FIND_GEOSOFT = 1,
                FIND_LOCAL = 2,
                FIND_SHORT = 1024
            };

            enum SYS_ENCRYPTION_KEY
            {
                SYS_ENCRYPTION_KEY_GEOSOFT_ID = 0,
                SYS_ENCRYPTION_KEY_GLOBAL_ID = 1
            };

            enum TB_SEARCH
            {
                TB_SEARCH_BINARY = 0,
                TB_SEARCH_LINEAR = 1
            };

            enum TPAT_STRING_SIZE
            {
                TPAT_CODE_SIZE = 21,
                TPAT_LABEL_SIZE = 32,
                TPAT_DESC_SIZE = 128,
                TPAT_SYMBFONT_SIZE = 32
            };

            enum USERMETA_FORMAT
            {
                USERMETA_FORMAT_DEFAULT = -1,
                USERMETA_FORMAT_ISO = 0,
                USERMETA_FORMAT_FGDC = 1
            };

            enum VA_AVERAGE
            {
                VA_AVERAGE_ROWS = 0,
                VA_AVERAGE_COLUMNS = 1
            };

            enum VA_OBJECT
            {
                VA_ROW = 0,
                VA_COL = 1
            };

            enum VOX_DIR
            {
                VOX_DIR_XY = 0,
                VOX_DIR_XZ = 1,
                VOX_DIR_YZ = 2
            };

            enum VOX_DIRECTION
            {
                VOX_3D_DIR_XYZ = 0,
                VOX_3D_DIR_YXZ = 1,
                VOX_3D_DIR_XZY = 2,
                VOX_3D_DIR_YZX = 3,
                VOX_3D_DIR_ZXY = 4,
                VOX_3D_DIR_ZYX = 5
            };

            enum VOX_FILTER3D
            {
                VOX_FILTER3D_FILE = 0,
                VOX_FILTER3D_SMOOTHING = 1,
                VOX_FILTER3D_LAPLACE = 2,
                VOX_FILTER3D_X_GRADIENT = 3,
                VOX_FILTER3D_Y_GRADIENT = 4,
                VOX_FILTER3D_Z_GRADIENT = 5,
                VOX_FILTER3D_TOTAL_GRADIENT = 6
            };

            enum VOX_GOCAD_ORIENTATION
            {
                VOX_GOCAD_ORIENTATIONS_NORMAL = 0,
                VOX_GOCAD_ORIENTATIONS_INVERTED = 1,
                VOX_GOCAD_ORIENTATIONS_NORMAL_ZFIRST = 2,
                VOX_GOCAD_ORIENTATIONS_INVERTED_ZFIRST = 3
            };

            enum VOX_GRID_LOGOPT
            {
                VOX_GRID_LOGOPT_LINEAR = 0,
                VOX_GRID_LOGOPT_LOG_SAVELINEAR = -1,
                VOX_GRID_LOGOPT_LOGLINEAR_SAVELINEAR = -2,
                VOX_GRID_LOGOPT_LOG_SAVELOG = 1,
                VOX_GRID_LOGOPT_LOGLINEAR_SAVELOG = 2
            };

            enum VOX_ORIGIN
            {
                VOX_ORIGIN_BOTTOM = 0,
                VOX_ORIGIN_TOP = 1
            };

            enum VOX_SLICE_MODE
            {
                VOX_SLICE_MODE_LINEAR = 1,
                VOX_SLICE_MODE_NEAREST = 0
            };

            enum VOX_VECTORVOX_IMPORT
            {
                VOX_VECTORVOX_XYZ = 0,
                VOX_VECTORVOX_UVW = 1,
                VOX_VECTORVOX_AID = 2
            };

            enum VOXE_EVAL
            {
                VOXE_EVAL_NEAR = 0,
                VOXE_EVAL_INTERP = 1,
                VOXE_EVAL_BEST = 2
            };

            enum BLOCK_MODEL_VARIABLE_TYPE
            {
                BLOCK_MODEL_NUMERIC_VARIABLE = 1,
                BLOCK_MODEL_STRING_VARIABLE = 2
            };

            enum VV_DOUBLE_CRC_BITS
            {
                VV_DOUBLE_CRC_BITS_EXACT = 0,
                VV_DOUBLE_CRC_BITS_DEFAULT = 10,
                VV_DOUBLE_CRC_BITS_MAX = 51
            };

            enum VV_FLOAT_CRC_BITS
            {
                VV_FLOAT_CRC_BITS_EXACT = 0,
                VV_FLOAT_CRC_BITS_DEFAULT = 7,
                VV_FLOAT_CRC_BITS_MAX = 22
            };

            enum VV_LOG_BASE
            {
                VV_LOG_BASE_10 = 0,
                VV_LOG_BASE_E = 1
            };

            enum VV_LOG_NEGATIVE
            {
                VV_LOG_NEGATIVE_NO = 0,
                VV_LOG_NEGATIVE_YES = 1
            };

            enum VV_LOOKUP
            {
                VV_LOOKUP_EXACT = 0,
                VV_LOOKUP_NEAREST = 1,
                VV_LOOKUP_INTERPOLATE = 2,
                VV_LOOKUP_NEARESTCLOSE = 3,
                VV_LOOKUP_INTERPCLOSE = 4
            };

            enum VV_MASK
            {
                VV_MASK_INSIDE = 0,
                VV_MASK_OUTSIDE = 1
            };

            enum VV_ORDER
            {
                VV_ORDER_NONE = 0,
                VV_ORDER_INCREASING = 1,
                VV_ORDER_DECREASING = 2
            };

            enum VV_SORT
            {
                VV_SORT_ASCENDING = 0,
                VV_SORT_DESCENDING = 1
            };

            enum VV_WINDOW
            {
                VV_WINDOW_DUMMY = 0,
                VV_WINDOW_LIMIT = 1
            };

            enum WA_ENCODE
            {
                WA_ENCODE_ANSI = 0,
                WA_ENCODE_RAW = 1,
                WA_ENCODE_UTF8 = 2,
                WA_ENCODE_UTF8_NOHEADER = 3,
                WA_ENCODE_UTF16_NOHEADER = 4
            };

            enum WA_OPEN
            {
                WA_NEW = 0,
                WA_APPEND = 1
            };


            template<typename T>
            struct gs_cpp_type
            {
            private:
                gs_cpp_type() {}

            public:
                static GS_TYPES type()
                {
                    static_assert(false, "Type does not map to supported GS_TYPES");
                }
            };

            template<> struct gs_cpp_type<int8_t>
            {
                static GS_TYPES type()
                {
                    return GS_BYTE;
                }
            };
            template<> struct gs_cpp_type<uint8_t>
            {
                static GS_TYPES type()
                {
                    return GS_UBYTE;
                }
            };
            template<> struct gs_cpp_type<int16_t>
            {
                static GS_TYPES type()
                {
                    return GS_SHORT;
                }
            };
            template<> struct gs_cpp_type<uint16_t>
            {
                static GS_TYPES type()
                {
                    return GS_USHORT;
                }
            };
            template<> struct gs_cpp_type<int32_t>
            {
                static GS_TYPES type()
                {
                    return GS_LONG;
                }
            };
            template<> struct gs_cpp_type<uint32_t>
            {
                static GS_TYPES type()
                {
                    return GS_ULONG;
                }
            };
            template<> struct gs_cpp_type<int64_t>
            {
                static GS_TYPES type()
                {
                    return GS_LONG64;
                }
            };
            template<> struct gs_cpp_type<uint64_t>
            {
                static GS_TYPES type()
                {
                    return GS_ULONG64;
                }
            };
            template<> struct gs_cpp_type<float>
            {
                static GS_TYPES type()
                {
                    return GS_FLOAT;
                }
            };
            template<> struct gs_cpp_type<double>
            {
                static GS_TYPES type()
                {
                    return GS_DOUBLE;
                }
            };




            static const uint32_t CRC_INIT_VALUE = 4294967295;


            namespace GEO_DUMMY
            {
                static const int32_t iDUMMY = -2147483647;
                static const double rDUMMY = -1.0E32;
            }

            namespace GEO_FULL_LIMITS
            {
                static const int8_t GS_S1MX = 127;
                static const int8_t GS_S1MN = -126;
                static const int8_t GS_S1DM = -127;
                static const uint8_t GS_U1MX = 254U;
                static const uint8_t GS_U1MN = 0U;
                static const uint8_t GS_U1DM = 255U;
                static const int16_t GS_S2MX = 32767;
                static const int16_t GS_S2MN = -32766;
                static const int16_t GS_S2DM = -32767;
                static const uint32_t GS_U2MX = 65534U;
                static const uint32_t GS_U2MN = 0U;
                static const uint32_t GS_U2DM = 65535U;
                static const int32_t GS_S4MX = 2147483647L;
                static const int32_t GS_S4MN = -2147483646L;
                static const int32_t GS_S4DM = -2147483647L;
                static const uint32_t GS_U4MX = 0xFFFFFFFE;
                static const uint32_t GS_U4MN = 0x00000000;
                static const uint32_t GS_U4DM = 0xFFFFFFFF;
                static const int64_t GS_S8MX = 0x7FFFFFFFFFFFFFFF;
                static const int64_t GS_S8MN = 0x8000000000000001;
                static const int64_t GS_S8DM = 0x8000000000000000;
                static const uint64_t GS_U8MX = 0xFFFFFFFFFFFFFFFE;
                static const uint64_t GS_U8MN = 0x0000000000000000;
                static const uint64_t GS_U8DM = 0xFFFFFFFFFFFFFFFF;
                static const float GS_R4MX = 1.0E32f;
                static const float GS_R4MN = -0.9E32f;
                static const float GS_R4DM = -1.0E32f;
                static const double GS_R8MX = 1.0E32;
                static const double GS_R8MN = -0.9E+32;
                static const double GS_R8DM = -1.0E+32;
                static const float GS_R4EPSILON = 1.0E-32f;
                static const double GS_R8EPSILON = 1.0E-32;
            }

            namespace GEO_LIMITS
            {
                static const int32_t iMIN = -2147483646;
                static const int32_t iMAX = 2147483647;
                static const double rMIN = -0.9E32;
                static const double rMAX = 1.0E32;
            }

            namespace SYS_CRYPT_KEY
            {
                static const gx_string_char_type* LICENSE_KEY = gx_string_literal("{***LICENSE_KEY***}");
                static const gx_string_char_type* COMPUTER_ID = gx_string_literal("{***COMPUTER_ID***}");
                static const gx_string_char_type* GLOBAL_ID = gx_string_literal("{***GLOBAL_COMPUTER_ID***}");
            }


            static const int32_t CHIMERA_MAX_CHAN = 128;


            namespace DH_DEFAULT_FILENAMES
            {
                static const gx_string_char_type* ROCKCODE_FILE = gx_string_literal("agso.csv");
                static const gx_string_char_type* STRUCTURECODE_FILE = gx_string_literal("structcodes.csv");
            }


            static const int32_t STR_DH_HOLES = 1048576;



            static const int32_t DH_DEFINE_PLAN = 1;


            namespace DH_DEFINE_SECT
            {
                static const int32_t NS = 1;
                static const int32_t EW = 2;
                static const int32_t ANGLED = 3;
            }


            static const int32_t MAX_PROF_WND = 5;



            static const gx_string_char_type* SEMPLOT_GROUP_CLASS = gx_string_literal("Semplot");



            static const gx_string_char_type* DB_ACTIVITY_BLOB = gx_string_literal("OE.DB_ACTIVITY_LOG");



            static const int32_t DB_GROUP_CLASS_SIZE = 16;



            static const int32_t DB_SYMB_NAME_SIZE = STR_DB_SYMBOL;



            static const int32_t NULLSYMB = -1;


            namespace MAP_EXPORT_FORMAT
            {
                static const gx_string_char_type* PLT = gx_string_literal("PLT");
                static const gx_string_char_type* SHP = gx_string_literal("SHP");
                static const gx_string_char_type* DXF12 = gx_string_literal("DXF12");
                static const gx_string_char_type* DXF13 = gx_string_literal("DXF13");
                static const gx_string_char_type* GTIFF = gx_string_literal("GTIFF");
                static const gx_string_char_type* MTIFF = gx_string_literal("MTIFF");
                static const gx_string_char_type* ATIFF = gx_string_literal("ATIFF");
                static const gx_string_char_type* GEO = gx_string_literal("GEO");
                static const gx_string_char_type* ERM = gx_string_literal("ERM");
                static const gx_string_char_type* KMZ = gx_string_literal("KMZ");
            }

            namespace MAP_EXPORT_RASTER_FORMAT
            {
                static const gx_string_char_type* EMF = gx_string_literal("EMF");
                static const gx_string_char_type* BMP = gx_string_literal("BMP");
                static const gx_string_char_type* JPEGL = gx_string_literal("JPEGL");
                static const gx_string_char_type* JPEG = gx_string_literal("JPEG");
                static const gx_string_char_type* JPEGH = gx_string_literal("JPEGH");
                static const gx_string_char_type* GIF = gx_string_literal("GIF");
                static const gx_string_char_type* PCX = gx_string_literal("PCX");
                static const gx_string_char_type* PNG = gx_string_literal("PNG");
                static const gx_string_char_type* EPS = gx_string_literal("EPS");
                static const gx_string_char_type* TIFF = gx_string_literal("TIFF");
            }


            static const int32_t H_META_INVALID_TOKEN = -1;



            static const int32_t MVIEW_NAME_LENGTH = 1040;



            class GXCancel : virtual public std::exception
            {
            };

            class GXExit : virtual public std::exception
            {
            };

            class GXError : virtual public std::exception
            {
            public:
                explicit GXError(const gx_string_type& message)
                    : message_(message)
                {
                }

                explicit GXError(const gx_string_type& message, const gx_string_type& module, int32_t error_number)
                    : message_(message)
                    , module_(module)
                    , error_number_(error_number)
                {
                }

                const gx_string_type& message() const
                {
                    return message_;
                }
                const gx_string_type& module() const
                {
                    return module_;
                }
                int32_t error_number() const
                {
                    return error_number_;
                }

            private:
                gx_string_type message_;
                gx_string_type module_;
                int32_t error_number_;
            };

            class GXAPIError : virtual public std::exception
            {
            public:
                explicit GXAPIError(const gx_string_type& message)
                    : message_(message)
                {
                }

                gx_string_type message() const
                {
                    return message_;
                }
            private:
                gx_string_type message_;
            };

            class GX3DN;
            typedef std::shared_ptr<GX3DN> GX3DNPtr;
            class GX3DV;
            typedef std::shared_ptr<GX3DV> GX3DVPtr;
            class GXACQUIRE;
            typedef std::shared_ptr<GXACQUIRE> GXACQUIREPtr;
            class GXARCDB;
            typedef std::shared_ptr<GXARCDB> GXARCDBPtr;
            class GXARCDH;
            typedef std::shared_ptr<GXARCDH> GXARCDHPtr;
            class GXARCMAP;
            typedef std::shared_ptr<GXARCMAP> GXARCMAPPtr;
            class GXARCSYS;
            typedef std::shared_ptr<GXARCSYS> GXARCSYSPtr;
            class GXBIGRID;
            typedef std::shared_ptr<GXBIGRID> GXBIGRIDPtr;
            class GXCHIMERA;
            typedef std::shared_ptr<GXCHIMERA> GXCHIMERAPtr;
            class GXCOM;
            typedef std::shared_ptr<GXCOM> GXCOMPtr;
            class GXCSYMB;
            typedef std::shared_ptr<GXCSYMB> GXCSYMBPtr;
            class GXDGW;
            typedef std::shared_ptr<GXDGW> GXDGWPtr;
            class GXDH;
            typedef std::shared_ptr<GXDH> GXDHPtr;
            class GXDMPPLY;
            typedef std::shared_ptr<GXDMPPLY> GXDMPPLYPtr;
            class GXDOCU;
            typedef std::shared_ptr<GXDOCU> GXDOCUPtr;
            class GXDU;
            typedef std::shared_ptr<GXDU> GXDUPtr;
            class GXDXFI;
            typedef std::shared_ptr<GXDXFI> GXDXFIPtr;
            class GXEDB;
            typedef std::shared_ptr<GXEDB> GXEDBPtr;
            class GXEDOC;
            typedef std::shared_ptr<GXEDOC> GXEDOCPtr;
            class GXEMAP;
            typedef std::shared_ptr<GXEMAP> GXEMAPPtr;
            class GXEMAPTEMPLATE;
            typedef std::shared_ptr<GXEMAPTEMPLATE> GXEMAPTEMPLATEPtr;
            class GXEUL3;
            typedef std::shared_ptr<GXEUL3> GXEUL3Ptr;
            class GXEXP;
            typedef std::shared_ptr<GXEXP> GXEXPPtr;
            class GXFFT;
            typedef std::shared_ptr<GXFFT> GXFFTPtr;
            class GXFFT2;
            typedef std::shared_ptr<GXFFT2> GXFFT2Ptr;
            class GXFLT;
            typedef std::shared_ptr<GXFLT> GXFLTPtr;
            class GXGD;
            typedef std::shared_ptr<GXGD> GXGDPtr;
            class GXGER;
            typedef std::shared_ptr<GXGER> GXGERPtr;
            class GXGMSYS;
            typedef std::shared_ptr<GXGMSYS> GXGMSYSPtr;
            class GXGU;
            typedef std::shared_ptr<GXGU> GXGUPtr;
            class GXGUI;
            typedef std::shared_ptr<GXGUI> GXGUIPtr;
            class GXHTTP;
            typedef std::shared_ptr<GXHTTP> GXHTTPPtr;
            class GXIEXP;
            typedef std::shared_ptr<GXIEXP> GXIEXPPtr;
            class GXIGRF;
            typedef std::shared_ptr<GXIGRF> GXIGRFPtr;
            class GXINTERNET;
            typedef std::shared_ptr<GXINTERNET> GXINTERNETPtr;
            class GXIP;
            typedef std::shared_ptr<GXIP> GXIPPtr;
            class GXIPGUI;
            typedef std::shared_ptr<GXIPGUI> GXIPGUIPtr;
            class GXKGRD;
            typedef std::shared_ptr<GXKGRD> GXKGRDPtr;
            class GXLMSG;
            typedef std::shared_ptr<GXLMSG> GXLMSGPtr;
            class GXMISC;
            typedef std::shared_ptr<GXMISC> GXMISCPtr;
            class GXMSTK;
            typedef std::shared_ptr<GXMSTK> GXMSTKPtr;
            class GXMVG;
            typedef std::shared_ptr<GXMVG> GXMVGPtr;
            class GXPDF3D;
            typedef std::shared_ptr<GXPDF3D> GXPDF3DPtr;
            class GXPGEXP;
            typedef std::shared_ptr<GXPGEXP> GXPGEXPPtr;
            class GXPGU;
            typedef std::shared_ptr<GXPGU> GXPGUPtr;
            class GXPRAGA3;
            typedef std::shared_ptr<GXPRAGA3> GXPRAGA3Ptr;
            class GXPROJ;
            typedef std::shared_ptr<GXPROJ> GXPROJPtr;
            class GXRGRD;
            typedef std::shared_ptr<GXRGRD> GXRGRDPtr;
            class GXSEMPLOT;
            typedef std::shared_ptr<GXSEMPLOT> GXSEMPLOTPtr;
            class GXSHP;
            typedef std::shared_ptr<GXSHP> GXSHPPtr;
            class GXSQLSRV;
            typedef std::shared_ptr<GXSQLSRV> GXSQLSRVPtr;
            class GXSTK;
            typedef std::shared_ptr<GXSTK> GXSTKPtr;
            class GXSTRINGS;
            typedef std::shared_ptr<GXSTRINGS> GXSTRINGSPtr;
            class GXTC;
            typedef std::shared_ptr<GXTC> GXTCPtr;
            class GXTEST;
            typedef std::shared_ptr<GXTEST> GXTESTPtr;
            class GXTIN;
            typedef std::shared_ptr<GXTIN> GXTINPtr;
            class GXTRND;
            typedef std::shared_ptr<GXTRND> GXTRNDPtr;
            class GXUNC;
            typedef std::shared_ptr<GXUNC> GXUNCPtr;
            class GXVAU;
            typedef std::shared_ptr<GXVAU> GXVAUPtr;
            class GXVVEXP;
            typedef std::shared_ptr<GXVVEXP> GXVVEXPPtr;
            class GXVVU;
            typedef std::shared_ptr<GXVVU> GXVVUPtr;
            class GXAGG;
            typedef std::shared_ptr<GXAGG> GXAGGPtr;
            class GXBF;
            typedef std::shared_ptr<GXBF> GXBFPtr;
            class GXDAT;
            typedef std::shared_ptr<GXDAT> GXDATPtr;
            class GXDATALINKD;
            typedef std::shared_ptr<GXDATALINKD> GXDATALINKDPtr;
            class GXDATAMINE;
            typedef std::shared_ptr<GXDATAMINE> GXDATAMINEPtr;
            class GXDB;
            typedef std::shared_ptr<GXDB> GXDBPtr;
            class GXDBREAD;
            typedef std::shared_ptr<GXDBREAD> GXDBREADPtr;
            class GXDBWRITE;
            typedef std::shared_ptr<GXDBWRITE> GXDBWRITEPtr;
            class GXDSEL;
            typedef std::shared_ptr<GXDSEL> GXDSELPtr;
            class GXEXT;
            typedef std::shared_ptr<GXEXT> GXEXTPtr;
            class GXGEO;
            typedef std::shared_ptr<GXGEO> GXGEOPtr;
            class GXGEOSTRING;
            typedef std::shared_ptr<GXGEOSTRING> GXGEOSTRINGPtr;
            class GXGIS;
            typedef std::shared_ptr<GXGIS> GXGISPtr;
            class GXHGD;
            typedef std::shared_ptr<GXHGD> GXHGDPtr;
            class GXHXYZ;
            typedef std::shared_ptr<GXHXYZ> GXHXYZPtr;
            class GXIMG;
            typedef std::shared_ptr<GXIMG> GXIMGPtr;
            class GXIMU;
            typedef std::shared_ptr<GXIMU> GXIMUPtr;
            class GXIPJ;
            typedef std::shared_ptr<GXIPJ> GXIPJPtr;
            class GXITR;
            typedef std::shared_ptr<GXITR> GXITRPtr;
            class GXLAYOUT;
            typedef std::shared_ptr<GXLAYOUT> GXLAYOUTPtr;
            class GXLL2;
            typedef std::shared_ptr<GXLL2> GXLL2Ptr;
            class GXLPT;
            typedef std::shared_ptr<GXLPT> GXLPTPtr;
            class GXLST;
            typedef std::shared_ptr<GXLST> GXLSTPtr;
            class GXLTB;
            typedef std::shared_ptr<GXLTB> GXLTBPtr;
            class GXMAP;
            typedef std::shared_ptr<GXMAP> GXMAPPtr;
            class GXMAPL;
            typedef std::shared_ptr<GXMAPL> GXMAPLPtr;
            class GXMAPTEMPLATE;
            typedef std::shared_ptr<GXMAPTEMPLATE> GXMAPTEMPLATEPtr;
            class GXMATH;
            typedef std::shared_ptr<GXMATH> GXMATHPtr;
            class GXMETA;
            typedef std::shared_ptr<GXMETA> GXMETAPtr;
            class GXMVIEW;
            typedef std::shared_ptr<GXMVIEW> GXMVIEWPtr;
            class GXMVU;
            typedef std::shared_ptr<GXMVU> GXMVUPtr;
            class GXMXD;
            typedef std::shared_ptr<GXMXD> GXMXDPtr;
            class GXPAT;
            typedef std::shared_ptr<GXPAT> GXPATPtr;
            class GXPG;
            typedef std::shared_ptr<GXPG> GXPGPtr;
            class GXPJ;
            typedef std::shared_ptr<GXPJ> GXPJPtr;
            class GXPLY;
            typedef std::shared_ptr<GXPLY> GXPLYPtr;
            class GXRA;
            typedef std::shared_ptr<GXRA> GXRAPtr;
            class GXREG;
            typedef std::shared_ptr<GXREG> GXREGPtr;
            class GXSBF;
            typedef std::shared_ptr<GXSBF> GXSBFPtr;
            class GXST;
            typedef std::shared_ptr<GXST> GXSTPtr;
            class GXST2;
            typedef std::shared_ptr<GXST2> GXST2Ptr;
            class GXSTR;
            typedef std::shared_ptr<GXSTR> GXSTRPtr;
            class GXSURFACE;
            typedef std::shared_ptr<GXSURFACE> GXSURFACEPtr;
            class GXSURFACEITEM;
            typedef std::shared_ptr<GXSURFACEITEM> GXSURFACEITEMPtr;
            class GXSYS;
            typedef std::shared_ptr<GXSYS> GXSYSPtr;
            class GXTB;
            typedef std::shared_ptr<GXTB> GXTBPtr;
            class GXTPAT;
            typedef std::shared_ptr<GXTPAT> GXTPATPtr;
            class GXTR;
            typedef std::shared_ptr<GXTR> GXTRPtr;
            class GXUSERMETA;
            typedef std::shared_ptr<GXUSERMETA> GXUSERMETAPtr;
            class GXVA;
            typedef std::shared_ptr<GXVA> GXVAPtr;
            class GXVM;
            typedef std::shared_ptr<GXVM> GXVMPtr;
            class GXVOX;
            typedef std::shared_ptr<GXVOX> GXVOXPtr;
            class GXVOXD;
            typedef std::shared_ptr<GXVOXD> GXVOXDPtr;
            class GXVOXE;
            typedef std::shared_ptr<GXVOXE> GXVOXEPtr;
            class GXVULCAN;
            typedef std::shared_ptr<GXVULCAN> GXVULCANPtr;
            class GXVV;
            typedef std::shared_ptr<GXVV> GXVVPtr;
            class GXWA;
            typedef std::shared_ptr<GXWA> GXWAPtr;

            class GXContext;
            typedef std::shared_ptr<GXContext> GXContextPtr;
            class GXContext : public std::enable_shared_from_this<GXContext>
            {
            private:

                friend class GX3DN;
                friend class GX3DV;
                friend class GXACQUIRE;
                friend class GXARCDB;
                friend class GXARCDH;
                friend class GXARCMAP;
                friend class GXARCSYS;
                friend class GXBIGRID;
                friend class GXCHIMERA;
                friend class GXCOM;
                friend class GXCSYMB;
                friend class GXDGW;
                friend class GXDH;
                friend class GXDMPPLY;
                friend class GXDOCU;
                friend class GXDU;
                friend class GXDXFI;
                friend class GXEDB;
                friend class GXEDOC;
                friend class GXEMAP;
                friend class GXEMAPTEMPLATE;
                friend class GXEUL3;
                friend class GXEXP;
                friend class GXFFT;
                friend class GXFFT2;
                friend class GXFLT;
                friend class GXGD;
                friend class GXGER;
                friend class GXGMSYS;
                friend class GXGU;
                friend class GXGUI;
                friend class GXHTTP;
                friend class GXIEXP;
                friend class GXIGRF;
                friend class GXINTERNET;
                friend class GXIP;
                friend class GXIPGUI;
                friend class GXKGRD;
                friend class GXLMSG;
                friend class GXMISC;
                friend class GXMSTK;
                friend class GXMVG;
                friend class GXPDF3D;
                friend class GXPGEXP;
                friend class GXPGU;
                friend class GXPRAGA3;
                friend class GXPROJ;
                friend class GXRGRD;
                friend class GXSEMPLOT;
                friend class GXSHP;
                friend class GXSQLSRV;
                friend class GXSTK;
                friend class GXSTRINGS;
                friend class GXTC;
                friend class GXTEST;
                friend class GXTIN;
                friend class GXTRND;
                friend class GXUNC;
                friend class GXVAU;
                friend class GXVVEXP;
                friend class GXVVU;
                friend class GXAGG;
                friend class GXBF;
                friend class GXDAT;
                friend class GXDATALINKD;
                friend class GXDATAMINE;
                friend class GXDB;
                friend class GXDBREAD;
                friend class GXDBWRITE;
                friend class GXDSEL;
                friend class GXEXT;
                friend class GXGEO;
                friend class GXGEOSTRING;
                friend class GXGIS;
                friend class GXHGD;
                friend class GXHXYZ;
                friend class GXIMG;
                friend class GXIMU;
                friend class GXIPJ;
                friend class GXITR;
                friend class GXLAYOUT;
                friend class GXLL2;
                friend class GXLPT;
                friend class GXLST;
                friend class GXLTB;
                friend class GXMAP;
                friend class GXMAPL;
                friend class GXMAPTEMPLATE;
                friend class GXMATH;
                friend class GXMETA;
                friend class GXMVIEW;
                friend class GXMVU;
                friend class GXMXD;
                friend class GXPAT;
                friend class GXPG;
                friend class GXPJ;
                friend class GXPLY;
                friend class GXRA;
                friend class GXREG;
                friend class GXSBF;
                friend class GXST;
                friend class GXST2;
                friend class GXSTR;
                friend class GXSURFACE;
                friend class GXSURFACEITEM;
                friend class GXSYS;
                friend class GXTB;
                friend class GXTPAT;
                friend class GXTR;
                friend class GXUSERMETA;
                friend class GXVA;
                friend class GXVM;
                friend class GXVOX;
                friend class GXVOXD;
                friend class GXVOXE;
                friend class GXVULCAN;
                friend class GXVV;
                friend class GXWA;


                void *pGeo;
                bool destroyGeo;
                static thread_local std::weak_ptr<GXContext> currentContext;

                GXContext(void *_pGeo)
                    : pGeo(_pGeo)
                    , destroyGeo(false)
                {
                }

                GXContext(const gx_string_type& application, const gx_string_type& version, HWND hParentWnd)
                    : pGeo(nullptr)
                    , destroyGeo(true)
                {
                    gx_string_char_type geoError[4096];
                    pGeo = pCreate_GEO(application.c_str(), version.c_str(), 0, hParentWnd, 0, geoError, _countof(geoError));
                    if (pGeo == nullptr)
                    {
                        gx_string_type error = gx_string_literal("Unable to initialize Geosoft libraries: ");
                        error += geoError;
                        throw GXAPIError(error);
                    }
                }

                void throw_on_error()
                {
                    long lTerminateReason = 0;
                    if (iCheckTerminate_SYS(pGeo, &lTerminateReason))
                    {
                        auto iErr = iCheckError_SYS(pGeo);
                        assert(iErr != 0);

                        if (lTerminateReason == 0)
                            throw GXExit();
                        else if (lTerminateReason == -1)
                            throw GXCancel();
                        else
                        {
                            int32_t error_number;
                            gx_string_type error_message, error_module;
                            int32_t moduleSize = STR_DEFAULT * STRING_CHAR_SIZE;
                            int32_t messageSize = STR_ERROR * STRING_CHAR_SIZE;
                            error_module.resize(STR_DEFAULT);
                            error_message.resize(STR_ERROR);
                            short ret = sGetError_GEO(pGeo, (gx_string_char_type*)error_module.data(), moduleSize, (gx_string_char_type*)error_message.data(), messageSize, reinterpret_cast<long*>(&error_number));
                            error_module.resize(gx_string_len(error_module.c_str()));
                            error_message.resize(gx_string_len(error_message.c_str()));
                            if (error_number == 21023 || error_number == 21031 || // These two due to GXX asserts, Abort_SYS etc
                                    error_number == 31009 || error_number == 31011) // wrapper bind errors
                                throw GXAPIError(error_message);
                            else
                                throw GXError(error_message, error_module, error_number);
                        }
                    }
                }




                template<class GXClass>
                std::shared_ptr<GXClass> createPtr(int32_t handle)
                {
                    return std::shared_ptr<GXClass>(new GXClass(handle));
                }

                template<class GXClass>
                std::shared_ptr<GXClass> createNullHandlePtr()
                {
                    return std::shared_ptr<GXClass>(new GXClass(0));
                }

                static const int32_t null_handle = 0;
                template<class GXClass>
                const int32_t& handle(std::shared_ptr<GXClass> obj)
                {
                    if (!obj)
                        return null_handle;
                    return obj->handle_;
                }

            public:
                void * _internal_p()
                {
                    return pGeo;
                }
                static GXContextPtr create_internal(void *pGeo)
                {
                    if (auto cur_ctx = currentContext.lock())
                        return cur_ctx;

                    auto ctx = GXContextPtr(new GXContext(pGeo));
                    currentContext = ctx;
                    return ctx;
                }
                static GXContextPtr create(const gx_string_type& application, const gx_string_type& version, HWND hParentWnd = nullptr)
                {
                    if (auto cur_ctx = currentContext.lock())
                        return cur_ctx;

                    auto ctx = GXContextPtr(new GXContext(application, version, hParentWnd));
                    currentContext = ctx;
                    return ctx;
                }
                static GXContextPtr current()
                {
                    if (auto cur_ctx = currentContext.lock())
                        return cur_ctx;
                    else
                        throw GXAPIError(gx_string_literal("A GXContext has not been created on this thread, or has been destroyed."));
                }

                HWND get_main_wnd()
                {
                    return hGetMainWnd_GEO();
                }

                HWND get_active_wnd()
                {
                    return hGetActiveMainWnd_GEO();
                }

                void enable_application_windows(bool enable)
                {
                    EnableApplicationWindows_GEO(enable);
                }

                ~GXContext()
                {
                    if (destroyGeo && pGeo)
                        Destroy_GEO(pGeo);
                }

            };

            class GX3DN
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GX3DN(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GX3DNPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GX3DN>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void copy(GX3DNPtr param1)
                {
                    Copy_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GX3DNPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_3DN(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GX3DN>(ret);
                }

                ~GX3DN()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_point_of_view(double& param1, double& param2, double& param3)
                {
                    GetPointOfView_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                void get_scale(double& param1, double& param2, double& param3)
                {
                    GetScale_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                int32_t get_axis_color()
                {
                    int32_t ret = iGetAxisColor_3DN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_axis_font(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetAxisFont_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                int32_t get_background_color()
                {
                    int32_t ret = iGetBackgroundColor_3DN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_render_controls(int32_t& param1, int32_t& param2, gx_string_type& param3, gx_string_type& param4, gx_string_type& param5)
                {
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT_LONG);
                    param4.resize(STR_DEFAULT_LONG);
                    param5.resize(STR_DEFAULT_LONG);
                    IGetRenderControls_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize6 ), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize8 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param5.resize(gx_string_len(param5.c_str()));
                }

                int32_t get_shading()
                {
                    int32_t ret = iGetShading_3DN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_axis_color(int32_t param1)
                {
                    SetAxisColor_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_axis_font(const gx_string_type& param1)
                {
                    SetAxisFont_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_background_color(int32_t param1)
                {
                    SetBackgroundColor_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_point_of_view(double param1, double param2, double param3)
                {
                    SetPointOfView_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                void set_render_controls(int32_t param1, int32_t param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    SetRenderControls_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }

                void set_scale(double param1, double param2, double param3)
                {
                    SetScale_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                void set_shading(int32_t param1)
                {
                    SetShading_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }


            };
            class GX3DV
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GX3DV(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GX3DVPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GX3DV>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                GXMVIEWPtr open_mview(GEO3DV_OPEN param1)
                {
                    int32_t ret = OpenMVIEW_3DV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }

                void copy_to_map(GXMAPPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, int32_t param7, gx_string_type& param8, gx_string_type& param9)
                {
                    int32_t paramSize9 = MVIEW_NAME_LENGTH * STRING_CHAR_SIZE;
                    int32_t paramSize11 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param8.resize(MVIEW_NAME_LENGTH);
                    param9.resize(STR_MULTI_FILE);
                    ICopyToMAP_3DV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7), (gx_string_char_type*)param8.data(), reinterpret_cast<const long*>(&paramSize9 ), (gx_string_char_type*)param9.data(), reinterpret_cast<const long*>(&paramSize11 ));
                    gx_->throw_on_error();
                    param8.resize(gx_string_len(param8.c_str()));
                    param9.resize(gx_string_len(param9.c_str()));
                }

                static GX3DVPtr create_new(const gx_string_type& param1, GXMVIEWPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateNew_3DV(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GX3DV>(ret);
                }

                static GX3DVPtr open(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_3DV(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GX3DV>(ret);
                }

                static GX3DVPtr from_map(GXMAPPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = FromMap_3DV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GX3DV>(ret);
                }

                void crc_3dv(int32_t& param1, const gx_string_type& param2)
                {
                    CRC3DV_3DV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXACQUIRE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXACQUIRE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXACQUIREPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXACQUIRE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXACQUIREPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_ACQUIRE(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXACQUIRE>(ret);
                }

                void delete_empty_chan(GXDBPtr param1)
                {
                    DeleteEmptyChan_ACQUIRE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                ~GXACQUIRE()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_ACQUIRE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t import_hole(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, int32_t param5, int32_t param6)
                {
                    int32_t ret = iImportHole_ACQUIRE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t import_point(GXDBPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    int32_t ret = iImportPoint_ACQUIRE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t selection_tool(const gx_string_type& param1, ACQUIRE_SEL param2)
                {
                    int32_t ret = iSelectionTool_ACQUIRE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXARCDB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXARCDB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXARCDBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXARCDB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                GXDATPtr create_dat(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    int32_t ret = CreateDAT_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDAT>(ret);
                }

                GXDATPtr create_dat_3d(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    int32_t ret = CreateDAT3D_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDAT>(ret);
                }

                static GXARCDBPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Current_ARCDB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXARCDB>(ret);
                }

                void export_to_db(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ExportToDB_ARCDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void field_lst(GXLSTPtr param1)
                {
                    FieldLST_ARCDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXARCDBPtr from_i_unknown(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = FromIUnknown_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXARCDB>(ret);
                }

                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_ARCDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                int32_t exist_field(const gx_string_type& param1)
                {
                    int32_t ret = iExistField_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_i_unknown()
                {
                    int32_t ret = iGetIUnknown_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t import_chem_database_wizard(const gx_string_type& param1, IMPCH_TYPE param2)
                {
                    int32_t ret = iImportChemDatabaseWizard_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static GXARCDBPtr sel_tbl_ex_gui(ARC_SELTBL_TYPE& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = SelTblExGUI_ARCDB(
                                      gx_->pGeo, reinterpret_cast<long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXARCDB>(ret);
                }

                static GXARCDBPtr sel_tbl_gui()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = SelTblGUI_ARCDB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXARCDB>(ret);
                }


            };
            class GXARCDH
            {
            private:
                GXARCDH();
                ~GXARCDH();
            public:


                static void close_project()
                {
                    GXContextPtr gx_ = GXContext::current();
                    CloseProject_ARCDH(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void set_project(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetProject_ARCDH(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void set_string_file_gdb(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetStringFileGDB_ARCDH(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void stop_editing_string_file_gdb()
                {
                    GXContextPtr gx_ = GXContext::current();
                    StopEditingStringFileGDB_ARCDH(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static int32_t has_string_file_gdb_edits()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iHasStringFileGDBEdits_ARCDH(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t geostrings_extension_available()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGeostringsExtensionAvailable_ARCDH(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_current_string_file_gdb(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    GetCurrentStringFileGDB_ARCDH(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static int32_t is_valid_fgdb_file_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsValidFGDBFileName_ARCDH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t is_valid_feature_class_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsValidFeatureClassName_ARCDH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void s_prompt_for_esri_symbol(HWND param1, const gx_string_type& param2, int32_t param3, gx_string_type& param4, int32_t& param5, int32_t& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param4.resize(STR_VERY_LONG);
                    sPromptForESRISymbol_ARCDH(
                        gx_->pGeo, param1, param2.c_str(), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }


            };
            class GXARCMAP
            {
            private:
                GXARCMAP();
                ~GXARCMAP();
            public:


                static void change_size(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ChangeSize_ARCMAP(
                        gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                }

                static void display_in_3d_view(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DisplayIn3DView_ARCMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void export_feature_layer_by_name_to_3d_file(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportFeatureLayerByNameTo3DFile_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                static void export_selected_feature_layer_to_3d_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportSelectedFeatureLayerTo3DFile_ARCMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void get_current_document_info(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    GetCurrentDocumentInfo_ARCMAP(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), (gx_string_char_type*)param2.data(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }

                static void get_selected_layer_info(int32_t param1, gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    GetSelectedLayerInfo_ARCMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }

                static int32_t get_number_of_selected_layers()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetNumberOfSelectedLayers_ARCMAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t get_load_map(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, ARCMAP_LOAD_FLAGS param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iLoadMAP_ARCMAP(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t load_map_ex(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, ARCMAP_LOAD_FLAGS param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iLoadMAPEx_ARCMAP(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t get_load_shape(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iLoadShape_ARCMAP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t load_spf(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iLoadSPF_ARCMAP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static void load_lyr(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadLYR_ARCMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void load_map(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, bool param5, bool param6, bool param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool5 = param5 ? 1 : 0;
                    long paramBool6 = param6 ? 1 : 0;
                    long paramBool7 = param7 ? 1 : 0;
                    LoadMap_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), &paramBool5, &paramBool6, &paramBool7);
                    gx_->throw_on_error();
                }

                static void load_map_view(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadMapView_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void load_raster(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadRaster_ARCMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void load_shape(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadShape_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void map_view_to_shape(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, GXLSTPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MapViewToShape_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void query_size(double& param1, double& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    QuerySize_ARCMAP(
                        gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                }

                static void show_layer_by_name_in_3d(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ShowLayerByNameIn3D_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void show_selected_layers_in_3d()
                {
                    GXContextPtr gx_ = GXContext::current();
                    ShowSelectedLayersIn3D_ARCMAP(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void get_ipj_for_predefined_esri_gcs(GXIPJPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetIPJForPredefinedEsriGCS_ARCMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void get_ipj_for_predefined_esri_pcs(GXIPJPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetIPJForPredefinedEsriPCS_ARCMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }


            };
            class GXARCSYS
            {
            private:
                GXARCSYS();
                ~GXARCSYS();
            public:


                static void get_browse_loc(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetBrowseLoc_ARCSYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void get_current_doc(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetCurrentDoc_ARCSYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void set_browse_loc(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetBrowseLoc_ARCSYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXBIGRID
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXBIGRID(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXBIGRIDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXBIGRID>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear()
                {
                    _Clear_BIGRID(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static GXBIGRIDPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_BIGRID(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXBIGRID>(ret);
                }

                ~GXBIGRID()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_BIGRID(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t load_parms(const gx_string_type& param1)
                {
                    int32_t ret = iLoadParms_BIGRID(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t load_warp(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    int32_t ret = iLoadWarp_BIGRID(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void run(const gx_string_type& param1, GXDATPtr param2, GXDATPtr param3)
                {
                    Run_BIGRID(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void run2(const gx_string_type& param1, GXDATPtr param2, GXDATPtr param3, GXIPJPtr param4)
                {
                    Run2_BIGRID(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void save_parms(const gx_string_type& param1)
                {
                    SaveParms_BIGRID(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXCHIMERA
            {
            private:
                GXCHIMERA();
                ~GXCHIMERA();
            public:


                static void bar_plot(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BarPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                }

                static void categorize_by_value(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CategorizeByValue_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void categorize_by_value_det_limit(GXVVPtr param1, GXVVPtr param2, double param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CategorizeByValueDetLimit_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void clip_to_detect_limit(GXVVPtr param1, double param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClipToDetectLimit_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void draw_circle_offset_markers(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DrawCircleOffsetMarkers_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), &param6);
                    gx_->throw_on_error();
                }

                static void draw_rectangle_offset_markers(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, double param6, double param7, double param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DrawRectangleOffsetMarkers_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), &param6, &param7, &param8);
                    gx_->throw_on_error();
                }

                static void duplicate_chem(GXMVIEWPtr param1, GXVVPtr param2, int32_t param3, double param4, int32_t param5, GXVVPtr param6, const gx_string_type& param7, const gx_string_type& param8, double param9, double param10, double param11, double param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DuplicateChem_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), param7.c_str(), param8.c_str(), &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }

                static void duplicate_chem_view(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXIPJPtr param4, GXVVPtr param5, int32_t param6, double param7, int32_t param8, GXVVPtr param9, const gx_string_type& param10, const gx_string_type& param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14, GXDBPtr param15, double& param16, double& param17)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DuplicateChemView_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)), param10.c_str(), param11.c_str(), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), &param16, &param17);
                    gx_->throw_on_error();
                }

                static void get_expression_data_vv(GXDBPtr param1, int32_t param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetExpressionDataVV_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void get_lithogeochem_data(GXDBPtr param1, GXLSTPtr param2, int32_t param3, GXVVPtr param4, int32_t param5, GXVVPtr param6, int32_t param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetLithogeochemData_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)));
                    gx_->throw_on_error();
                }

                static void get_transform(GXDBPtr param1, const gx_string_type& param2, int32_t param3, int32_t& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetTransform_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<long*>(&param4), &param5);
                    gx_->throw_on_error();
                }

                static bool is_acquire_chan(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, double& param4, bool& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    param3.resize(STR_DEFAULT_SHORT);
                    long paramBool5 = param5 ? 1 : 0;
                    bool ret = 0 != iIsAcquireChan_CHIMERA(
                                   gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), &param4, &paramBool5);
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param5 = paramBool5 != 0 ? true : false;
                    return ret;
                }

                static bool is_element(const gx_string_type& param1, STR_CASE param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != iIsElement_CHIMERA(
                                   gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static void launch_histogram(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchHistogram_CHIMERA(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void launch_probability(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchProbability_CHIMERA(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void launch_scatter(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchScatter_CHIMERA(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void launch_triplot(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchTriplot_CHIMERA(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void mask_chan_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MaskChanLST_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void ordered_channel_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OrderedChannelLST_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void pie_plot(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PiePlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                }

                static void pie_plot2(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10, double param11, double param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PiePlot2_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11, &param12);
                    gx_->throw_on_error();
                }

                static void plot_string_classified_symbols_legend_from_class_file(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, const gx_string_type& param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PlotStringClassifiedSymbolsLegendFromClassFile_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, param6.c_str(), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static double atomic_weight(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rAtomicWeight_CHIMERA(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void rose_plot(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RosePlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10);
                    gx_->throw_on_error();
                }

                static void rose_plot2(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RosePlot2_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                }

                static void scatter2(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, const gx_string_type& param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, int32_t param13, const gx_string_type& param14, const gx_string_type& param15, const gx_string_type& param16, const gx_string_type& param17, double param18, double param19, double param20, double param21, double param22, double param23, double param24, double param25, int32_t param26, int32_t param27, int32_t param28, int32_t param29, int32_t param30, int32_t param31)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Scatter2_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), param9.c_str(), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&param13), param14.c_str(), param15.c_str(), param16.c_str(), param17.c_str(), &param18, &param19, &param20, &param21, &param22, &param23, &param24, &param25, reinterpret_cast<const long*>(&param26), reinterpret_cast<const long*>(&param27), reinterpret_cast<const long*>(&param28), reinterpret_cast<const long*>(&param29), reinterpret_cast<const long*>(&param30), reinterpret_cast<const long*>(&param31));
                    gx_->throw_on_error();
                }

                static void fixed_symbol_scatter_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, const gx_string_type& param11, int32_t param12, double param13, double param14, int32_t param15, int32_t param16, GXDBPtr param17, GXVVPtr param18, GXVVPtr param19, int32_t param20, const gx_string_type& param21, const gx_string_type& param22, const gx_string_type& param23, const gx_string_type& param24, double param25, double param26, double param27, double param28, int32_t param29, int32_t param30, const gx_string_type& param31)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FixedSymbolScatterPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), param11.c_str(), reinterpret_cast<const long*>(&param12), &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), reinterpret_cast<const long*>(&param20), param21.c_str(), param22.c_str(), param23.c_str(), param24.c_str(), &param25, &param26, &param27, &param28, reinterpret_cast<const long*>(&param29), reinterpret_cast<const long*>(&param30), param31.c_str());
                    gx_->throw_on_error();
                }

                static void zone_coloured_scatter_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, GXVVPtr param11, const gx_string_type& param12, const gx_string_type& param13, int32_t param14, double param15, double param16, int32_t param17, int32_t param18, int32_t param19, GXDBPtr param20, GXVVPtr param21, GXVVPtr param22, int32_t param23, const gx_string_type& param24, const gx_string_type& param25, const gx_string_type& param26, const gx_string_type& param27, double param28, double param29, double param30, double param31, int32_t param32, int32_t param33, const gx_string_type& param34)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ZoneColouredScatterPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), param12.c_str(), param13.c_str(), reinterpret_cast<const long*>(&param14), &param15, &param16, reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&gx_->handle(param20)), reinterpret_cast<const long*>(&gx_->handle(param21)), reinterpret_cast<const long*>(&gx_->handle(param22)), reinterpret_cast<const long*>(&param23), param24.c_str(), param25.c_str(), param26.c_str(), param27.c_str(), &param28, &param29, &param30, &param31, reinterpret_cast<const long*>(&param32), reinterpret_cast<const long*>(&param33), param34.c_str());
                    gx_->throw_on_error();
                }

                static void string_classified_scatter_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, GXVVPtr param11, const gx_string_type& param12, double param13, GXDBPtr param14, GXVVPtr param15, GXVVPtr param16, int32_t param17, const gx_string_type& param18, const gx_string_type& param19, const gx_string_type& param20, const gx_string_type& param21, double param22, double param23, double param24, double param25, int32_t param26, int32_t param27, const gx_string_type& param28)
                {
                    GXContextPtr gx_ = GXContext::current();
                    StringClassifiedScatterPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), param12.c_str(), &param13, reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&gx_->handle(param16)), reinterpret_cast<const long*>(&param17), param18.c_str(), param19.c_str(), param20.c_str(), param21.c_str(), &param22, &param23, &param24, &param25, reinterpret_cast<const long*>(&param26), reinterpret_cast<const long*>(&param27), param28.c_str());
                    gx_->throw_on_error();
                }

                static void set_lithogeochem_data(GXDBPtr param1, GXLSTPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetLithogeochemData_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)));
                    gx_->throw_on_error();
                }

                static void stacked_bar_plot(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    StackedBarPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                }

                static void standard(GXMVIEWPtr param1, GXVVPtr param2, int32_t param3, double param4, double param5, double param6, const gx_string_type& param7, const gx_string_type& param8, double param9, double param10, double param11, double param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Standard_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, param7.c_str(), param8.c_str(), &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }

                static void standard_view(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXIPJPtr param4, GXVVPtr param5, int32_t param6, double param7, double param8, double param9, const gx_string_type& param10, const gx_string_type& param11, double param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15, GXDBPtr param16, double& param17, double& param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    StandardView_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, param10.c_str(), param11.c_str(), &param12, reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&gx_->handle(param16)), &param17, &param18);
                    gx_->throw_on_error();
                }

                static void tri_plot2(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, const gx_string_type& param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14, const gx_string_type& param15, const gx_string_type& param16, const gx_string_type& param17, double param18, double param19, double param20, double param21, double param22, double param23, int32_t param24, int32_t param25, int32_t param26, int32_t param27, int32_t param28, int32_t param29, int32_t param30, double param31, double param32)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TriPlot2_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), param11.c_str(), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), param15.c_str(), param16.c_str(), param17.c_str(), &param18, &param19, &param20, &param21, &param22, &param23, reinterpret_cast<const long*>(&param24), reinterpret_cast<const long*>(&param25), reinterpret_cast<const long*>(&param26), reinterpret_cast<const long*>(&param27), reinterpret_cast<const long*>(&param28), reinterpret_cast<const long*>(&param29), reinterpret_cast<const long*>(&param30), &param31, &param32);
                    gx_->throw_on_error();
                }

                static void fixed_symbol_tri_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, const gx_string_type& param11, int32_t param12, double param13, double param14, int32_t param15, int32_t param16, GXDBPtr param17, GXVVPtr param18, GXVVPtr param19, const gx_string_type& param20, const gx_string_type& param21, const gx_string_type& param22, int32_t param23, double param24, double param25, const gx_string_type& param26)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FixedSymbolTriPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), param11.c_str(), reinterpret_cast<const long*>(&param12), &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), param20.c_str(), param21.c_str(), param22.c_str(), reinterpret_cast<const long*>(&param23), &param24, &param25, param26.c_str());
                    gx_->throw_on_error();
                }

                static void zone_coloured_tri_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, GXVVPtr param11, const gx_string_type& param12, const gx_string_type& param13, int32_t param14, double param15, double param16, int32_t param17, int32_t param18, int32_t param19, GXDBPtr param20, GXVVPtr param21, GXVVPtr param22, const gx_string_type& param23, const gx_string_type& param24, const gx_string_type& param25, int32_t param26, double param27, double param28, const gx_string_type& param29)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ZoneColouredTriPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), param12.c_str(), param13.c_str(), reinterpret_cast<const long*>(&param14), &param15, &param16, reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&gx_->handle(param20)), reinterpret_cast<const long*>(&gx_->handle(param21)), reinterpret_cast<const long*>(&gx_->handle(param22)), param23.c_str(), param24.c_str(), param25.c_str(), reinterpret_cast<const long*>(&param26), &param27, &param28, param29.c_str());
                    gx_->throw_on_error();
                }

                static void string_classified_tri_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, GXVVPtr param11, const gx_string_type& param12, double param13, GXDBPtr param14, GXVVPtr param15, GXVVPtr param16, const gx_string_type& param17, const gx_string_type& param18, const gx_string_type& param19, int32_t param20, double param21, double param22, const gx_string_type& param23)
                {
                    GXContextPtr gx_ = GXContext::current();
                    StringClassifiedTriPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), param12.c_str(), &param13, reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&gx_->handle(param16)), param17.c_str(), param18.c_str(), param19.c_str(), reinterpret_cast<const long*>(&param20), &param21, &param22, param23.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXCOM
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXCOM(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXCOMPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXCOM>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXCOMPtr create(const gx_string_type& param1, COM_BAUD param2, COM_DATASIZE param3, COM_PARITY param4, COM_STOPBITS param5, COM_FLOWCONTROL param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_COM(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXCOM>(ret);
                }

                static GXCOMPtr create_no_terminate(const gx_string_type& param1, COM_BAUD param2, COM_DATASIZE param3, COM_PARITY param4, COM_STOPBITS param5, COM_FLOWCONTROL param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateNoTerminate_COM(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXCOM>(ret);
                }

                ~GXCOM()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t read_line_no_terminate(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    int32_t ret = IiReadLineNoTerminate_COM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }

                int32_t read_chars_no_terminate(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    int32_t ret = iReadCharsNoTerminate_COM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }

                void read_line(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IReadLine_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                int32_t write_chars_no_terminate(const gx_string_type& param1)
                {
                    int32_t ret = iWriteCharsNoTerminate_COM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void purge_comm()
                {
                    PurgeComm_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void read_chars(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    ReadChars_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void read_em61_lines_wa(int32_t param1, GXWAPtr param2)
                {
                    ReadEM61LinesWA_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void read_file2_wa(GXWAPtr param1)
                {
                    ReadFile2WA_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void read_lines_wa(int32_t param1, GXWAPtr param2)
                {
                    ReadLinesWA_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void set_time_out(int32_t param1)
                {
                    SetTimeOut_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void write_chars(const gx_string_type& param1)
                {
                    WriteChars_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void write_line(const gx_string_type& param1)
                {
                    WriteLine_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXCSYMB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXCSYMB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXCSYMBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXCSYMB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void set_angle(double param1)
                {
                    _SetAngle_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_base(double param1)
                {
                    _SetBase_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_dynamic_col(CSYMB_COLOR param1)
                {
                    _SetDynamicCol_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_fixed(int32_t param1)
                {
                    _SetFixed_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_number(int32_t param1)
                {
                    _SetNumber_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_scale(double param1)
                {
                    _SetScale_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void add_data(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    AddData_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static GXCSYMBPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_CSYMB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXCSYMB>(ret);
                }

                ~GXCSYMB()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void set_font(const gx_string_type& param1, int32_t param2, MVIEW_FONT_WEIGHT param3, int32_t param4)
                {
                    SetFont_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void set_static_col(int32_t param1, CSYMB_COLOR param2)
                {
                    SetStaticCol_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }


            };
            class GXDGW
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDGW(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDGWPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDGW>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDGWPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Create_DGW(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDGW>(ret);
                }

                ~GXDGW()
                {
                    if (handle_ == 0)
                        return;
                    App_Destroy_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_info_meta(int32_t param1, DGW_OBJECT param2, GXMETAPtr param3, int32_t param4, int32_t param5)
                {
                    App_GetInfoMETA_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                void get_info_sys(int32_t param1, DGW_OBJECT param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    App_GetInfoSYS_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                GXLSTPtr get_list(int32_t param1)
                {
                    int32_t ret = App_GetList_DGW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }

                void gt_info(int32_t param1, DGW_OBJECT param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    App_GtInfo_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                int32_t run_dialogue()
                {
                    int32_t ret = App_iRunDialogue_DGW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_info(int32_t param1, DGW_OBJECT param2, const gx_string_type& param3)
                {
                    App_SetInfo_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                void set_info_meta(int32_t param1, DGW_OBJECT param2, GXMETAPtr param3, int32_t param4, int32_t param5)
                {
                    App_SetInfoMETA_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                void set_info_sys(int32_t param1, DGW_OBJECT param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    App_SetInfoSYS_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                void set_title(const gx_string_type& param1)
                {
                    App_SetTitle_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXDH
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDH(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDHPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDH>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static int32_t is_esri()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsESRI_DH(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                void creat_chan_lst(GXLSTPtr param1)
                {
                    CreatChanLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void depth_data_lst(GXLSTPtr param1)
                {
                    DepthDataLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void from_to_data_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    FromToDataLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_geology_contacts(GXLSTPtr param1, const gx_string_type& param2, const gx_string_type& param3, DH_SURFACE param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8)
                {
                    GetGeologyContacts_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }

                void get_oriented_core_dip_dir(GXLSTPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GetOrientedCoreDipDir_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }

                void get_unique_channel_items(const gx_string_type& param1, int32_t param2, GXVVPtr param3)
                {
                    GetUniqueChannelItems_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void get_unique_channel_items_from_collar(const gx_string_type& param1, int32_t param2, GXVVPtr param3)
                {
                    GetUniqueChannelItemsFromCollar_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                int32_t chan_type(const gx_string_type& param1)
                {
                    int32_t ret = iChanType_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_hole_intersection(int32_t param1, GXIMGPtr param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = iFindHoleIntersection_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }

                void get_chan_code_info(const gx_string_type& param1, int32_t& param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param3.resize(STR_DB_SYMBOL);
                    IGetChanCodeInfo_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                int32_t grid_intersection(double param1, double param2, double param3, double param4, double param5, const gx_string_type& param6, double& param7, double& param8, double& param9)
                {
                    int32_t ret = iGridIntersection_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, param6.c_str(), &param7, &param8, &param9);
                    gx_->throw_on_error();
                    return ret;
                }

                void litho_grid_3d(const gx_string_type& param1, GXTPATPtr param2, const gx_string_type& param3, double param4, double param5, double param6, int32_t param7, GXREGPtr param8, int32_t param9)
                {
                    LithoGrid3D_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), &param4, &param5, &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                void numeric_chan_lst(GXLSTPtr param1)
                {
                    NumericChanLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void numeric_from_to_data_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    NumericFromToDataLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void punch_grid_holes(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5)
                {
                    PunchGridHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5);
                    gx_->throw_on_error();
                }

                void string_chan_lst(GXLSTPtr param1)
                {
                    StringChanLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void string_from_to_data_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    StringFromToDataLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                GXDBPtr h_assay_db(int32_t param1)
                {
                    int32_t ret = _hAssayDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }

                int32_t h_assay_symb(int32_t param1, int32_t param2)
                {
                    int32_t ret = _hAssaySymb_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                GXDBPtr h_collar_db()
                {
                    int32_t ret = _hCollarDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }

                int32_t h_collar_symb()
                {
                    int32_t ret = _hCollarSymb_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                GXDBPtr h_dip_az_survey_db()
                {
                    int32_t ret = _hDipAzSurveyDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }

                int32_t h_dip_az_survey_symb(int32_t param1)
                {
                    int32_t ret = _hDipAzSurveySymb_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                GXDBPtr h_en_survey_db()
                {
                    int32_t ret = _hENSurveyDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }

                int32_t h_en_survey_symb(int32_t param1)
                {
                    int32_t ret = _hENSurveySymb_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void add_survey_table(int32_t param1)
                {
                    AddSurveyTable_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void assay_hole_lst(int32_t param1, GXLSTPtr param2)
                {
                    AssayHoleLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void assay_lst(GXLSTPtr param1)
                {
                    AssayLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void auto_select_holes(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AutoSelectHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void clean()
                {
                    Clean_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void composite_db(GXDBPtr param1, GXDBPtr param2, DH_COMPSTDB_HOLSEL param3, DH_COMPSTDB_INTSEL param4, double param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, double param9, double param10, double param11, int32_t param12, const gx_string_type& param13)
                {
                    CompositeDB_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, param6.c_str(), param7.c_str(), param8.c_str(), &param9, &param10, &param11, reinterpret_cast<const long*>(&param12), param13.c_str());
                    gx_->throw_on_error();
                }

                void compute_hole_xyz(int32_t param1)
                {
                    ComputeHoleXYZ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void compute_sel_extent(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    ComputeSelExtent_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void compute_xyz()
                {
                    ComputeXYZ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static void convert_old_line_names(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertOldLineNames_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static GXDHPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDH>(ret);
                }

                void create_default_job(const gx_string_type& param1, DH_PLOT param2)
                {
                    CreateDefaultJob_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static GXDHPtr create_external(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateExternal_DH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDH>(ret);
                }

                static GXDHPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Current_DH(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDH>(ret);
                }

                static void datamine_to_csv(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DatamineToCSV_DH(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void delete_holes(GXLSTPtr param1)
                {
                    DeleteHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                ~GXDH()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void export_file(const gx_string_type& param1, DH_EXP param2)
                {
                    Export_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void export_geodatabase_lst(GXLSTPtr param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4, bool param5)
                {
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    long paramBool5 = param5 ? 1 : 0;
                    ExportGeodatabaseLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ), &paramBool5);
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }

                void export_las(int32_t param1, int32_t param2, double param3, const gx_string_type& param4)
                {
                    ExportLAS_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, param4.c_str());
                    gx_->throw_on_error();
                }

                void export_lst(GXLSTPtr param1, const gx_string_type& param2, DH_EXP param3)
                {
                    ExportLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void flush_select()
                {
                    FlushSelect_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void get_databases_vv(GXVVPtr param1)
                {
                    GetDatabasesVV_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_databases_sorted_vv(GXVVPtr param1)
                {
                    GetDatabasesSortedVV_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_data_type(GXDBPtr param1, DH_DATA& param2)
                {
                    GetDataType_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }

                void get_default_section(double& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GetDefaultSection_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                int32_t get_hole_group(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = GetHoleGroup_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_hole_survey(int32_t param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GetHoleSurvey_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_map_names_vv(GXVVPtr param1)
                {
                    GetMapNamesVV_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                GXMAPPtr get_map(int32_t param1)
                {
                    int32_t ret = GetMap_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAP>(ret);
                }

                int32_t get_num_maps()
                {
                    int32_t ret = GetNumMaps_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                GXREGPtr get_reg()
                {
                    int32_t ret = GetREG_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }

                void get_selected_holes_vv(GXVVPtr param1)
                {
                    GetSelectedHolesVV_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void get_table_default_chan_lst(GXLSTPtr param1, DH_DATA param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetTableDefaultChanLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void hole_lst(GXLSTPtr param1)
                {
                    HoleLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void hole_lst2(GXLSTPtr param1)
                {
                    HoleLST2_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                int32_t add_hole(const gx_string_type& param1)
                {
                    int32_t ret = iAddHole_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t clean_will_delete_db()
                {
                    int32_t ret = iCleanWillDeleteDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                DH_COMP_CHOICE compositing_tool_gui(GXMAPPtr param1, double param2, double param3, double param4)
                {
                    DH_COMP_CHOICE ret = (DH_COMP_CHOICE)iCompositingToolGUI_DH(
                                             gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4);
                    gx_->throw_on_error();
                    return ret;
                }

                static void create_collar_table(const gx_string_type& param1, int32_t param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    ICreateCollarTable_DH(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                static void create_collar_table_dir(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    ICreateCollarTableDir_DH(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }

                int32_t delete_will_delete_db(GXLSTPtr param1)
                {
                    int32_t ret = iDeleteWillDeleteDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_hole(const gx_string_type& param1)
                {
                    int32_t ret = iFindHole_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_collar_table_db(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetCollarTableDB_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_info(int32_t param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT_LONG);
                    IGetInfo_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                void get_project_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetProjectName_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void get_section_id(double param1, double param2, double param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    IGetSectionID_DH(
                        gx_->pGeo, &param1, &param2, &param3, (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }

                static int32_t get_template_blob(GXDBPtr param1, const gx_string_type& param2, DH_DATA& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetTemplateBlob_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_template_info(const gx_string_type& param1, DH_DATA& param2, gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    param4.resize(STR_FILE);
                    IGetTemplateInfo_DH(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }

                static void get_template_info_ex(const gx_string_type& param1, DH_DATA& param2, gx_string_type& param3, gx_string_type& param4, GXLSTPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    param4.resize(STR_FILE);
                    IGetTemplateInfoEx_DH(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }

                void get_units(gx_string_type& param1, double& param2)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    IGetUnits_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), &param2);
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static bool have_current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != iHaveCurrent_DH(
                                   gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static bool have_current2(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    bool ret = 0 != IiHaveCurrent2_DH(
                                   gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }

                int32_t holes()
                {
                    int32_t ret = iHoles_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t hole_select_from_list_gui(GXLSTPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iHoleSelectFromListGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t hole_selection_tool_gui()
                {
                    int32_t ret = iHoleSelectionToolGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify3d_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModify3dGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify_crooked_section_holes_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyCrookedSectionHolesGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify_fence_gui(const gx_string_type& param1, DH_SECT_PAGE& param2)
                {
                    int32_t ret = iModifyFenceGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify_hole_traces_3dgui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyHoleTraces3DGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify_hole_traces_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyHoleTracesGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify_hole_traces_gui2(const gx_string_type& param1, DH_PLOT param2, int32_t& param3)
                {
                    int32_t ret = iModifyHoleTracesGUI2_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify_plan_gui(const gx_string_type& param1, DH_SECT_PAGE& param2)
                {
                    int32_t ret = iModifyPlanGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify_plan_holes_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyPlanHolesGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t modify_rock_codes_gui(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iModifyRockCodesGUI_DH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t modify_rock_codes_gui2(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iModifyRockCodesGUI2_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify_section_gui(const gx_string_type& param1, DH_SECT_PAGE& param2)
                {
                    int32_t ret = iModifySectionGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify_section_holes_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifySectionHolesGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify_stacked_section_gui(const gx_string_type& param1, DH_SECT_PAGE& param2)
                {
                    int32_t ret = iModifyStackedSectionGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t modify_strip_log_gui(const gx_string_type& param1, DH_SECT_PAGE& param2)
                {
                    int32_t ret = iModifyStripLogGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t modify_structure_codes_gui(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iModifyStructureCodesGUI_DH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t modify_structure_codes_gui2(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iModifyStructureCodesGUI2_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void import2(const gx_string_type& param1, GXDBPtr param2, int32_t param3, int32_t param4, const gx_string_type& param5, DH_DATA param6, const gx_string_type& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Import2_DH(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), reinterpret_cast<const long*>(&param6), param7.c_str());
                    gx_->throw_on_error();
                }

                void import_las(const gx_string_type& param1, const gx_string_type& param2, double param3, int32_t param4, GXWAPtr param5)
                {
                    ImportLAS_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                int32_t num_assays()
                {
                    int32_t ret = iNumAssays_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t num_selected_holes()
                {
                    int32_t ret = iNumSelectedHoles_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t qa_dip_az_curvature_lst(GXLSTPtr param1, double param2, GXWAPtr param3)
                {
                    int32_t ret = iQADipAzCurvatureLST_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t qa_dip_az_survey_lst(GXLSTPtr param1, GXWAPtr param2)
                {
                    int32_t ret = iQADipAzSurveyLST_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t qa_east_north_curvature_lst(GXLSTPtr param1, double param2, GXWAPtr param3)
                {
                    int32_t ret = iQAEastNorthCurvatureLST_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t qa_east_north_survey_lst(GXLSTPtr param1, GXWAPtr param2)
                {
                    int32_t ret = iQAEastNorthSurveyLST_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t slice_selection_tool_gui(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double& param9, double& param10, double& param11, double& param12)
                {
                    int32_t ret = iSliceSelectionToolGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t update_survey_from_collar(int32_t param1)
                {
                    int32_t ret = iUpdateSurveyFromCollar_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void load_data_parameters_ini(GXDBPtr param1, const gx_string_type& param2)
                {
                    LoadDataParametersINI_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void load_plot_parameters(const gx_string_type& param1, DH_PLOT param2)
                {
                    LoadPlotParameters_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void load_select(const gx_string_type& param1)
                {
                    LoadSelect_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void mask_ply(GXPLYPtr param1, GXIPJPtr param2, double param3, const gx_string_type& param4, DH_HOLES param5, DH_MASK param6)
                {
                    MaskPLY_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static GXDHPtr open(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_DH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDH>(ret);
                }

                void open_job(const gx_string_type& param1, DH_PLOT param2)
                {
                    OpenJob_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void plot_hole_traces(GXMAPPtr param1, const gx_string_type& param2)
                {
                    PlotHoleTraces_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void plot_hole_traces_3d(GXMVIEWPtr param1, const gx_string_type& param2)
                {
                    PlotHoleTraces3D_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void plot_symbols_3d(GXMVIEWPtr param1, const gx_string_type& param2)
                {
                    PlotSymbols3D_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void qa_collar(GXWAPtr param1)
                {
                    QACollar_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void qa_collar_lst(GXLSTPtr param1, GXWAPtr param2)
                {
                    QACollarLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void qa_dip_az_curvature(GXWAPtr param1, double param2)
                {
                    QADipAzCurvature_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }

                void qa_dip_az_curvature2(GXWAPtr param1, double param2, const gx_string_type& param3)
                {
                    QADipAzCurvature2_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, param3.c_str());
                    gx_->throw_on_error();
                }

                void qa_dip_az_survey(GXDBPtr param1, GXWAPtr param2, int32_t param3, const gx_string_type& param4)
                {
                    QADipAzSurvey_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }

                void qa_east_north_curvature(GXWAPtr param1, double param2)
                {
                    QAEastNorthCurvature_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }

                void qa_east_north_curvature2(GXWAPtr param1, double param2, const gx_string_type& param3)
                {
                    QAEastNorthCurvature2_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, param3.c_str());
                    gx_->throw_on_error();
                }

                void qa_east_north_survey(GXDBPtr param1, GXWAPtr param2, int32_t param3, const gx_string_type& param4)
                {
                    QAEastNorthSurvey_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }

                void qa_from_to_data(GXDBPtr param1, GXWAPtr param2, int32_t param3, const gx_string_type& param4)
                {
                    QAFromToData_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }

                void qa_point_data(GXDBPtr param1, GXWAPtr param2, int32_t param3, const gx_string_type& param4)
                {
                    QAPointData_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }

                void qa_write_unregistered_holes(GXDBPtr param1, GXWAPtr param2)
                {
                    QAWriteUnregisteredHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void replot_holes(const gx_string_type& param1, DH_PLOT param2)
                {
                    ReplotHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void plot_holes_on_section(const gx_string_type& param1, DH_PLOT param2, const gx_string_type& param3)
                {
                    PlotHolesOnSection_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                void re_survey_east_north(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, double param6, double param7, double param8, double param9, double& param10)
                {
                    ReSurveyEastNorth_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }

                void re_survey_pol_fit(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8, double param9, double param10, DIP_CONVENTION param11, int32_t param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15, GXVVPtr param16)
                {
                    ReSurveyPolFit_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&gx_->handle(param16)));
                    gx_->throw_on_error();
                }

                void re_survey_rad_curve(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8, double param9, double param10, DIP_CONVENTION param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15)
                {
                    ReSurveyRadCurve_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)));
                    gx_->throw_on_error();
                }

                void re_survey_straight(const gx_string_type& param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, DIP_CONVENTION param10, GXVVPtr param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14)
                {
                    ReSurveyStraight_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)));
                    gx_->throw_on_error();
                }

                void re_survey_straight_seg(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8, double param9, double param10, DIP_CONVENTION param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15)
                {
                    ReSurveyStraightSeg_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)));
                    gx_->throw_on_error();
                }

                void save_data_parameters_ini(GXDBPtr param1, const gx_string_type& param2)
                {
                    SaveDataParametersINI_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void save_job(const gx_string_type& param1, DH_PLOT param2)
                {
                    SaveJob_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void save_select(const gx_string_type& param1)
                {
                    SaveSelect_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void section_window_size_mm(double& param1, double& param2)
                {
                    SectionWindowSizeMM_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void select_all_holes()
                {
                    SelectAllHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void select_holes(GXVVPtr param1, int32_t param2)
                {
                    SelectHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void select_name(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    SelectName_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void select_ply(GXPLYPtr param1)
                {
                    SelectPLY_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void select_ply2(GXPLYPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    SelectPLY2_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void set_crooked_section_ipj(GXIPJPtr param1)
                {
                    SetCrookedSectionIPJ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_current_view_name(const gx_string_type& param1)
                {
                    SetCurrentViewName_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_info(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    SetInfo_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_map(GXMAPPtr param1)
                {
                    SetMAP_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_new_ipj(const gx_string_type& param1)
                {
                    SetNewIPJ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_selected_holes_vv(GXVVPtr param1, int32_t param2)
                {
                    SetSelectedHolesVV_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void set_template_blob(GXDBPtr param1, const gx_string_type& param2, DH_DATA param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetTemplateBlob_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void significant_intersections_db(GXDBPtr param1, GXDBPtr param2, DH_COMPSTDB_HOLSEL param3, const gx_string_type& param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11)
                {
                    SignificantIntersectionsDB_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str(), &param5, &param6, &param7, &param8, &param9, &param10, &param11);
                    gx_->throw_on_error();
                }

                void test_import_las(const gx_string_type& param1, const gx_string_type& param2, double param3, GXWAPtr param4, int32_t& param5)
                {
                    TestImportLAS_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                }

                void un_select_all_holes()
                {
                    UnSelectAllHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void un_selected_hole_lst(GXLSTPtr param1)
                {
                    UnSelectedHoleLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void update_collar_table()
                {
                    UpdateCollarTable_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void update_hole_extent(int32_t param1)
                {
                    UpdateHoleExtent_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void wholeplot(const gx_string_type& param1, DH_PLOT param2)
                {
                    Wholeplot_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void surface_intersections(GXDBPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    SurfaceIntersections_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }


            };
            class GXDMPPLY
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDMPPLY(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDMPPLYPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDMPPLY>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear()
                {
                    _Clear_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void copy(GXDMPPLYPtr param1)
                {
                    Copy_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXDMPPLYPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DMPPLY(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDMPPLY>(ret);
                }

                ~GXDMPPLY()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_azimuth(int32_t param1, double& param2)
                {
                    GetAzimuth_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void get_extents(int32_t param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetExtents_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void get_joins(int32_t param1, GXVVPtr param2)
                {
                    GetJoins_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_normal_vectors(int32_t param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10)
                {
                    GetNormalVectors_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }

                void get_poly(int32_t param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GetPoly_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void get_swing(int32_t param1, double& param2)
                {
                    GetSwing_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void get_vertex(int32_t param1, int32_t param2, double& param3, double& param4, double& param5)
                {
                    GetVertex_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                int32_t num_joins()
                {
                    int32_t ret = iNumJoins_DMPPLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t num_polys()
                {
                    int32_t ret = iNumPolys_DMPPLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t num_vertices(int32_t param1)
                {
                    int32_t ret = iNumVertices_DMPPLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void load(const gx_string_type& param1)
                {
                    Load_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void move_vertex(int32_t param1, int32_t param2, double param3, double param4, double param5)
                {
                    MoveVertex_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void project_poly(int32_t param1, double param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9)
                {
                    ProjectPoly_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }

                void re_project_poly(int32_t param1, double param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10)
                {
                    ReProjectPoly_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)));
                    gx_->throw_on_error();
                }

                void save(const gx_string_type& param1)
                {
                    Save_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_poly(int32_t param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    SetPoly_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }


            };
            class GXDOCU
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDOCU(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDOCUPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDOCU>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void copy(GXDOCUPtr param1)
                {
                    Copy_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXDOCUPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DOCU(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDOCU>(ret);
                }

                static GXDOCUPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_DOCU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDOCU>(ret);
                }

                ~GXDOCU()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_file(const gx_string_type& param1)
                {
                    GetFile_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void get_file_meta(const gx_string_type& param1)
                {
                    GetFileMeta_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void doc_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IDocName_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void file_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IFileName_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                bool have_meta()
                {
                    bool ret = 0 != iHaveMETA_DOCU(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_reference()
                {
                    int32_t ret = iIsReference_DOCU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void open(DOCU_OPEN param1)
                {
                    Open_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void serial(GXBFPtr param1)
                {
                    Serial_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_file(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    SetFile_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void set_file_meta(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    SetFileMeta_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }


            };
            class GXDU
            {
            private:
                GXDU();
                ~GXDU();
            public:


                static void table_look1(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, DU_LOOKUP param7, double param8, GXTBPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _TableLook1_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), reinterpret_cast<const long*>(&param7), &param8, reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }

                static void table_look2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, DU_LOOKUP param9, double param10, GXTBPtr param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _TableLook2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), param7.c_str(), param8.c_str(), reinterpret_cast<const long*>(&param9), &param10, reinterpret_cast<const long*>(&gx_->handle(param11)));
                    gx_->throw_on_error();
                }

                static void table_look_i2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, DU_LOOKUP param9, double param10, GXTBPtr param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _TableLookI2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), param7.c_str(), param8.c_str(), reinterpret_cast<const long*>(&param9), &param10, reinterpret_cast<const long*>(&gx_->handle(param11)));
                    gx_->throw_on_error();
                }

                static void table_look_r2(GXDBPtr param1, int32_t param2, double param3, int32_t param4, int32_t param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, DU_LOOKUP param9, double param10, GXTBPtr param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _TableLookR2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), param7.c_str(), param8.c_str(), reinterpret_cast<const long*>(&param9), &param10, reinterpret_cast<const long*>(&gx_->handle(param11)));
                    gx_->throw_on_error();
                }

                static void ado_table_names(const gx_string_type& param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ADOTableNames_DU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void an_sig(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AnSig_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void append(GXDBPtr param1, GXDBPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Append_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void avg_azimuth(GXDBPtr param1, double param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AvgAzimuth_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3);
                    gx_->throw_on_error();
                }

                static void base_data(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXTBPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BaseData_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void base_data_ex(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXTBPtr param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BaseDataEx_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void bound_line(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXPLYPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BoundLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void bp_filt(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, double param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BPFilt_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void break_line(GXDBPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BreakLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void break_line2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BreakLine2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void break_line_to_groups(GXDBPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BreakLineToGroups_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }

                static void break_line_to_groups2(GXDBPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BreakLineToGroups2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void b_spline(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BSpline_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7);
                    gx_->throw_on_error();
                }

                static void closest_point(GXDBPtr param1, double param2, double param3, double& param4, double& param5, int32_t& param6, double& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClosestPoint_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, reinterpret_cast<long*>(&param6), &param7);
                    gx_->throw_on_error();
                }

                static void copy_line(GXDBPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CopyLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void copy_line_across(GXDBPtr param1, int32_t param2, GXDBPtr param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CopyLineAcross_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void copy_line_chan_across(GXDBPtr param1, int32_t param2, GXVVPtr param3, GXDBPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CopyLineChanAcross_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void copy_line_masked(GXDBPtr param1, int32_t param2, int32_t param3, VVU_PRUNE param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CopyLineMasked_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void dao_table_names(const gx_string_type& param1, const gx_string_type& param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DAOTableNames_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void decimate(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Decimate_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void diff(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Diff_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void distance(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Distance_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void distance_3d(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, DU_DISTANCE_CHANNEL_TYPE param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Distance3D_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void distline(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Distline_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5);
                    gx_->throw_on_error();
                }

                static void dup_chan_locks(GXDBPtr param1, GXDBPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DupChanLocks_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void dup_chans(GXDBPtr param1, GXDBPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DupChans_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void edit_duplicates(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, DB_DUP param5, DB_DUPEDIT param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EditDuplicates_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7);
                    gx_->throw_on_error();
                }

                static void export1(GXDBPtr param1, DU_EXPORT param2, const gx_string_type& param3, GXVVPtr param4, DU_CHANNELS param5, const gx_string_type& param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Export_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), param6.c_str(), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void export2(GXDBPtr param1, DU_EXPORT param2, const gx_string_type& param3, GXVVPtr param4, DU_CHANNELS param5, const gx_string_type& param6, int32_t param7, int32_t param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Export2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), param6.c_str(), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                static void export_amira(GXDBPtr param1, GXWAPtr param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportAMIRA_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str());
                    gx_->throw_on_error();
                }

                static void export_aseg(GXDBPtr param1, const gx_string_type& param2, GXVVPtr param3, DU_CHANNELS param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportAseg_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }

                static void export_aseg_proj(GXDBPtr param1, const gx_string_type& param2, GXVVPtr param3, DU_CHANNELS param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, GXIPJPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportAsegProj_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), param7.c_str(), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }

                static void export_chan_crc(GXDBPtr param1, int32_t param2, int32_t& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportChanCRC_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }

                static void export_csv(GXDBPtr param1, const gx_string_type& param2, GXVVPtr param3, DU_CHANNELS param4, const gx_string_type& param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportCSV_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void export_database_crc(GXDBPtr param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportDatabaseCRC_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                static void export_gbn(GXDBPtr param1, GXVVPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportGBN_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }

                static void export_mdb(GXDBPtr param1, const gx_string_type& param2, GXVVPtr param3, DU_CHANNELS param4, DU_LINEOUT param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportMDB_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str());
                    gx_->throw_on_error();
                }

                static void export_geodatabase(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, DU_CHANNELS param5, DU_FEATURE_TYPE_OUTPUT param6, DU_LINEOUT param7, const gx_string_type& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportGeodatabase_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), param8.c_str());
                    gx_->throw_on_error();
                }

                static int32_t get_existing_feature_classes_in_geodatabase(GXDBPtr param1, const gx_string_type& param2, GXLSTPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GetExistingFeatureClassesInGeodatabase_DU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }

                static void export_shp(GXDBPtr param1, const gx_string_type& param2, GXVVPtr param3, DU_CHANNELS param4, DU_LINEOUT param5, const gx_string_type& param6, GXLSTPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportSHP_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void export_xyz(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportXYZ_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void export_xyz2(GXDBPtr param1, GXWAPtr param2, GXRAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportXYZ2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void fft(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FFT_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void filter(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXFLTPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Filter_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void gen_lev(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, double param4, DU_LEVEL param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenLev_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void gen_lev_db(GXDBPtr param1, const gx_string_type& param2, double param3, DU_LEVEL param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenLevDB_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void gen_xyz_temp(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenXYZTemp_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void get_xyz_num_fields(const gx_string_type& param1, int32_t& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetXYZNumFields_DU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }

                static void get_chan_data_lst(GXDBPtr param1, int32_t param2, int32_t param3, GXLSTPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetChanDataLST_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void get_chan_data_vv(GXDBPtr param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetChanDataVV_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void gradient(GXDBPtr param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Gradient_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                }

                static void grav_drift(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GravDrift_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void grav_tide(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GravTide_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void grid_load(GXDBPtr param1, GXIMGPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridLoad_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void grid_load_xyz(GXDBPtr param1, GXIMGPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridLoadXYZ_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

                static void head(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXTBPtr param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Head_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), &param6);
                    gx_->throw_on_error();
                }

                static void import_bin3(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4, int32_t param5, double param6, GXWAPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param4.resize(STR_VERY_LONG);
                    IImportBIN3_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }

                static void imp_cb_ply(GXDBPtr param1, GXPJPtr param2, const gx_string_type& param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImpCBPly_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void import_ado(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportADO_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }

                static void import_all_ado(GXDBPtr param1, const gx_string_type& param2, DU_STORAGE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportAllADO_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void import_all_dao(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, DU_STORAGE param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportAllDAO_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void import_amira(GXDBPtr param1, GXRAPtr param2, GXWAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportAMIRA_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void import_aseg(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportAseg_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void import_aseg_proj(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportAsegProj_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str(), param9.c_str());
                    gx_->throw_on_error();
                }

                static void import_bin(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportBIN_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), &param6);
                    gx_->throw_on_error();
                }

                static void import_bin2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, double param6, GXWAPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportBIN2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void import_bin4(GXDBPtr param1, DU_IMPORT param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6, double param7, GXWAPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportBIN4_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }

                static void import_daarc500_serial(GXDBPtr param1, int32_t param2, const gx_string_type& param3, int32_t param4, GU_DAARC500_DATATYPE param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDAARC500Serial_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void import_daarc500_serial_gps(GXDBPtr param1, int32_t param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDAARC500SerialGPS_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void import_dao(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDAO_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }

                static void import_esri(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportESRI_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                static void import_gbn(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportGBN_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void import_oddf(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportODDF_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void import_pico(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportPico_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void import_ubc_mod_msh(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportUBCModMsh_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), &param5);
                    gx_->throw_on_error();
                }

                static void import_usgs_post(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportUSGSPost_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void import_xyz(GXDBPtr param1, DU_IMPORT param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportXYZ_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                static void import_xyz2(GXDBPtr param1, DU_IMPORT param2, const gx_string_type& param3, const gx_string_type& param4, GXWAPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportXYZ2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void import_io_gas(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportIoGAS_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void index_order(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IndexOrder_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void interp(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, DU_INTERP param5, DU_INTERP_EDGE param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Interp_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void interp_gap(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, DU_INTERP param5, DU_INTERP_EDGE param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    InterpGap_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void intersect(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Intersect_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, param6.c_str());
                    gx_->throw_on_error();
                }

                static void intersect_all(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IntersectAll_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, param6.c_str());
                    gx_->throw_on_error();
                }

                static void intersect_gd_bto_tbl(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IntersectGDBtoTBL_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void intersect_old(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IntersectOld_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }

                static void intersect_tb_lto_gdb(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IntersectTBLtoGDB_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void lab_template(const gx_string_type& param1, const gx_string_type& param2, DU_LAB_TYPE param3, const gx_string_type& param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LabTemplate_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                static void load_gravity(GXDBPtr param1, GXREGPtr param2, int32_t param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadGravity_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }

                static void load_ltb(GXDBPtr param1, int32_t param2, GXLTBPtr param3, DU_LOADLTB param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadLTB_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void make_fid(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MakeFid_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void mask(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Mask_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void math(GXDBPtr param1, int32_t param2, GXEXPPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Math_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void merge_line(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, DU_MERGE param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MergeLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void mod_fid_range(GXDBPtr param1, int32_t param2, double param3, double param4, int32_t param5, int32_t param6, DU_MODFID param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ModFidRange_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void move(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, DU_MOVE param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Move_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void nl_filt(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NLFilt_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6);
                    gx_->throw_on_error();
                }

                static void normal(GXDBPtr param1, int32_t param2, bool param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool3 = param3 ? 1 : 0;
                    Normal_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &paramBool3);
                    gx_->throw_on_error();
                }

                static void poly_fill(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXPLYPtr param6, DU_FILL param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PolyFill_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void poly_mask(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXPLYPtr param6, DU_MASK param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PolyMask_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void project_data(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, GXPJPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProjectData_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void project_xyz(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, GXPJPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProjectXYZ_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }

                static void proj_points(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9, int32_t param10, int32_t param11, int32_t param12, int32_t param13, int32_t param14, int32_t param15, int32_t param16, int32_t param17, int32_t param18, int32_t param19, int32_t param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProjPoints_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14), reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20));
                    gx_->throw_on_error();
                }

                static void qc_init_separation(GXDBPtr param1, double param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    QCInitSeparation_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3);
                    gx_->throw_on_error();
                }

                static int32_t qc_survey_plan(GXDBPtr param1, GXWAPtr param2, GXPLYPtr param3, double param4, double param5, double param6, double param7, int32_t param8, int32_t param9, double param10, double param11, double param12, double param13, int32_t param14, int32_t param15, QC_PLAN_TYPE param16, double param17, double param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = QCSurveyPlan_DU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11, &param12, &param13, reinterpret_cast<const long*>(&param14), reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), &param17, &param18);
                    gx_->throw_on_error();
                    return ret;
                }

                static double direction(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rDirection_DU(
                                     gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }

                static void re_fid(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, DU_REFID param6, double param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReFid_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                static void re_fid_all_ch(GXDBPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReFidAllCh_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void re_fid_ch(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReFidCh_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void rotate(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Rotate_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                static void sample_gd(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXGDPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SampleGD_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void sample_img(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXIMGPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SampleIMG_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void sample_img_line_lst(GXDBPtr param1, GXLSTPtr param2, int32_t param3, int32_t param4, int32_t param5, GXIMGPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SampleIMGLineLST_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void scan_ado(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanADO_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void scan_aseg(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanAseg_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                static void scan_dao(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanDAO_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                static void scan_pico(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanPico_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void sort(GXDBPtr param1, int32_t param2, int32_t param3, DU_SORT param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sort_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void sort_index(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, DU_SORT param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SortIndex_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void sort_index2(GXDBPtr param1, int32_t param2, int32_t param3, DU_SORT param4, int32_t param5, DU_SORT param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SortIndex2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void split_line(GXDBPtr param1, int32_t param2, int32_t param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }

                static void split_line2(GXDBPtr param1, int32_t param2, int32_t param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLine2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void split_line_xy(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7, DU_SPLITLINE param8, int32_t& param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLineXY_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

                static void split_line_xy2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7, DU_SPLITLINE param8, int32_t& param9, int32_t param10, int32_t param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLineXY2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }

                static void split_line_xy3(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7, DU_SPLITLINE param8, int32_t& param9, int32_t param10, int32_t param11, int32_t param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLineXY3_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }

                static void split_line_by_direction(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, double param6, double param7, double param8, bool param9, DU_SPLITLINE param10, int32_t& param11, int32_t param12, int32_t param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool9 = param9 ? 1 : 0;
                    SplitLineByDirection_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &paramBool9, reinterpret_cast<const long*>(&param10), reinterpret_cast<long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13));
                    gx_->throw_on_error();
                }

                static void split_line_by_direction2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, double param6, double param7, double param8, bool param9, DU_SPLITLINE param10, int32_t& param11, int32_t param12, int32_t param13, int32_t param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool9 = param9 ? 1 : 0;
                    SplitLineByDirection2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &paramBool9, reinterpret_cast<const long*>(&param10), reinterpret_cast<long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14));
                    gx_->throw_on_error();
                }

                static void stat(GXDBPtr param1, int32_t param2, int32_t param3, GXSTPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Stat_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void table_line_fid(GXDBPtr param1, int32_t param2, int32_t param3, GXTBPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TableLineFid_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void table_selected_lines_fid(GXDBPtr param1, int32_t param2, int32_t param3, GXTBPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TableSelectedLinesFid_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void time_constant(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TimeConstant_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void trend(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Trend_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void update_intersect_db(GXDBPtr param1, int32_t param2, int32_t param3, GXDBPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UpdateIntersectDB_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void voxel_section(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXVOXPtr param5, const gx_string_type& param6, double param7, double param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    VoxelSection_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), param6.c_str(), &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                static void write_wa(GXDBPtr param1, int32_t param2, GXLSTPtr param3, GXWAPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    WriteWA_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void xyz_line(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    XyzLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6);
                    gx_->throw_on_error();
                }

                static void xyz_line2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    XyzLine2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7);
                    gx_->throw_on_error();
                }

                static void xyz_line3(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    XyzLine3_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void z_mask(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ZMask_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6);
                    gx_->throw_on_error();
                }

                static void range_xy(GXDBPtr param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeXY_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                static void range_xyz(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, int32_t& param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeXYZ_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<long*>(&param11));
                    gx_->throw_on_error();
                }

                static void range_xyz_data(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13, int32_t& param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeXYZData_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, reinterpret_cast<long*>(&param14));
                    gx_->throw_on_error();
                }

                static void create_drillhole_parameter_weight_constraint_database(GXDBPtr param1, int32_t param2, GXREGPtr param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateDrillholeParameterWeightConstraintDatabase_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str());
                    gx_->throw_on_error();
                }

                static void calculate_draped_survey_altitude(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXIMGPtr param5, int32_t param6, double param7, double param8, double param9, int32_t param10, double param11, double param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CalculateDrapedSurveyAltitude_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), &param11, &param12);
                    gx_->throw_on_error();
                }

                static void calculate_draped_survey_altitude2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXIMGPtr param5, int32_t param6, int32_t param7, double param8, double param9, double param10, double param11, int32_t param12, double param13, double param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CalculateDrapedSurveyAltitude2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, &param9, &param10, &param11, reinterpret_cast<const long*>(&param12), &param13, &param14);
                    gx_->throw_on_error();
                }

                static void direct_grid_data_to_voxel(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6, double param7, double param8, double param9, int32_t param10, int32_t param11, int32_t param12, double param13, double param14, double param15, DU_DIRECTGRID_METHOD param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGridDataToVoxel_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), &param13, &param14, &param15, reinterpret_cast<const long*>(&param16));
                    gx_->throw_on_error();
                }

                static void direct_grid_item_counts_to_voxel(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6, double param7, double param8, double param9, int32_t param10, int32_t param11, int32_t param12, double param13, double param14, double param15, bool param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool16 = param16 ? 1 : 0;
                    DirectGridItemCountsToVoxel_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), &param13, &param14, &param15, &paramBool16);
                    gx_->throw_on_error();
                }


            };
            class GXDXFI
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDXFI(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDXFIPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDXFI>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDXFIPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DXFI(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDXFI>(ret);
                }

                ~GXDXFI()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DXFI(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                static void dxf2_ply(GXPLYPtr param1, GXDXFIPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DXF2PLY_DXFI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void dxf2_view_ex(GXMVIEWPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, int32_t param5, MVIEW_COLOR param6)
                {
                    DXF2ViewEx_DXFI(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                void get_range(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetRange_DXFI(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }


            };
            class GXEDB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEDB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEDBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEDB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void apply_formula_internal(const gx_string_type& param1)
                {
                    App_ApplyFormulaInternal_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                static GXEDBPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Current_EDB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }

                static GXEDBPtr current_no_activate()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentNoActivate_EDB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }

                static GXEDBPtr current_if_exists()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentIfExists_EDB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }

                void del_line0()
                {
                    App_DelLine0_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                ~GXEDB()
                {
                    if (handle_ == 0)
                        return;
                    App_Destroy_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void destroy_view(EDB_REMOVE param1)
                {
                    App_DestroyView_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                int32_t get_cur_chan_symb()
                {
                    int32_t ret = App_GetCurChanSymb_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_cur_line_symb()
                {
                    int32_t ret = App_GetCurLineSymb_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_displ_fid_range(int32_t& param1, int32_t& param2)
                {
                    App_GetDisplFidRange_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }

                void get_fid_range(double& param1, double& param2, int32_t& param3)
                {
                    App_GetFidRange_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }

                int32_t get_next_line_symb()
                {
                    int32_t ret = App_GetNextLineSymb_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_prev_line_symb()
                {
                    int32_t ret = App_GetPrevLineSymb_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_profile_range_x(double& param1, double& param2, int32_t& param3)
                {
                    App_GetProfileRangeX_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }

                void get_profile_range_y(int32_t param1, int32_t param2, double& param3, double& param4, EDB_PROFILE_SCALE& param5)
                {
                    App_GetProfileRangeY_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                }

                void get_profile_split(double& param1, double& param2)
                {
                    App_GetProfileSplit_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void get_profile_split5(double& param1, double& param2, double& param3, double& param4)
                {
                    App_GetProfileSplit5_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void get_profile_split_vv(GXVVPtr param1)
                {
                    App_GetProfileSplitVV_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_profile_vertical_grid_lines(int32_t& param1, double& param2)
                {
                    App_GetProfileVerticalGridLines_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void get_profile_window(int32_t param1, int32_t& param2, int32_t& param3)
                {
                    App_GetProfileWindow_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }

                void goto_column(int32_t param1)
                {
                    App_GotoColumn_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void goto_elem(int32_t param1)
                {
                    App_GotoElem_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void goto_line(int32_t param1)
                {
                    App_GotoLine_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void histogram(GXSTPtr param1, double param2, double param3, int32_t param4)
                {
                    App_Histogram_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                int32_t all_chan_list(GXVVPtr param1)
                {
                    int32_t ret = App_iAllChanList_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t channels()
                {
                    int32_t ret = App_iChannels_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t disp_chan_list(GXVVPtr param1)
                {
                    int32_t ret = App_iDispChanList_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t disp_chan_lst(GXLSTPtr param1)
                {
                    int32_t ret = App_iDispChanLST_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t disp_class_chan_lst(GXLSTPtr param1, const gx_string_type& param2)
                {
                    int32_t ret = App_iDispClassChanLST_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_channel_column(const gx_string_type& param1)
                {
                    int32_t ret = App_iFindChannelColumn_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_nearest(double& param1, double& param2, double& param3, GXIPJPtr param4)
                {
                    int32_t ret = App_iFindNearest_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_cur_chan(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param1.resize(STR_DB_SYMBOL);
                    App_IGetCurChan_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_cur_fid_string(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param1.resize(STR_DB_SYMBOL);
                    App_IGetCurFidString_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_cur_line(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param1.resize(STR_DB_SYMBOL);
                    App_IGetCurLine_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                int32_t get_cur_mark(double& param1, double& param2, double& param3)
                {
                    int32_t ret = App_iGetCurMark_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }

                void get_current_selection(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    param2.resize(STR_DB_SYMBOL);
                    param3.resize(STR_DB_SYMBOL);
                    param4.resize(STR_DB_SYMBOL);
                    App_IGetCurrentSelection_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize6 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize8 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }

                static int32_t get_databases_lst(GXLSTPtr param1, EDB_PATH param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetDatabasesLST_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_mark_chan_vv(GXVVPtr param1, int32_t param2)
                {
                    int32_t ret = App_iGetMarkChanVV_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_mark_chan_va(GXVAPtr param1, int32_t param2)
                {
                    int32_t ret = App_iGetMarkChanVA_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    App_IGetName_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                int32_t get_profile_parm_int(int32_t param1, int32_t param2, EDB_PROF param3)
                {
                    int32_t ret = App_iGetProfileParm_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                EDB_WINDOW_STATE get_window_state()
                {
                    EDB_WINDOW_STATE ret = (EDB_WINDOW_STATE)App_iGetWindowState_EDB(
                                               gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static bool have_current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != App_iHaveCurrent_EDB(
                                   gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                bool is_locked()
                {
                    bool ret = 0 != App_iIsLocked_EDB(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t loaded(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iLoaded_EDB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t profile_open(int32_t param1)
                {
                    int32_t ret = App_iProfileOpen_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                bool read_only()
                {
                    bool ret = 0 != App_iReadOnly_EDB(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_window_position(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, EDB_WINDOW_STATE& param5, EDB_WINDOW_POSITION& param6)
                {
                    App_GetWindowPosition_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }

                void set_window_position(int32_t param1, int32_t param2, int32_t param3, int32_t param4, EDB_WINDOW_STATE param5, EDB_WINDOW_POSITION param6)
                {
                    App_SetWindowPosition_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                int32_t show_profile_name(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = App_iShowProfileName_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                EDB_YAXIS_DIRECTION get_window_y_axis_direction(int32_t param1)
                {
                    EDB_YAXIS_DIRECTION ret = (EDB_YAXIS_DIRECTION)App_iGetWindowYAxisDirection_EDB(
                                                  gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t window_profiles(int32_t param1)
                {
                    int32_t ret = App_iWindowProfiles_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void launch_histogram(const gx_string_type& param1)
                {
                    LaunchHistogram_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void launch_scatter()
                {
                    LaunchScatter_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static GXEDBPtr load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Load_EDB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }

                static GXEDBPtr load_no_activate(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadNoActivate_EDB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }

                void load_all_chans()
                {
                    App_LoadAllChans_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void load_chan(const gx_string_type& param1)
                {
                    App_LoadChan_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                static GXEDBPtr load_new(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadNew_EDB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }

                static GXEDBPtr load_pass(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadPass_EDB(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }

                static GXEDBPtr load_with_view(const gx_string_type& param1, GXEDBPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadWithView_EDB(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }

                GXDBPtr lock()
                {
                    int32_t ret = App_Lock_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }

                void make_current()
                {
                    App_MakeCurrent_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void remove_profile(int32_t param1, int32_t param2)
                {
                    App_RemoveProfile_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                double get_cur_fid()
                {
                    double ret = App_rGetCurFid_EDB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double get_profile_parm_double(int32_t param1, int32_t param2, EDB_PROF param3)
                {
                    double ret = App_rGetProfileParm_EDB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                double get_split()
                {
                    double ret = App_rGetSplit_EDB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void run_channel_maker(const gx_string_type& param1)
                {
                    App_RunChannelMaker_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void run_channel_makers()
                {
                    App_RunChannelMakers_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void set_cur_line(const gx_string_type& param1)
                {
                    App_SetCurLine_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_cur_line_no_message(const gx_string_type& param1)
                {
                    App_SetCurLineNoMessage_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_cur_mark(double param1, double param2)
                {
                    App_SetCurMark_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void set_profile_parm_i(int32_t param1, int32_t param2, EDB_PROF param3, int32_t param4)
                {
                    App_SetProfileParmI_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void set_profile_parm_r(int32_t param1, int32_t param2, EDB_PROF param3, double param4)
                {
                    App_SetProfileParmR_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }

                void set_profile_range_x(double param1, double param2, int32_t param3)
                {
                    App_SetProfileRangeX_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void set_profile_range_y(int32_t param1, int32_t param2, double param3, double param4, EDB_PROFILE_SCALE param5)
                {
                    App_SetProfileRangeY_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                void set_profile_split(double param1, double param2)
                {
                    App_SetProfileSplit_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void set_profile_split5(double param1, double param2, double param3, double param4)
                {
                    App_SetProfileSplit5_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void set_profile_split_vv(GXVVPtr param1)
                {
                    App_SetProfileSplitVV_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_split(double param1)
                {
                    App_SetSplit_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_window_state(EDB_WINDOW_STATE param1)
                {
                    App_SetWindowState_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void show_profile(int32_t param1, int32_t param2)
                {
                    App_ShowProfile_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void statistics(GXSTPtr param1)
                {
                    App_Statistics_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void un_load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoad_EDB(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void un_load_all()
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadAll_EDB(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                void un_load_all_chans()
                {
                    App_UnLoadAllChans_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void un_load_chan(const gx_string_type& param1)
                {
                    App_UnLoadChan_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                static void un_load_discard(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadDiscard_EDB(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void un_load_verify(const gx_string_type& param1, EDB_UNLOAD param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadVerify_EDB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void un_lock()
                {
                    App_UnLock_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }


            };
            class GXEDOC
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEDOC(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEDOCPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEDOC>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXEDOCPtr create_new_gms_3d(const gx_string_type& param1, int32_t param2, int32_t param3, GMS3D_MODELTYPE param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CreateNewGMS3D_EDOC(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }

                static GXEDOCPtr current(EDOC_TYPE param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Current_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }

                static GXEDOCPtr current_no_activate(EDOC_TYPE param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentNoActivate_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }

                static GXEDOCPtr current_if_exists(EDOC_TYPE param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentIfExists_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }

                ~GXEDOC()
                {
                    if (handle_ == 0)
                        return;
                    App_Destroy_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                static int32_t get_documents_lst(GXLSTPtr param1, EDOC_PATH param2, EDOC_TYPE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetDocumentsLST_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    App_IGetName_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                EDOC_WINDOW_STATE get_window_state()
                {
                    EDOC_WINDOW_STATE ret = (EDOC_WINDOW_STATE)App_iGetWindowState_EDOC(
                                                gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static bool have_current(EDOC_TYPE param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != App_iHaveCurrent_EDOC(
                                   gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t loaded(const gx_string_type& param1, EDOC_TYPE param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iLoaded_EDOC(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_window_position(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, EDOC_WINDOW_STATE& param5, EDOC_WINDOW_POSITION& param6)
                {
                    App_GetWindowPosition_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }

                void set_window_position(int32_t param1, int32_t param2, int32_t param3, int32_t param4, EDOC_WINDOW_STATE param5, EDOC_WINDOW_POSITION param6)
                {
                    App_SetWindowPosition_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                bool read_only()
                {
                    bool ret = 0 != App_iReadOnly_EDOC(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static GXEDOCPtr load(const gx_string_type& param1, EDOC_TYPE param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Load_EDOC(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }

                static GXEDOCPtr load_no_activate(const gx_string_type& param1, EDOC_TYPE param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadNoActivate_EDOC(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }

                void make_current()
                {
                    App_MakeCurrent_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void set_window_state(EDOC_WINDOW_STATE param1)
                {
                    App_SetWindowState_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void sync(const gx_string_type& param1, EDOC_TYPE param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_Sync_EDOC(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void sync_open()
                {
                    App_SyncOpen_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static void un_load(const gx_string_type& param1, EDOC_TYPE param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoad_EDOC(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void un_load_all(EDOC_TYPE param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadAll_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void un_load_discard(const gx_string_type& param1, EDOC_TYPE param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadDiscard_EDOC(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void un_load_verify(const gx_string_type& param1, EDOC_UNLOAD param2, EDOC_TYPE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadVerify_EDOC(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }


            };
            class GXEMAP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEMAP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEMAPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEMAP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void drop_map_clip_data(int32_t param1)
                {
                    App_DropMapClipData_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                bool drag_drop_enabled()
                {
                    bool ret = 0 != App_iDragDropEnabled_EMAP(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_drag_drop_enabled(bool param1)
                {
                    long paramBool1 = param1 ? 1 : 0;
                    App_SetDragDropEnabled_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &paramBool1);
                    gx_->throw_on_error();
                }

                void copy_to_clip()
                {
                    App_CopyToClip_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void draw_line(double param1, double param2, double param3, double param4)
                {
                    App_DrawLine_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void draw_rect(double param1, double param2, double param3, double param4)
                {
                    App_DrawRect_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void draw_rect_3d(double param1, double param2, double param3, int32_t param4)
                {
                    App_DrawRect3D_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void get_display_area(double& param1, double& param2, double& param3, double& param4)
                {
                    App_GetDisplayArea_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void get_display_area_raw(double& param1, double& param2, double& param3, double& param4)
                {
                    App_GetDisplayAreaRaw_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void get_map_layout_props(bool& param1, double& param2, int32_t& param3, int32_t& param4, LAYOUT_VIEW_UNITS& param5, int32_t& param6, int32_t& param7, int32_t& param8)
                {
                    long paramBool1 = param1 ? 1 : 0;
                    App_GetMapLayoutProps_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &paramBool1, &param2, reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7), reinterpret_cast<long*>(&param8));
                    gx_->throw_on_error();
                    param1 = paramBool1 != 0 ? true : false;
                }

                void get_map_snap(double& param1)
                {
                    App_GetMapSnap_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                EMAP_WINDOW_STATE get_window_state()
                {
                    EMAP_WINDOW_STATE ret = (EMAP_WINDOW_STATE)App_iGetWindowState_EMAP(
                                                gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_display_area(double param1, double param2, double param3, double param4)
                {
                    App_SetDisplayArea_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void set_map_layout_props(bool param1, double param2, int32_t param3, int32_t param4, LAYOUT_VIEW_UNITS param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    long paramBool1 = param1 ? 1 : 0;
                    App_SetMapLayoutProps_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &paramBool1, &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                void set_map_snap(double param1)
                {
                    App_SetMapSnap_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_window_state(EMAP_WINDOW_STATE param1)
                {
                    App_SetWindowState_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void activate_group(const gx_string_type& param1)
                {
                    App_ActivateGroup_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void activate_view(const gx_string_type& param1)
                {
                    App_ActivateView_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                static GXEMAPPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Current_EMAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }

                static GXEMAPPtr current_no_activate()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentNoActivate_EMAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }

                static GXEMAPPtr current_if_exists()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentIfExists_EMAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }

                ~GXEMAP()
                {
                    if (handle_ == 0)
                        return;
                    App_Destroy_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void destroy_view(EMAP_REMOVE param1)
                {
                    App_DestroyView_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void font_lst(GXLSTPtr param1, EMAP_FONT param2)
                {
                    App_FontLST_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                int32_t change_current_view(const gx_string_type& param1)
                {
                    int32_t ret = App_iChangeCurrentView_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t create_group_snapshot(GXLSTPtr param1)
                {
                    int32_t ret = App_iCreateGroupSnapshot_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_3d_view_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    App_IGet3DViewName_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_current_group(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VIEW_GROUP * STRING_CHAR_SIZE;
                    param1.resize(STR_VIEW_GROUP);
                    App_IGetCurrentGroup_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_current_view(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VIEW * STRING_CHAR_SIZE;
                    param1.resize(STR_VIEW);
                    App_IGetCurrentView_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static int32_t get_maps_lst(GXLSTPtr param1, EMAP_PATH param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetMapsLST_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    App_IGetName_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static int32_t have_current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iHaveCurrent_EMAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t i_get_specified_map_name(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iIGetSpecifiedMapName_EMAP(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                int32_t is_grid()
                {
                    int32_t ret = App_iIsGrid_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static void reload_grid(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ReloadGrid_EMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                int32_t is_3d_view()
                {
                    int32_t ret = App_iIs3DView_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                bool is_locked()
                {
                    bool ret = 0 != App_iIsLocked_EMAP(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t loaded(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iLoaded_EMAP(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                bool read_only()
                {
                    bool ret = 0 != App_iReadOnly_EMAP(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_window_position(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, EMAP_WINDOW_STATE& param5, EMAP_WINDOW_POSITION& param6)
                {
                    App_GetWindowPosition_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }

                void set_window_position(int32_t param1, int32_t param2, int32_t param3, int32_t param4, EMAP_WINDOW_STATE param5, EMAP_WINDOW_POSITION param6)
                {
                    App_SetWindowPosition_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                int32_t doubleize_group_snapshot(GXLSTPtr param1)
                {
                    int32_t ret = App_iRealizeGroupSnapshot_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t set_current_view(const gx_string_type& param1)
                {
                    int32_t ret = App_iSetCurrentView_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_view_ipj(const gx_string_type& param1, GXIPJPtr param2)
                {
                    App_GetViewIPJ_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static GXEMAPPtr load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Load_EMAP(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }

                static GXEMAPPtr load_no_activate(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadNoActivate_EMAP(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }

                static GXEMAPPtr load_with_view(const gx_string_type& param1, GXEMAPPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadWithView_EMAP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }

                GXMAPPtr lock()
                {
                    int32_t ret = App_Lock_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAP>(ret);
                }

                void make_current()
                {
                    App_MakeCurrent_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void print(int32_t param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, double param9, int32_t param10, int32_t param11, int32_t param12, const gx_string_type& param13)
                {
                    App_Print_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), param13.c_str());
                    gx_->throw_on_error();
                }

                void redraw()
                {
                    App_Redraw_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void select_group(const gx_string_type& param1)
                {
                    App_SelectGroup_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_redraw_flag(EMAP_REDRAW param1)
                {
                    App_SetRedrawFlag_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void un_load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoad_EMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void un_load_all()
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadAll_EMAP(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void un_load_verify(const gx_string_type& param1, bool param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool2 = param2 ? 1 : 0;
                    App_UnLoadVerify_EMAP(
                        gx_->pGeo, param1.c_str(), &paramBool2);
                    gx_->throw_on_error();
                }

                void un_lock()
                {
                    App_UnLock_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void get_cur_point(double& param1, double& param2)
                {
                    App_GetCurPoint_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void get_cur_point_mm(double& param1, double& param2)
                {
                    App_GetCurPointMM_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void get_cursor(double& param1, double& param2)
                {
                    App_GetCursor_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void get_cursor_mm(double& param1, double& param2)
                {
                    App_GetCursorMM_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                int32_t digitize(GXWAPtr param1, GXIMGPtr param2, int32_t param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, int32_t param7)
                {
                    int32_t ret = App_iDigitize_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str(), param6.c_str(), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t digitize2(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXIMGPtr param4, const gx_string_type& param5, int32_t param6)
                {
                    int32_t ret = App_iDigitize2_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t digitize_peaks(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXIMGPtr param4, const gx_string_type& param5, int32_t param6)
                {
                    int32_t ret = App_iDigitizePeaks_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t digitize_polygon(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXIMGPtr param4, const gx_string_type& param5, int32_t param6, int32_t param7)
                {
                    int32_t ret = App_iDigitizePolygon_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_box(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetBox_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_box2(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9)
                {
                    int32_t ret = App_iGetBox2_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_grid(const gx_string_type& param1, int32_t param2, int32_t param3, double& param4, double& param5, double& param6, double& param7, double& param8)
                {
                    int32_t ret = App_iGetGrid_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_line(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetLine_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_line_ex(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetLineEx_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_line_xyz(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7)
                {
                    int32_t ret = App_iGetLineXYZ_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_point(const gx_string_type& param1, double& param2, double& param3)
                {
                    int32_t ret = App_iGetPoint_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_point_ex(const gx_string_type& param1, double& param2, double& param3)
                {
                    int32_t ret = App_iGetPointEx_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_point_3d(const gx_string_type& param1, double& param2, double& param3, double& param4)
                {
                    int32_t ret = App_iGetPoint3D_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_poly_line(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3)
                {
                    int32_t ret = App_iGetPolyLine_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_poly_line_xyz(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    int32_t ret = App_iGetPolyLineXYZ_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_rect(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetRect_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t track_point(EMAP_TRACK param1, double& param2, double& param3)
                {
                    int32_t ret = App_iTrackPoint_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }

                void get_aoi_area(double& param1, double& param2, double& param3, double& param4)
                {
                    App_GetAOIArea_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void set_aoi_area(double param1, double param2, double param3, double param4)
                {
                    App_SetAOIArea_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void set_viewport_mode(EMAP_VIEWPORT param1)
                {
                    App_SetViewportMode_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void get_selected_vertices(GXVVPtr param1, GXVVPtr param2)
                {
                    App_GetSelectedVertices_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static GXEMAPPtr create_virtual(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CreateVirtual_EMAP(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }


            };
            class GXEMAPTEMPLATE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEMAPTEMPLATE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEMAPTEMPLATEPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEMAPTEMPLATE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                bool drag_drop_enabled()
                {
                    bool ret = 0 != App_iDragDropEnabled_EMAPTEMPLATE(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_drag_drop_enabled(bool param1)
                {
                    long paramBool1 = param1 ? 1 : 0;
                    App_SetDragDropEnabled_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &paramBool1);
                    gx_->throw_on_error();
                }

                static GXEMAPTEMPLATEPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Current_EMAPTEMPLATE(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }

                static GXEMAPTEMPLATEPtr current_no_activate()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentNoActivate_EMAPTEMPLATE(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }

                static GXEMAPTEMPLATEPtr current_if_exists()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentIfExists_EMAPTEMPLATE(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }

                ~GXEMAPTEMPLATE()
                {
                    if (handle_ == 0)
                        return;
                    App_Destroy_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                static int32_t get_map_templates_lst(GXLSTPtr param1, EMAPTEMPLATE_PATH param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetMapTemplatesLST_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    App_IGetName_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static int32_t have_current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iHaveCurrent_EMAPTEMPLATE(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t i_get_specified_map_name(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iIGetSpecifiedMapName_EMAPTEMPLATE(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                bool is_locked()
                {
                    bool ret = 0 != App_iIsLocked_EMAPTEMPLATE(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t loaded(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iLoaded_EMAPTEMPLATE(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_window_position(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, EMAPTEMPLATE_WINDOW_STATE& param5, EMAPTEMPLATE_WINDOW_POSITION& param6)
                {
                    App_GetWindowPosition_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }

                void set_window_position(int32_t param1, int32_t param2, int32_t param3, int32_t param4, EMAPTEMPLATE_WINDOW_STATE param5, EMAPTEMPLATE_WINDOW_POSITION param6)
                {
                    App_SetWindowPosition_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                bool read_only()
                {
                    bool ret = 0 != App_iReadOnly_EMAPTEMPLATE(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static GXEMAPTEMPLATEPtr load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Load_EMAPTEMPLATE(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }

                static GXEMAPTEMPLATEPtr load_no_activate(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadNoActivate_EMAPTEMPLATE(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }

                GXMAPTEMPLATEPtr lock()
                {
                    int32_t ret = App_Lock_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAPTEMPLATE>(ret);
                }

                void make_current()
                {
                    App_MakeCurrent_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static void un_load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoad_EMAPTEMPLATE(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void un_load_all()
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadAll_EMAPTEMPLATE(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void un_load_verify(const gx_string_type& param1, bool param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool2 = param2 ? 1 : 0;
                    App_UnLoadVerify_EMAPTEMPLATE(
                        gx_->pGeo, param1.c_str(), &paramBool2);
                    gx_->throw_on_error();
                }

                void un_lock()
                {
                    App_UnLock_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                int32_t get_box(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetBox_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_line(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetLine_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_point(const gx_string_type& param1, double& param2, double& param3)
                {
                    int32_t ret = App_iGetPoint_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_rect(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetRect_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t track_point(EMAPTEMPLATE_TRACK param1, double& param2, double& param3)
                {
                    int32_t ret = App_iTrackPoint_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }

                bool get_item_selection(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    bool ret = 0 != App_iGetItemSelection_EMAPTEMPLATE(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }

                void set_item_selection(const gx_string_type& param1)
                {
                    App_SetItemSelection_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void get_display_area(double& param1, double& param2, double& param3, double& param4)
                {
                    App_GetDisplayArea_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void get_template_layout_props(bool& param1, double& param2, int32_t& param3, int32_t& param4, LAYOUT_VIEW_UNITS& param5, int32_t& param6, int32_t& param7, int32_t& param8)
                {
                    long paramBool1 = param1 ? 1 : 0;
                    App_GetTemplateLayoutProps_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &paramBool1, &param2, reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7), reinterpret_cast<long*>(&param8));
                    gx_->throw_on_error();
                    param1 = paramBool1 != 0 ? true : false;
                }

                EMAPTEMPLATE_WINDOW_STATE get_window_state()
                {
                    EMAPTEMPLATE_WINDOW_STATE ret = (EMAPTEMPLATE_WINDOW_STATE)App_iGetWindowState_EMAPTEMPLATE(
                                                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_display_area(double param1, double param2, double param3, double param4)
                {
                    App_SetDisplayArea_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void set_template_layout_props(bool param1, double param2, int32_t param3, int32_t param4, LAYOUT_VIEW_UNITS param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    long paramBool1 = param1 ? 1 : 0;
                    App_SetTemplateLayoutProps_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &paramBool1, &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                void set_window_state(EMAPTEMPLATE_WINDOW_STATE param1)
                {
                    App_SetWindowState_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static GXEMAPTEMPLATEPtr create_virtual(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CreateVirtual_EMAPTEMPLATE(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }


            };
            class GXEUL3
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEUL3(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEUL3Ptr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEUL3>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void destr()
                {
                    _Destr_EUL3(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static GXEUL3Ptr creat(GXIMGPtr param1, GXIMGPtr param2, GXIMGPtr param3, GXIMGPtr param4, int32_t param5, double param6, double param7, double param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Creat_EUL3(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), &param6, &param7, &param8, reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEUL3>(ret);
                }

                void get_result(GXVVPtr param1, EUL3_RESULT param2)
                {
                    GetResult_EUL3(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void write(const gx_string_type& param1)
                {
                    Write_EUL3(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                static int32_t ex_euler_derive(GXVVPtr param1, double param2, GXVVPtr param3, int32_t param4, GXVVPtr param5, GXVVPtr param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ExEulerDerive_EUL3(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t ex_euler_calc(int32_t param1, double param2, int32_t param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, int32_t param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15, int32_t param16, GXVVPtr param17, GXVVPtr param18, GXVVPtr param19, GXVVPtr param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ExEulerCalc_EUL3(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), &param2, reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), reinterpret_cast<const long*>(&gx_->handle(param20)));
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXEXP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEXP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEXPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEXP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXEXPPtr create(GXDBPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_EXP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEXP>(ret);
                }

                static GXEXPPtr create_file(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateFile_EXP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEXP>(ret);
                }

                ~GXEXP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_EXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }


            };
            class GXFFT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXFFT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXFFTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXFFT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void app_dens(double param1, double param2)
                {
                    AppDens_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void app_susc(double param1)
                {
                    AppSusc_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void band_pass(double param1, double param2, int32_t param3)
                {
                    BandPass_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void b_worth(double param1, double param2, int32_t param3)
                {
                    BWorth_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void rc_filter(double param1, int32_t param2)
                {
                    RCFilter_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void contin(double param1)
                {
                    Contin_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void cos_roll(double param1, double param2, double param3, int32_t param4)
                {
                    CosRoll_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static GXFFTPtr create(GXVVPtr param1, double param2, FFT_DETREND param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_FFT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFFT>(ret);
                }

                static GXFFTPtr create_ex(GXVVPtr param1, double param2, FFT_DETREND param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateEx_FFT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFFT>(ret);
                }

                static GXFFTPtr create_ref(GXVVPtr param1, double param2, FFT_DETREND param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateRef_FFT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFFT>(ret);
                }

                static GXFFTPtr create_ref_ex(GXVVPtr param1, double param2, FFT_DETREND param3, double param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateRefEx_FFT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3), &param4, &param5);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFFT>(ret);
                }

                ~GXFFT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void gaus(double param1, int32_t param2)
                {
                    Gaus_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void get_vv(GXVVPtr param1, GXVVPtr param2)
                {
                    GetVV_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void h_drv(double param1)
                {
                    HDrv_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void high_pass(double param1, double param2)
                {
                    HighPass_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void h_int()
                {
                    HInt_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void inverse(GXVVPtr param1, GXVVPtr param2)
                {
                    Inverse_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void low_pass(double param1)
                {
                    LowPass_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void red_pol(double param1, double param2, double param3, double param4)
                {
                    RedPol_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                double nyquist()
                {
                    double ret = rNyquist_FFT(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double samp_incr()
                {
                    double ret = rSampIncr_FFT(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double wave_incr()
                {
                    double ret = rWaveIncr_FFT(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_vv(GXVVPtr param1, GXVVPtr param2)
                {
                    SetVV_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void spectrum(GXVVPtr param1)
                {
                    Spectrum_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void v_drv(double param1)
                {
                    VDrv_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void v_int()
                {
                    VInt_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void write_spectrum(GXVVPtr param1, const gx_string_type& param2)
                {
                    WriteSpectrum_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXFFT2
            {
            private:
                GXFFT2();
                ~GXFFT2();
            public:


                static void fft2_in(GXIMGPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Fft2In_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void filter_pg(GXPGPtr param1, const gx_string_type& param2, GXTRPtr param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FilterPG_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                static void flt(GXIMGPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Flt_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void flt_inv(GXIMGPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FltInv_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void pow_spc(GXIMGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PowSpc_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void rad_spc(GXIMGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RadSpc_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void rad_spc1(GXIMGPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RadSpc1_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void rad_spc2(GXIMGPtr param1, GXIMGPtr param2, GXVVPtr param3, GXVVPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RadSpc2_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void td_xd_y(GXIMGPtr param1, GXIMGPtr param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TdXdY_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void trans_pg(GXPGPtr param1, FFT2_PG param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TransPG_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }


            };
            class GXFLT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXFLT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXFLTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXFLT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXFLTPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_FLT(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFLT>(ret);
                }

                ~GXFLT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_FLT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                static GXFLTPtr load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Load_FLT(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFLT>(ret);
                }


            };
            class GXGD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXGD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXGDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXGD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXGDPtr create(const gx_string_type& param1, GD_STATUS param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_GD(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXGD>(ret);
                }

                ~GXGD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_GD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }


            };
            class GXGER
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXGER(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXGERPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXGER>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXGERPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_GER(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXGER>(ret);
                }

                ~GXGER()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_GER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t get(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    int32_t ret = IiGet_GER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }

                void set_int(const gx_string_type& param1, int32_t param2)
                {
                    SetInt_GER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_double(const gx_string_type& param1, double param2)
                {
                    SetReal_GER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }

                void set_string(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SetString_GER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXGMSYS
            {
            private:
                GXGMSYS();
                ~GXGMSYS();
            public:


                static void launch(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Launch_GMSYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXGU
            {
            private:
                GXGU();
                ~GXGU();
            public:


                static void dipole_mag(const gx_string_type& param1, double param2, double param3, int32_t param4, int32_t param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DipoleMag_GU(
                        gx_->pGeo, param1.c_str(), &param2, &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7);
                    gx_->throw_on_error();
                }

                static void em_half_space_inv(double param1, double param2, EMLAY_GEOMETRY param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, EM_INV param10, EM_ERR param11, double param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EMHalfSpaceInv_GU(
                        gx_->pGeo, &param1, &param2, reinterpret_cast<const long*>(&param3), &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), &param12);
                    gx_->throw_on_error();
                }

                static void em_half_space_vv(double param1, double param2, EMLAY_GEOMETRY param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EMHalfSpaceVV_GU(
                        gx_->pGeo, &param1, &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void geometrics2_db(GXDBPtr param1, GXRAPtr param2, GXWAPtr param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, double param8, double param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Geometrics2DB_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, &param9, &param10, &param11);
                    gx_->throw_on_error();
                }

                static void geometrics2_tbl(GXRAPtr param1, GXWAPtr param2, GXWAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Geometrics2TBL_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void geometrics_qc(GXWAPtr param1, const gx_string_type& param2, GXVVPtr param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GeometricsQC_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }

                static void geonics3138_dump2_db(GXDBPtr param1, GXRAPtr param2, GXRAPtr param3, GXWAPtr param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Geonics3138Dump2DB_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6);
                    gx_->throw_on_error();
                }

                static void geonics61_dump2_db(GXDBPtr param1, GXRAPtr param2, GXWAPtr param3, double param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Geonics61Dump2DB_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5);
                    gx_->throw_on_error();
                }

                static void geonics_dat2_db(GXDBPtr param1, GXRAPtr param2, GXWAPtr param3, double param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GeonicsDAT2DB_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5);
                    gx_->throw_on_error();
                }

                static void gr_curv_cor(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GrCurvCor_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void gr_curv_cor_ex(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GrCurvCorEx_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4);
                    gx_->throw_on_error();
                }

                static void gr_demvv(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GrDEMVV_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void gr_test(double param1, double param2, double param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GrTest_GU(
                        gx_->pGeo, &param1, &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }

                static void gravity_still_reading_correction(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, const gx_string_type& param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GravityStillReadingCorrection_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static int32_t em_layer(double param1, double param2, double param3, EMLAY_GEOMETRY param4, int32_t param5, GXVVPtr param6, GXVVPtr param7, double& param8, double& param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iEMLayer_GU(
                                      gx_->pGeo, &param1, &param2, &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), &param8, &param9);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t em_plate(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, EMPLATE_DOMAIN param10, GXVVPtr param11, EMPLATE_TX param12, double param13, double param14, double param15, GXVVPtr param16, GXVVPtr param17, GXVVPtr param18, GXVVPtr param19, GXVVPtr param20, GXVVPtr param21)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iEMPlate_GU(
                                      gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&param12), &param13, &param14, &param15, reinterpret_cast<const long*>(&gx_->handle(param16)), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), reinterpret_cast<const long*>(&gx_->handle(param20)), reinterpret_cast<const long*>(&gx_->handle(param21)));
                    gx_->throw_on_error();
                    return ret;
                }

                static void gen_ux_detect_symbols_group_name(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_GROUP * STRING_CHAR_SIZE;
                    param3.resize(STR_GROUP);
                    IGenUXDetectSymbolsGroupName_GU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                static void import_daarc500_ethernet(const gx_string_type& param1, const gx_string_type& param2, int32_t& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDAARC500Ethernet_GU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }

                static void import_daarc500_serial(const gx_string_type& param1, int32_t param2, const gx_string_type& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDAARC500Serial_GU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }

                static void import_p190(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXWAPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportP190_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void lag_daarc500_gps(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LagDAARC500GPS_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void maxwell_plate_corners(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double& param9, double& param10, double& param11, double& param12, double& param13, double& param14, double& param15, double& param16, double& param17, double& param18, double& param19, double& param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MaxwellPlateCorners_GU(
                        gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, &param19, &param20);
                    gx_->throw_on_error();
                }

                static void scan_daarc500_ethernet(const gx_string_type& param1, int32_t& param2, int32_t& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanDAARC500Ethernet_GU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }

                static void scan_daarc500_serial(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanDAARC500Serial_GU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void vv_euler(GXVVPtr param1, GXVVPtr param2, GXIMGPtr param3, GXIMGPtr param4, GXIMGPtr param5, GXIMGPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, int32_t param13, double param14, double param15, PEAKEULER_XY param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    VVEuler_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&param13), &param14, &param15, reinterpret_cast<const long*>(&param16));
                    gx_->throw_on_error();
                }

                static void vv_euler2(GXVVPtr param1, GXVVPtr param2, GXIMGPtr param3, GXIMGPtr param4, GXIMGPtr param5, GXIMGPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, GXVVPtr param13, double param14, double param15, PEAKEULER_XY param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    VVEuler2_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), &param14, &param15, reinterpret_cast<const long*>(&param16));
                    gx_->throw_on_error();
                }


            };
            class GXGUI
            {
            private:
                GXGUI();
                ~GXGUI();
            public:


                static int32_t create_wnd_from_hwnd(HWND param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CreateWNDFromHWND_GUI(
                                      gx_->pGeo, param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static void fft2_spec_filter(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_Fft2SpecFilter_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static int32_t get_parent_wnd()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_GetParentWND_GUI(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_printer_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_GetPrinterLST_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static WINDOW_STATE get_window_state()
                {
                    GXContextPtr gx_ = GXContext::current();
                    WINDOW_STATE ret = (WINDOW_STATE)App_iGetWindowState_GUI(
                                           gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static void set_window_state(WINDOW_STATE param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetWindowState_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void get_window_position(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, WINDOW_STATE& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_GetWindowPosition_GUI(
                        gx_->pGeo, reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                }

                static void set_window_position(int32_t param1, int32_t param2, int32_t param3, int32_t param4, WINDOW_STATE param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetWindowPosition_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void get_client_window_area(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_GetClientWindowArea_GUI(
                        gx_->pGeo, reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }

                static void grid_stat_hist(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_GridStatHist_GUI(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void voxel_stat_hist(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_VoxelStatHist_GUI(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static int32_t color_form(int32_t& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iColorForm_GUI(
                                      gx_->pGeo, reinterpret_cast<long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t color_transform(GXITRPtr param1, GXSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iColorTransform_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t coord_sys_wizard(GXIPJPtr param1, int32_t param2, COORDSYS_MODE param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iCoordSysWizard_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t coord_sys_wizard_licensed(GXIPJPtr param1, int32_t param2, COORDSYS_MODE param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iCoordSysWizardLicensed_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t coord_sys_wizard_grid(GXIPJPtr param1, GXIPJPtr param2, int32_t param3, COORDSYS_MODE param4, const gx_string_type& param5, const gx_string_type& param6, int32_t param7, int32_t param8, double& param9, double& param10, double& param11, double& param12, double& param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iCoordSysWizardGrid_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), &param9, &param10, &param11, &param12, &param13);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t database_type(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    int32_t ret = App_iDatabaseType_GUI(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }

                static int32_t datamine_type(const gx_string_type& param1, int32_t& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iDatamineType_GUI(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t export_xyz_template_editor(GXDBPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iExportXYZTemplateEditor_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t export_xyz_template_editor_ex(GXEDBPtr param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    int32_t ret = App_iExportXYZTemplateEditorEx_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }

                static FILE_FILTER file_filter_index(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FILE_FILTER ret = (FILE_FILTER)iFileFilterIndex_GUI(
                                          gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t gcs_datum_warning_shp(const gx_string_type& param1, GXIPJPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGCSDatumWarningSHP_GUI(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t gcs_datum_warning_shpdb_ex(GXLSTPtr param1, GXLSTPtr param2, GXLSTPtr param3, GXDBPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGCSDatumWarningSHPDBEx_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t gcs_datum_warning_shp_ex(GXLSTPtr param1, GXLSTPtr param2, GXLSTPtr param3, GXMVIEWPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGCSDatumWarningSHPEx_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }

                static AOI_RETURN_STATE get_area_of_interest(double& param1, double& param2, double& param3, double& param4, GXPLYPtr param5, GXIPJPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AOI_RETURN_STATE ret = (AOI_RETURN_STATE)App_iGetAreaOfInterest_GUI(
                                               gx_->pGeo, &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                    return ret;
                }

                static AOI_RETURN_STATE get_area_of_interest_3d(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, GXPLYPtr param7, GXIPJPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AOI_RETURN_STATE ret = (AOI_RETURN_STATE)App_iGetAreaOfInterest3D_GUI(
                                               gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_dat_defaults(DAT_TYPE param1, FILE_FORM param2, gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    param4.resize(STR_FILE);
                    IGetDATDefaults_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }

                static void get_file_filter(FILE_FILTER param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, GS_DIRECTORY& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_SHORT);
                    param3.resize(STR_DEFAULT_SHORT);
                    param4.resize(STR_DEFAULT_SHORT);
                    IGetFileFilter_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize6 ), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }

                static void get_gs_directory(GS_DIRECTORY param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetGSDirectory_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static int32_t browse_dir(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_IiBrowseDir_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t color_transform_ex(GXITRPtr param1, GXSTPtr param2, int32_t param3, int32_t param4, gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param5.resize(STR_FILE);
                    int32_t ret = App_IiColorTransformEx_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param5.resize(gx_string_len(param5.c_str()));
                    return ret;
                }

                static int32_t cumulative_percent(gx_string_type& param1, GXITRPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    int32_t ret = App_IiCumulativePercent_GUI(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }

                static int32_t dat_file_form(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, DAT_TYPE param4, FILE_FORM param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_MULTI_FILE);
                    int32_t ret = App_IiDatFileForm_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t gen_file_form(const gx_string_type& param1, GXVVPtr param2, FILE_FILTER param3, const gx_string_type& param4, gx_string_type& param5, FILE_FORM param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize5 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param5.resize(STR_MULTI_FILE);
                    int32_t ret = App_IiGenFileForm_GUI(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str(), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    param5.resize(gx_string_len(param5.c_str()));
                    return ret;
                }

                static int32_t import_drill_database_ado2(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, DH_DATA& param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    int32_t ret = App_IiImportDrillDatabaseADO2_GUI(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t import_drill_database_esri(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, DH_DATA& param4, bool param5, GXREGPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    long paramBool5 = param5 ? 1 : 0;
                    int32_t ret = App_IiImportDrillDatabaseESRI_GUI(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<long*>(&param4), &paramBool5, reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t import_drill_database_odbc(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, DH_DATA& param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    int32_t ret = App_IiImportDrillDatabaseODBC_GUI(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t import_drill_database_odbc_maxwell(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, DH_DATA& param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    int32_t ret = App_IiImportDrillDatabaseODBCMaxwell_GUI(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t import_ascii_wizard(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iImportAsciiWizard_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t import_chem_database(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, IMPCH_TYPE param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iImportChemDatabase_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t import_chem_database_ado(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, IMPCH_TYPE param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iImportChemDatabaseADO_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t import_database(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iImportDatabase_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t import_database_ado(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iImportDatabaseADO_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t import_database_sql(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    int32_t ret = App_iImportDatabaseSQL_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }

                static int32_t import_database_sqlado(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    int32_t ret = App_iImportDatabaseSQLADO_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }

                static int32_t import_drill_database_ado(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, DH_DATA& param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iImportDrillDatabaseADO_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t import_template_sql(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iImportTemplateSQL_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t import_template_sqlado(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iImportTemplateSQLADO_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t import_xyz_template_editor(GXDBPtr param1, const gx_string_type& param2, int32_t param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iImportXYZTemplateEditor_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t odbc_file_connect(const gx_string_type& param1, gx_string_type& param2, int32_t param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    param4.resize(STR_FILE);
                    int32_t ret = App_IiODBCFileConnect_GUI(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }

                static int32_t symbol_form(gx_string_type& param1, bool& param2, MVIEW_FONT_WEIGHT& param3, int32_t& param4, double& param5, double& param6, int32_t& param7, int32_t& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    long paramBool2 = param2 ? 1 : 0;
                    int32_t ret = App_IiSymbolForm_GUI(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), &paramBool2, reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), &param5, &param6, reinterpret_cast<long*>(&param7), reinterpret_cast<long*>(&param8));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2 = paramBool2 != 0 ? true : false;
                    return ret;
                }

                static int32_t meta_data_tool(GXMETAPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iMetaDataTool_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static void import_chem_wizard(const gx_string_type& param1, const gx_string_type& param2, IMPCH_TYPE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ImportChemWizard_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void import_drill_wizard(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, DH_DATA& param5, GXREGPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ImportDrillWizard_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void internet_trust()
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_InternetTrust_GUI(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static int32_t pattern_form(int32_t& param1, double& param2, int32_t& param3, double& param4, int32_t& param5, int32_t& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iPatternForm_GUI(
                                      gx_->pGeo, reinterpret_cast<long*>(&param1), &param2, reinterpret_cast<long*>(&param3), &param4, reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t line_pattern_form(int32_t& param1, double& param2, double& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iLinePatternForm_GUI(
                                      gx_->pGeo, reinterpret_cast<long*>(&param1), &param2, &param3, reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t two_panel_selection(GXLSTPtr param1, GXLSTPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iTwoPanelSelection_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t two_panel_selection2(GXLSTPtr param1, GXLSTPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iTwoPanelSelection2_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t two_panel_selection_ex(GXLSTPtr param1, GXLSTPtr param2, int32_t param3, int32_t param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iTwoPanelSelectionEx_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t two_panel_selection_ex2(GXLSTPtr param1, GXLSTPtr param2, int32_t param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iTwoPanelSelectionEx2_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void launch_single_geo_dotnetx_tool(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchSingleGeoDOTNETXTool_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void launch_geo_dotnetx_tool(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchGeoDOTNETXTool_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void launch_geo_x_tool(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchGeoXTool_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void launch_single_geo_dotnetx_tool_ex(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3, XTOOL_ALIGN param4, XTOOL_DOCK param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchSingleGeoDOTNETXToolEx_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void launch_geo_dotnetx_tool_ex(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3, XTOOL_ALIGN param4, XTOOL_DOCK param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchGeoDOTNETXToolEx_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void launch_geo_x_tool_ex(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3, XTOOL_ALIGN param4, XTOOL_DOCK param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchGeoXToolEx_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void meta_data_viewer(GXMETAPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_MetaDataViewer_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void print_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_PrintFile_GUI(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void render_pattern(HDC param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, int32_t param8, double param9, int32_t param10, int32_t param11, int32_t param12, int32_t param13, int32_t param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_RenderPattern_GUI(
                        gx_->pGeo, param1, reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14));
                    gx_->throw_on_error();
                }

                static void render_line_pattern(HDC param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8, int32_t param9, int32_t param10, int32_t param11, int32_t param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_RenderLinePattern_GUI(
                        gx_->pGeo, param1, reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }

                static void set_parent_wnd(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetParentWND_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void set_printer(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetPrinter_GUI(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void set_prog_always_on(bool param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool1 = param1 ? 1 : 0;
                    App_SetProgAlwaysOn_GUI(
                        gx_->pGeo, &paramBool1);
                    gx_->throw_on_error();
                }

                static void show_direct_hist(double param1, double param2, double param3, double param4, double param5, int32_t param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ShowDirectHist_GUI(
                        gx_->pGeo, &param1, &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void show_hist(GXSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ShowHist_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void simple_map_dialog(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SimpleMapDialog_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void thematic_voxel_info(GXVOXPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ThematicVoxelInfo_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void show_3d_viewer_dialog(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_Show3DViewerDialog_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXHTTP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXHTTP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXHTTPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXHTTP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXHTTPPtr create(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_HTTP(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHTTP>(ret);
                }

                ~GXHTTP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void download(const gx_string_type& param1, GXBFPtr param2, int32_t param3)
                {
                    Download_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void silent_download(const gx_string_type& param1, GXBFPtr param2, int32_t param3)
                {
                    SilentDownload_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void get(const gx_string_type& param1, const gx_string_type& param2, GXBFPtr param3, GXBFPtr param4)
                {
                    Get_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void post(const gx_string_type& param1, const gx_string_type& param2, GXBFPtr param3)
                {
                    Post_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void set_proxy_credentials(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SetProxyCredentials_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXIEXP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXIEXP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXIEXPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXIEXP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_grid(GXIMGPtr param1, const gx_string_type& param2)
                {
                    AddGrid_IEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static GXIEXPPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_IEXP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIEXP>(ret);
                }

                ~GXIEXP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_IEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void do_formula(const gx_string_type& param1, int32_t param2)
                {
                    DoFormula_IEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }


            };
            class GXIGRF
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXIGRF(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXIGRFPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXIGRF>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void calc(double param1, double param2, double param3, double& param4, double& param5, double& param6)
                {
                    Calc_IGRF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void calc_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    CalcVV_IGRF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static GXIGRFPtr create(double param1, int32_t param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_IGRF(
                                      gx_->pGeo, &param1, reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIGRF>(ret);
                }

                static void date_range(const gx_string_type& param1, double& param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DateRange_IGRF(
                        gx_->pGeo, param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                }

                ~GXIGRF()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_IGRF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }


            };
            class GXINTERNET
            {
            private:
                GXINTERNET();
                ~GXINTERNET();
            public:


                static int32_t download_http(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDownloadHTTP_INTERNET(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static void send_mail(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SendMail_INTERNET(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXIP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXIP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXIPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXIP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static void convert_ubcip2_d_to_grid(const gx_string_type& param1, GXPGPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertUBCIP2DToGrid_IP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                void create_default_job(const gx_string_type& param1, IP_PLOT param2)
                {
                    CreateDefaultJob_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void export_ubcip3(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, double param7)
                {
                    ExportUBCIP3_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), &param7);
                    gx_->throw_on_error();
                }

                static void export_ubcip_control(const gx_string_type& param1, int32_t param2, int32_t param3, double param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11, const gx_string_type& param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportUBCIPControl_IP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4, param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str(), param12.c_str());
                    gx_->throw_on_error();
                }

                static void export_ubcip_control_v5(const gx_string_type& param1, int32_t param2, double param3, const gx_string_type& param4, const gx_string_type& param5, IP_UBC_CONTROL param6, const gx_string_type& param7, IP_UBC_CONTROL param8, const gx_string_type& param9, IP_UBC_CONTROL param10, const gx_string_type& param11, IP_UBC_CONTROL param12, const gx_string_type& param13, IP_UBC_CONTROL param14, const gx_string_type& param15, const gx_string_type& param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportUBCIPControlV5_IP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), &param3, param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), param7.c_str(), reinterpret_cast<const long*>(&param8), param9.c_str(), reinterpret_cast<const long*>(&param10), param11.c_str(), reinterpret_cast<const long*>(&param12), param13.c_str(), reinterpret_cast<const long*>(&param14), param15.c_str(), param16.c_str());
                    gx_->throw_on_error();
                }

                void export_ubc_res3(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, double param8)
                {
                    ExportUBCRes3_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), &param8);
                    gx_->throw_on_error();
                }

                static void export_ubc_res_control(const gx_string_type& param1, int32_t param2, int32_t param3, double param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, double param9, const gx_string_type& param10, const gx_string_type& param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportUBCResControl_IP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4, param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), &param9, param10.c_str(), param11.c_str());
                    gx_->throw_on_error();
                }

                static void export_ubc_res_control_v5(const gx_string_type& param1, int32_t param2, double param3, const gx_string_type& param4, const gx_string_type& param5, IP_UBC_CONTROL param6, const gx_string_type& param7, IP_UBC_CONTROL param8, const gx_string_type& param9, IP_UBC_CONTROL param10, const gx_string_type& param11, IP_UBC_CONTROL param12, const gx_string_type& param13, const gx_string_type& param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportUBCResControlV5_IP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), &param3, param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), param7.c_str(), reinterpret_cast<const long*>(&param8), param9.c_str(), reinterpret_cast<const long*>(&param10), param11.c_str(), reinterpret_cast<const long*>(&param12), param13.c_str(), param14.c_str());
                    gx_->throw_on_error();
                }

                void export_data_to_ubc_3d(GXDBPtr param1, GXLSTPtr param2, int32_t param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, int32_t param8, const gx_string_type& param9, const gx_string_type& param10)
                {
                    ExportDataToUBC3D_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), param7.c_str(), reinterpret_cast<const long*>(&param8), param9.c_str(), param10.c_str());
                    gx_->throw_on_error();
                }

                static GXPGPtr import_ubc2_dmod(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ImportUBC2DMOD_IP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }

                static void import_ubc2_dmsh(const gx_string_type& param1, double& param2, double& param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportUBC2DMSH_IP(
                        gx_->pGeo, param1.c_str(), &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void import_ubc2_d_topo(const gx_string_type& param1, double& param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportUBC2DTopo_IP(
                        gx_->pGeo, param1.c_str(), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void open_job(const gx_string_type& param1, IP_PLOT param2)
                {
                    OpenJob_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void save_job(const gx_string_type& param1, IP_PLOT param2)
                {
                    SaveJob_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static GXPGPtr trim_ubc2_d_model(GXPGPtr param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5, GXVVPtr param6, double& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = TrimUBC2DModel_IP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), &param7);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }

                void write_distant_electrodes(GXDBPtr param1)
                {
                    WriteDistantElectrodes_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void write_distant_electrodes_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    WriteDistantElectrodesLST_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void average_duplicates_qc(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, IP_DUPLICATE param4)
                {
                    AverageDuplicatesQC_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static GXIPPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_IP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIP>(ret);
                }

                ~GXIP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void export_i2_x(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11)
                {
                    ExportI2X_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str());
                    gx_->throw_on_error();
                }

                void export_ipdata(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ExportIPDATA_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void export_ipdata_dir(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    ExportIPDATADir_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                void export_ipred(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, IP_FILTER param5, const gx_string_type& param6, double param7, double param8, int32_t param9)
                {
                    ExportIPRED_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), param6.c_str(), &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                void export_ipred_dir(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, IP_FILTER param5, const gx_string_type& param6, double param7, double param8, int32_t param9, const gx_string_type& param10)
                {
                    ExportIPREDDir_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), param6.c_str(), &param7, &param8, reinterpret_cast<const long*>(&param9), param10.c_str());
                    gx_->throw_on_error();
                }

                void export_line_ipdata(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    ExportLineIPDATA_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                void export_sgdf(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    ExportSGDF_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                void get_n_value_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    GetNValueLST_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_topo_line(GXDBPtr param1, const gx_string_type& param2, double param3, double param4, double param5, GXVVPtr param6)
                {
                    GetTopoLine_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                IP_DOMAIN get_chan_domain(GXDBPtr param1, const gx_string_type& param2)
                {
                    IP_DOMAIN ret = (IP_DOMAIN)iGetChanDomain_IP(
                                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_chan_label(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    param3.resize(STR_DEFAULT);
                    IGetChanLabel_IP(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }

                void get_channel_info(GXDBPtr param1, const gx_string_type& param2, IP_DOMAIN& param3, double& param4, int32_t& param5, GXVVPtr param6)
                {
                    GetChannelInfo_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<long*>(&param3), &param4, reinterpret_cast<long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                void set_channel_info(GXDBPtr param1, const gx_string_type& param2, IP_DOMAIN param3, double param4, int32_t param5, GXVVPtr param6)
                {
                    SetChannelInfo_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                void import_dump(IP_SYS param1, GXDBPtr param2, const gx_string_type& param3)
                {
                    ImportDump_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }

                void import_grid(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ImportGrid_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void import_i2_x(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11, IP_I2XIMPMODE param12)
                {
                    ImportI2X_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str(), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }

                void import_i2_x_ex(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11, const gx_string_type& param12, const gx_string_type& param13, IP_I2XIMPMODE param14)
                {
                    ImportI2XEx_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str(), param12.c_str(), param13.c_str(), reinterpret_cast<const long*>(&param14));
                    gx_->throw_on_error();
                }

                void import_instrumentation_gdd(GXDBPtr param1, const gx_string_type& param2)
                {
                    ImportInstrumentationGDD_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void import_ipdata(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ImportIPDATA_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void import_ipdata2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    ImportIPDATA2_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                void import_ipred(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ImportIPRED_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void import_merge_ipred(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ImportMergeIPRED_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void import_sgdf(GXDBPtr param1, const gx_string_type& param2)
                {
                    ImportSGDF_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void import_topo_csv(GXDBPtr param1, const gx_string_type& param2)
                {
                    ImportTopoCSV_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void import_topo_grid(GXDBPtr param1, const gx_string_type& param2)
                {
                    ImportTopoGrid_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void import_zonge_avg(GXDBPtr param1, const gx_string_type& param2, double param3, IP_STNSCALE param4, double param5)
                {
                    ImportZongeAVG_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4), &param5);
                    gx_->throw_on_error();
                }

                void import_zonge_fld(GXDBPtr param1, const gx_string_type& param2, IP_STNSCALE param3, double param4)
                {
                    ImportZongeFLD_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }

                void new_xy_database(GXDBPtr param1, GXDBPtr param2, GXVVPtr param3, const gx_string_type& param4, double param5)
                {
                    NewXYDatabase_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), &param5);
                    gx_->throw_on_error();
                }

                void pseudo_plot(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    PseudoPlot_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                void pseudo_plot2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    PseudoPlot2_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }

                void pseudo_plot2_dir(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    PseudoPlot2Dir_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }

                void ps_stack(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    PSStack_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                void ps_stack2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, IP_STACK_TYPE param4, const gx_string_type& param5)
                {
                    PSStack2_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                }

                void ps_stack2_dir(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, IP_STACK_TYPE param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    PSStack2Dir_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }

                void qc_chan_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    QCChanLST_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void recalculate(GXDBPtr param1)
                {
                    Recalculate_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void recalculate_ex(GXDBPtr param1, int32_t param2)
                {
                    RecalculateEx_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void recalculate_z(GXDBPtr param1)
                {
                    RecalculateZ_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_import_mode(int32_t param1)
                {
                    SetImportMode_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void window(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    Window_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                static void winnow_chan_list(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    WinnowChanList_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void winnow_chan_list2(GXLSTPtr param1, GXDBPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    WinnowChanList2_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                int32_t is_valid_line(GXDBPtr param1, const gx_string_type& param2)
                {
                    int32_t ret = isValidLine_IP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                IP_ARRAY line_array_type(GXDBPtr param1, const gx_string_type& param2)
                {
                    IP_ARRAY ret = (IP_ARRAY)iLineArrayType_IP(
                                       gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                double a_spacing(GXDBPtr param1, const gx_string_type& param2)
                {
                    double ret = rASpacing_IP(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                IP_PLDP_CONV pldp_convention()
                {
                    IP_PLDP_CONV ret = (IP_PLDP_CONV)iPLDPConvention_IP(
                                           gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_electrode_locations_and_mask_values(GXDBPtr param1, const gx_string_type& param2, int32_t param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7)
                {
                    GetElectrodeLocationsAndMaskValues_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                void set_electrode_mask_values(GXDBPtr param1, const gx_string_type& param2, int32_t param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7)
                {
                    SetElectrodeMaskValues_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }


            };
            class GXIPGUI
            {
            private:
                GXIPGUI();
                ~GXIPGUI();
            public:


                static int32_t modify_job(GXIPPtr param1, GXDBPtr param2, const gx_string_type& param3, IP_PLOT param4, int32_t& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iModifyJob_IPGUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }

                static void launch_ipqc_tool(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchIPQCTool_IPGUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void launch_offset_ipqc_tool(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchOffsetIPQCTool_IPGUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static int32_t ipqc_tool_exists()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIPQCToolExists_IPGUI(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXKGRD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXKGRD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXKGRDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXKGRD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear()
                {
                    _Clear_KGRD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static GXKGRDPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_KGRD(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXKGRD>(ret);
                }

                ~GXKGRD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_KGRD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t load_parms(const gx_string_type& param1)
                {
                    int32_t ret = iLoadParms_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t run(const gx_string_type& param1, GXDATPtr param2, GXDATPtr param3, GXDATPtr param4, const gx_string_type& param5, const gx_string_type& param6, int32_t param7, int32_t param8, int32_t param9)
                {
                    int32_t ret = iRun_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), param6.c_str(), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t run2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRun2_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t run3(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, int32_t param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRun3_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t save_parms(const gx_string_type& param1)
                {
                    int32_t ret = iSaveParms_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXLMSG
            {
            private:
                GXLMSG();
                ~GXLMSG();
            public:


                static void goto_point(double param1, double param2, double param3, GXIPJPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GotoPoint_LMSG(
                        gx_->pGeo, &param1, &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void view_area(double param1, double param2, double param3, double param4, GXIPJPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ViewArea_LMSG(
                        gx_->pGeo, &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }


            };
            class GXMISC
            {
            private:
                GXMISC();
                ~GXMISC();
            public:


                static void convert_cg3to_raw(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertCG3toRAW_MISC(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void convert_cg5to_raw(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertCG5toRAW_MISC(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void ukoa2_tbl(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Ukoa2Tbl_MISC(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXMSTK
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMSTK(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMSTKPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMSTK>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                GXSTKPtr add_stk()
                {
                    int32_t ret = AddSTK_MSTK(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSTK>(ret);
                }

                void chan_list_vv(GXDBPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    ChanListVV_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static GXMSTKPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MSTK(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMSTK>(ret);
                }

                ~GXMSTK()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void draw_profile(GXDBPtr param1, int32_t param2, GXMAPPtr param3)
                {
                    DrawProfile_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void set_y_axis_direction(int32_t param1)
                {
                    SetYAxisDirection_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void find_stk2(const gx_string_type& param1, int32_t& param2, GXVVPtr param3)
                {
                    FindSTK2_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                GXSTKPtr get_stk(int32_t param1)
                {
                    int32_t ret = GetSTK_MSTK(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSTK>(ret);
                }

                void delete_stk(int32_t param1)
                {
                    IDelete_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void find_stk(const gx_string_type& param1, int32_t& param2, gx_string_type& param3, gx_string_type& param4, gx_string_type& param5)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    param4.resize(STR_VERY_LONG);
                    param5.resize(STR_VERY_LONG);
                    IFindSTK_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize6 ), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize8 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param5.resize(gx_string_len(param5.c_str()));
                }

                int32_t get_num_stk()
                {
                    int32_t ret = iGetNumSTK_MSTK(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void read_ini(GXRAPtr param1)
                {
                    ReadINI_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void save_profile(GXWAPtr param1)
                {
                    SaveProfile_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }


            };
            class GXMVG
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMVG(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMVGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMVG>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void axis_x(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    AxisX_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void axis_y(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    AxisY_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                static GXMVGPtr create(GXMAPPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MVG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVG>(ret);
                }

                ~GXMVG()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                GXMVIEWPtr get_mview()
                {
                    int32_t ret = GetMVIEW_MVG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }

                void grid(double param1, double param2, double param3, double param4, double param5, double param6, MVG_GRID param7)
                {
                    Grid_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                void label_x(double param1, double param2, double param3, double param4, MVG_LABEL_JUST param5, MVG_LABEL_BOUND param6, MVG_LABEL_ORIENT param7)
                {
                    LabelX_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                void label_y(double param1, double param2, double param3, double param4, MVG_LABEL_JUST param5, MVG_LABEL_BOUND param6, MVG_LABEL_ORIENT param7)
                {
                    LabelY_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                void poly_line_va(MVG_DRAW param1, MVG_WRAP param2, GXVVPtr param3, GXVAPtr param4, GXVVPtr param5)
                {
                    PolyLineVA_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                void poly_line_vv(MVG_DRAW param1, MVG_WRAP param2, GXVVPtr param3, GXVVPtr param4)
                {
                    PolyLineVV_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void rescale_x_range(MVG_SCALE param1, double param2, double param3, double param4)
                {
                    RescaleXRange_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void rescale_y_range(MVG_SCALE param1, double param2, double param3, double param4)
                {
                    RescaleYRange_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4);
                    gx_->throw_on_error();
                }


            };
            class GXPDF3D
            {
            private:
                GXPDF3D();
                ~GXPDF3D();
            public:


                static void render(GXMVIEWPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Render_PDF3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void render_to_page(GXMVIEWPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RenderToPage_PDF3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void export2_d(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Export2D_PDF3D(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }


            };
            class GXPGEXP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXPGEXP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXPGEXPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXPGEXP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_pager(GXPGPtr param1, const gx_string_type& param2)
                {
                    AddPager_PGEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static GXPGEXPPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_PGEXP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPGEXP>(ret);
                }

                ~GXPGEXP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_PGEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void do_formula(const gx_string_type& param1, int32_t param2)
                {
                    DoFormula_PGEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }


            };
            class GXPGU
            {
            private:
                GXPGU();
                ~GXPGU();
            public:


                static void bool_mask(GXPGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Bool_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void direct_gridding_dat(GXPGPtr param1, double param2, double param3, double param4, double param5, double param6, GXDATPtr param7, PGU_DIRECTGRID param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGriddingDAT_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void direct_gridding_dat_3d(GXPGPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, GXDATPtr param9, PGU_DIRECTGRID param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGriddingDAT3D_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

                static void direct_gridding_db(GXPGPtr param1, double param2, double param3, double param4, double param5, double param6, GXDBPtr param7, int32_t param8, int32_t param9, int32_t param10, PGU_DIRECTGRID param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGriddingDB_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }

                static void direct_gridding_db_3d(GXPGPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, GXDBPtr param9, int32_t param10, int32_t param11, int32_t param12, int32_t param13, PGU_DIRECTGRID param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGriddingDB3D_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14));
                    gx_->throw_on_error();
                }

                static void direct_gridding_vv(GXPGPtr param1, double param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, PGU_DIRECTGRID param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGriddingVV_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

                static void expand(GXPGPtr param1, GXPGPtr param2, double param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Expand_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void fill(GXPGPtr param1, int32_t param2, double param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8, int32_t param9, int32_t param10, const gx_string_type& param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Fill_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), param11.c_str());
                    gx_->throw_on_error();
                }

                static void fill_value(GXPGPtr param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FillValue_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }

                static void filt_sym(GXPGPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, int32_t param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FiltSym_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void filt_sym5(GXPGPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FiltSym5_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void grid_peak(const gx_string_type& param1, BLAKEY_TEST param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridPeak_PGU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void dw_gridding_dat(GXPGPtr param1, GXDATPtr param2, GXREGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGriddingDAT_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void dw_gridding_dat_3d(GXPGPtr param1, GXDATPtr param2, GXREGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGriddingDAT3D_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void dw_gridding_db(GXPGPtr param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, GXREGPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGriddingDB_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void dw_gridding_db_3d(GXPGPtr param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, GXREGPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGriddingDB3D_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void dw_gridding_vv(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGriddingVV_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void numeric_to_thematic(GXPGPtr param1, GXVVPtr param2, GXPGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NumericToThematic_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void peakedness(const gx_string_type& param1, int32_t param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Peakedness_PGU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void peakedness_grid(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PeakednessGrid_PGU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }

                static void ref_file(GXPGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RefFile_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void save_file(GXPGPtr param1, double param2, double param3, double param4, double param5, double param6, GXTRPtr param7, GXIPJPtr param8, const gx_string_type& param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SaveFile_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), param9.c_str());
                    gx_->throw_on_error();
                }

                static void thematic_to_numeric(GXPGPtr param1, GXVVPtr param2, GXPGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ThematicToNumeric_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void trend(GXPGPtr param1, GXPGPtr param2, GXTRPtr param3, int32_t param4, int32_t param5, double param6, double param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Trend_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                static void add_scalar(GXPGPtr param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AddScalar_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }

                static void multiply_scalar(GXPGPtr param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MultiplyScalar_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }

                static void correlation_matrix(GXPGPtr param1, GXPGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CorrelationMatrix_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void correlation_matrix2(GXPGPtr param1, PGU_CORR param2, GXPGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CorrelationMatrix2_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void invert_matrix(GXPGPtr param1, GXPGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    InvertMatrix_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void jacobi(GXPGPtr param1, GXVVPtr param2, GXPGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Jacobi_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void lu_back_sub(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LUBackSub_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void lu_decomp(GXPGPtr param1, GXPGPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LUDecomp_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void matrix_mult(GXPGPtr param1, int32_t param2, GXPGPtr param3, int32_t param4, GXPGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MatrixMult_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void matrix_vector_mult(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MatrixVectorMult_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void sv_decompose(GXPGPtr param1, GXPGPtr param2, GXVVPtr param3, GXPGPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SVDecompose_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void sv_recompose(GXPGPtr param1, GXVVPtr param2, GXPGPtr param3, double param4, GXPGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SVRecompose_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void pc_communality(GXPGPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCCommunality_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void pc_loadings(GXPGPtr param1, GXPGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCLoadings_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void pc_loadings2(GXPGPtr param1, GXPGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCLoadings2_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void pc_scores(GXPGPtr param1, GXPGPtr param2, GXPGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCScores_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void pc_standardize(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3, PGU_DIRECTION param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCStandardize_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void pc_standardize2(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCStandardize2_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void pc_transform(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, PGU_DIRECTION param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCTransform_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void pc_varimax(GXPGPtr param1, GXPGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCVarimax_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static double maximum_terrain_steepness(GXPGPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rMaximumTerrainSteepness_PGU(
                                     gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXPRAGA3
            {
            private:
                GXPRAGA3();
                ~GXPRAGA3();
            public:


                static int32_t launch()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iLaunch_PRAGA3(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXPROJ
            {
            private:
                GXPROJ();
                ~GXPROJ();
            public:


                static void drop_map_clip_data(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DropMapClipData_PROJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static int32_t add_document(const gx_string_type& param1, const gx_string_type& param2, PROJ_DISPLAY param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iAddDocument_PROJ(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t add_document_without_opening(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iAddDocumentWithoutOpening_PROJ(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static COMMAND_ENV get_command_environment()
                {
                    GXContextPtr gx_ = GXContext::current();
                    COMMAND_ENV ret = (COMMAND_ENV)App_iGetCommandEnvironment_PROJ(
                                          gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t list_documents(GXVVPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iListDocuments_PROJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t list_tools(GXLSTPtr param1, TOOL_TYPE param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iListTools_PROJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t remove_document(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iRemoveDocument_PROJ(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t remove_tool(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iRemoveTool_PROJ(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t save_close_documents(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iSaveCloseDocuments_PROJ(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_name(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    App_IGetName_PROJ(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }


            };
            class GXRGRD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXRGRD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXRGRDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXRGRD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear()
                {
                    _Clear_RGRD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static GXRGRDPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_RGRD(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXRGRD>(ret);
                }

                static GXIMGPtr create_img(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXIPJPtr param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateIMG_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }

                ~GXRGRD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_RGRD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t default(const gx_string_type& param1, GXDATPtr param2)
                {
                    int32_t ret = iDefault_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t load_parms(const gx_string_type& param1)
                {
                    int32_t ret = iLoadParms_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t run(GXDATPtr param1, GXDATPtr param2)
                {
                    int32_t ret = iRun_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t run2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRun2_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t save_parms(const gx_string_type& param1)
                {
                    int32_t ret = iSaveParms_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void run_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXIPJPtr param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RunVV_RGRD(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXSEMPLOT
            {
            private:
                GXSEMPLOT();
                ~GXSEMPLOT();
            public:


                static void apply_filter_to_mask(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ApplyFilterToMask_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void convert_dummies(GXDBPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertDummies_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void create_groups(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateGroups_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void default_groups(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DefaultGroups_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void edit_map_plot_parameters(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXMAPPtr param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EditMapPlotParameters_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str());
                    gx_->throw_on_error();
                }

                static void edit_plot_components(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EditPlotComponents_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void edit_plot_parameters(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EditPlotParameters_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void export_overlay(const gx_string_type& param1, const gx_string_type& param2, GXMVIEWPtr param3, const gx_string_type& param4, SEMPLOT_PLOT param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11, SEMPLOT_EXT param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportOverlay_SEMPLOT(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), reinterpret_cast<const long*>(&param5), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str(), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }

                static void export_view(GXDBPtr param1, GXLSTPtr param2, GXDBPtr param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportView_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), param7.c_str());
                    gx_->throw_on_error();
                }

                static void export_view2(GXDBPtr param1, GXLSTPtr param2, GXDBPtr param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, SEMPLOT_EXPORT param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportView2_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), param7.c_str(), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void filter_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FilterLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void filter_mineral_pos_data(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FilterMineralPosData_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void get_associated_lst(GXDBPtr param1, int32_t param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetAssociatedLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void get_current_mineral_lst(GXDBPtr param1, const gx_string_type& param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetCurrentMineralLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void get_current_position_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetCurrentPositionLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void get_full_mineral_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetFullMineralLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void get_full_position_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetFullPositionLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void get_grouping_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetGroupingLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static int32_t create_ascii_template(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCreateASCIITemplate_SEMPLOT(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t create_database_template(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCreateDatabaseTemplate_SEMPLOT(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t edit_filter(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iEditFilter_SEMPLOT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_mineral_channel_name(GXDBPtr param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    IGetMineralChannelName_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void import_ascii_wizard(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param3.resize(STR_DB_SYMBOL);
                    IImportAsciiWizard_SEMPLOT(
                        gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                static void import_database_odbc(gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    param2.resize(STR_FILE);
                    IImportDatabaseODBC_SEMPLOT(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void import_bin(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportBIN_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), &param6);
                    gx_->throw_on_error();
                }

                static void import_database_ado(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDatabaseADO_SEMPLOT(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void init_group_symbols_used(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    InitGroupSymbolsUsed_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static int32_t template_type(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTemplateType_SEMPLOT(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static SEMPLOT_PLOT view_type(GXMAPPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SEMPLOT_PLOT ret = (SEMPLOT_PLOT)iViewType_SEMPLOT(
                                           gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void mineral_id(GXDBPtr param1, double param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MineralID_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void new_filter(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NewFilter_SEMPLOT(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void new_template(const gx_string_type& param1, int32_t param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NewTemplate_SEMPLOT(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                static void overlay_lst(GXLSTPtr param1, SEMPLOT_EXT param2, SEMPLOT_PLOT param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OverlayLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void plot(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Plot_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void plot_symbol_legend(GXDBPtr param1, GXMVIEWPtr param2, double param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PlotSymbolLegend_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                static void prop_symb(GXDBPtr param1, GXMAPPtr param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, int32_t param7, int32_t param8, double param9, double param10, int32_t param11, int32_t param12, int32_t param13, int32_t param14, int32_t param15)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PropSymb_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14), reinterpret_cast<const long*>(&param15));
                    gx_->throw_on_error();
                }

                static void replot(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXMAPPtr param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Replot_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str());
                    gx_->throw_on_error();
                }

                static void re_plot_symbol_legend(GXDBPtr param1, GXMVIEWPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RePlotSymbolLegend_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void reset_groups(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ResetGroups_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void reset_used_channel(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ResetUsedChannel_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void select_poly(GXDBPtr param1, GXMVIEWPtr param2, const gx_string_type& param3, const gx_string_type& param4, GXPLYPtr param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SelectPoly_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void set_channel_order(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetChannelOrder_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void set_channel_units(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetChannelUnits_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void set_itr(GXDBPtr param1, int32_t param2, GXITRPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetITR_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void set_mask(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetMask_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void sort_data(GXDBPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SortData_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void template_lst(GXLSTPtr param1, SEMPLOT_PLOT param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TemplateLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void tile_windows()
                {
                    GXContextPtr gx_ = GXContext::current();
                    TileWindows_SEMPLOT(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void total_oxides(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TotalOxides_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXSHP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSHP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSHPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSHP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void append_item()
                {
                    AppendItem_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static GXSHPPtr create(const gx_string_type& param1, SHP_GEOM_TYPE param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_SHP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSHP>(ret);
                }

                ~GXSHP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t add_int_field(const gx_string_type& param1)
                {
                    int32_t ret = iAddIntField_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t add_double_field(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = iAddRealField_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t add_string_field(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = iAddStringField_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_field(const gx_string_type& param1)
                {
                    int32_t ret = iFindField_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t max_id_num()
                {
                    int32_t ret = iMaxIDNum_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t num_fields()
                {
                    int32_t ret = iNumFields_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t num_records()
                {
                    int32_t ret = iNumRecords_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                SHP_GEOM_TYPE type()
                {
                    SHP_GEOM_TYPE ret = (SHP_GEOM_TYPE)iType_SHP(
                                            gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static GXSHPPtr open(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_SHP(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSHP>(ret);
                }

                void set_arc(GXVVPtr param1, GXVVPtr param2)
                {
                    SetArc_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void set_arc_z(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    SetArcZ_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void set_int(int32_t param1, int32_t param2)
                {
                    SetInt_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_point(double param1, double param2)
                {
                    SetPoint_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void set_point_z(double param1, double param2, double param3)
                {
                    SetPointZ_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                void set_polygon(GXVVPtr param1, GXVVPtr param2, bool param3)
                {
                    long paramBool3 = param3 ? 1 : 0;
                    SetPolygon_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &paramBool3);
                    gx_->throw_on_error();
                }

                void set_polygon_z(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, bool param4)
                {
                    long paramBool4 = param4 ? 1 : 0;
                    SetPolygonZ_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &paramBool4);
                    gx_->throw_on_error();
                }

                void set_double(int32_t param1, double param2)
                {
                    SetReal_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void set_string(int32_t param1, const gx_string_type& param2)
                {
                    SetString_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void write_item()
                {
                    WriteItem_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }


            };
            class GXSQLSRV
            {
            private:
                GXSQLSRV();
                ~GXSQLSRV();
            public:


                static int32_t attach_mdf(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iAttachMDF_SQLSRV(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t detach_db(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDetachDB_SQLSRV(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t get_database_languages_lst(GXLSTPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetDatabaseLanguagesLST_SQLSRV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t get_databases_lst(GXLSTPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetDatabasesLST_SQLSRV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_login_gui(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, MFCSQL_DRIVER param4, int32_t& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    param3.resize(STR_DEFAULT);
                    IGetLoginGUI_SQLSRV(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<const long*>(&param4), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }

                static int32_t get_servers_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetServersLST_SQLSRV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXSTK
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSTK(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSTKPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSTK>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void get_trans_parms(int32_t& param1, double& param2, GXVVPtr param3, GXVVPtr param4, int32_t& param5, double& param6, GXVVPtr param7, GXVVPtr param8)
                {
                    GetTransParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<long*>(&param5), &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }

                DB_CHAN_FORMAT get_axis_format(STK_AXIS param1)
                {
                    DB_CHAN_FORMAT ret = (DB_CHAN_FORMAT)iGetAxisFormat_STK(
                                             gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_axis_parms(int32_t& param1, double& param2, double& param3, double& param4, gx_string_type& param5, double& param6, double& param7, double& param8, int32_t& param9, STK_AXIS param10)
                {
                    int32_t paramSize6 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param5.resize(STR_DEFAULT_SHORT);
                    IGetAxisParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, &param4, (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize6 ), &param6, &param7, &param8, reinterpret_cast<long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                    param5.resize(gx_string_len(param5.c_str()));
                }

                void get_fid_parms(double& param1, double& param2, double& param3, gx_string_type& param4, double& param5, gx_string_type& param6)
                {
                    int32_t paramSize5 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_SHORT);
                    param6.resize(STR_DEFAULT_SHORT);
                    IGetFidParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ), &param5, (gx_string_char_type*)param6.data(), reinterpret_cast<const long*>(&paramSize8 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    param6.resize(gx_string_len(param6.c_str()));
                }

                int32_t get_flag(STK_FLAG param1)
                {
                    int32_t ret = iGetFlag_STK(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_gen_parms(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11)
                {
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_GROUP * STRING_CHAR_SIZE;
                    param1.resize(STR_DB_SYMBOL);
                    param2.resize(STR_DB_SYMBOL);
                    param3.resize(STR_GROUP);
                    IGetGenParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize6 ), &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11);
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }

                void get_grid_parms(int32_t& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, gx_string_type& param10, STK_GRID param11)
                {
                    int32_t paramSize11 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param10.resize(STR_DEFAULT_SHORT);
                    IGetGridParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, (gx_string_char_type*)param10.data(), reinterpret_cast<const long*>(&paramSize11 ), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                    param10.resize(gx_string_len(param10.c_str()));
                }

                void get_label_parms(int32_t& param1, double& param2, int32_t& param3, double& param4, int32_t& param5, double& param6, gx_string_type& param7, double& param8, gx_string_type& param9, int32_t& param10, STK_AXIS param11)
                {
                    int32_t paramSize8 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize11 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param7.resize(STR_DEFAULT_SHORT);
                    param9.resize(STR_DEFAULT_SHORT);
                    IGetLabelParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, reinterpret_cast<long*>(&param3), &param4, reinterpret_cast<long*>(&param5), &param6, (gx_string_char_type*)param7.data(), reinterpret_cast<const long*>(&paramSize8 ), &param8, (gx_string_char_type*)param9.data(), reinterpret_cast<const long*>(&paramSize11 ), reinterpret_cast<long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                    param7.resize(gx_string_len(param7.c_str()));
                    param9.resize(gx_string_len(param9.c_str()));
                }

                void get_profile(int32_t& param1, double& param2, double& param3, gx_string_type& param4, int32_t& param5, int32_t& param6, int32_t& param7, GXVVPtr param8, gx_string_type& param9, int32_t& param10, gx_string_type& param11, double& param12, gx_string_type& param13, int32_t& param14)
                {
                    int32_t paramSize5 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize11 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize14 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize17 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_SHORT);
                    param9.resize(STR_DEFAULT);
                    param11.resize(STR_DEFAULT_SHORT);
                    param13.resize(STR_DEFAULT_SHORT);
                    IGetProfile_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7), reinterpret_cast<const long*>(&gx_->handle(param8)), (gx_string_char_type*)param9.data(), reinterpret_cast<const long*>(&paramSize11 ), reinterpret_cast<long*>(&param10), (gx_string_char_type*)param11.data(), reinterpret_cast<const long*>(&paramSize14 ), &param12, (gx_string_char_type*)param13.data(), reinterpret_cast<const long*>(&paramSize17 ), reinterpret_cast<long*>(&param14));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    param9.resize(gx_string_len(param9.c_str()));
                    param11.resize(gx_string_len(param11.c_str()));
                    param13.resize(gx_string_len(param13.c_str()));
                }

                void get_profile_ex(int32_t& param1, double& param2, double& param3, gx_string_type& param4, int32_t& param5, int32_t& param6, int32_t& param7, int32_t& param8, GXVVPtr param9, gx_string_type& param10, int32_t& param11, gx_string_type& param12, double& param13, gx_string_type& param14, int32_t& param15)
                {
                    int32_t paramSize5 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize12 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize15 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize18 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_SHORT);
                    param10.resize(STR_DEFAULT);
                    param12.resize(STR_DEFAULT_SHORT);
                    param14.resize(STR_DEFAULT_SHORT);
                    IGetProfileEx_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7), reinterpret_cast<long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)), (gx_string_char_type*)param10.data(), reinterpret_cast<const long*>(&paramSize12 ), reinterpret_cast<long*>(&param11), (gx_string_char_type*)param12.data(), reinterpret_cast<const long*>(&paramSize15 ), &param13, (gx_string_char_type*)param14.data(), reinterpret_cast<const long*>(&paramSize18 ), reinterpret_cast<long*>(&param15));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    param10.resize(gx_string_len(param10.c_str()));
                    param12.resize(gx_string_len(param12.c_str()));
                    param14.resize(gx_string_len(param14.c_str()));
                }

                void get_symb_parms(gx_string_type& param1, double& param2, gx_string_type& param3, gx_string_type& param4, int32_t& param5, int32_t& param6, double& param7, int32_t& param8, GXVVPtr param9, GXVVPtr param10, int32_t& param11, gx_string_type& param12, double& param13, gx_string_type& param14)
                {
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize7 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize16 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize19 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    param3.resize(STR_DEFAULT_SHORT);
                    param4.resize(STR_DEFAULT_SHORT);
                    param12.resize(STR_DEFAULT_SHORT);
                    param14.resize(STR_DEFAULT_SHORT);
                    IGetSymbParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), &param2, (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize7 ), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), &param7, reinterpret_cast<long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<long*>(&param11), (gx_string_char_type*)param12.data(), reinterpret_cast<const long*>(&paramSize16 ), &param13, (gx_string_char_type*)param14.data(), reinterpret_cast<const long*>(&paramSize19 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param12.resize(gx_string_len(param12.c_str()));
                    param14.resize(gx_string_len(param14.c_str()));
                }

                void get_title_parms(gx_string_type& param1, gx_string_type& param2, int32_t& param3, double& param4, double& param5, int32_t& param6, double& param7, double& param8, gx_string_type& param9, double& param10, gx_string_type& param11, STK_AXIS param12)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize12 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize15 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    param2.resize(STR_DEFAULT);
                    param9.resize(STR_DEFAULT_SHORT);
                    param11.resize(STR_DEFAULT_SHORT);
                    IGetTitleParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<long*>(&param3), &param4, &param5, reinterpret_cast<long*>(&param6), &param7, &param8, (gx_string_char_type*)param9.data(), reinterpret_cast<const long*>(&paramSize12 ), &param10, (gx_string_char_type*)param11.data(), reinterpret_cast<const long*>(&paramSize15 ), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param9.resize(gx_string_len(param9.c_str()));
                    param11.resize(gx_string_len(param11.c_str()));
                }

                void set_flag(int32_t param1, STK_FLAG param2)
                {
                    ISetFlag_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_array_colors(GXITRPtr param1)
                {
                    SetArrayColors_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_axis_format(DB_CHAN_FORMAT param1, STK_AXIS param2)
                {
                    SetAxisFormat_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_axis_parms(int32_t param1, double param2, double param3, double param4, const gx_string_type& param5, double param6, double param7, double param8, int32_t param9, STK_AXIS param10)
                {
                    SetAxisParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, param5.c_str(), &param6, &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

                void set_fid_parms(double param1, double param2, double param3, const gx_string_type& param4, double param5, const gx_string_type& param6)
                {
                    SetFidParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, param4.c_str(), &param5, param6.c_str());
                    gx_->throw_on_error();
                }

                void set_gen_parms(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11)
                {
                    SetGenParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11);
                    gx_->throw_on_error();
                }

                void set_grid_parms(int32_t param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, const gx_string_type& param10, STK_GRID param11)
                {
                    SetGridParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, param10.c_str(), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }

                void set_label_parms(int32_t param1, double param2, int32_t param3, double param4, int32_t param5, double param6, const gx_string_type& param7, double param8, const gx_string_type& param9, int32_t param10, STK_AXIS param11)
                {
                    SetLabelParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5), &param6, param7.c_str(), &param8, param9.c_str(), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }

                void set_line_parm(int32_t param1)
                {
                    SetLineParm_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_profile(int32_t param1, double param2, double param3, const gx_string_type& param4, int32_t param5, int32_t param6, int32_t param7, GXVVPtr param8, const gx_string_type& param9, int32_t param10, const gx_string_type& param11, double param12, const gx_string_type& param13, int32_t param14)
                {
                    SetProfile_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&gx_->handle(param8)), param9.c_str(), reinterpret_cast<const long*>(&param10), param11.c_str(), &param12, param13.c_str(), reinterpret_cast<const long*>(&param14));
                    gx_->throw_on_error();
                }

                void set_profile_ex(int32_t param1, double param2, double param3, const gx_string_type& param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, GXVVPtr param9, const gx_string_type& param10, int32_t param11, const gx_string_type& param12, double param13, const gx_string_type& param14, int32_t param15)
                {
                    SetProfileEx_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)), param10.c_str(), reinterpret_cast<const long*>(&param11), param12.c_str(), &param13, param14.c_str(), reinterpret_cast<const long*>(&param15));
                    gx_->throw_on_error();
                }

                void set_symb_parms(const gx_string_type& param1, double param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, int32_t param6, double param7, int32_t param8, GXVVPtr param9, GXVVPtr param10, int32_t param11, const gx_string_type& param12, double param13, const gx_string_type& param14)
                {
                    SetSymbParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&param11), param12.c_str(), &param13, param14.c_str());
                    gx_->throw_on_error();
                }

                void set_title_parms(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, double param4, double param5, int32_t param6, double param7, double param8, const gx_string_type& param9, double param10, const gx_string_type& param11, STK_AXIS param12)
                {
                    SetTitleParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4, &param5, reinterpret_cast<const long*>(&param6), &param7, &param8, param9.c_str(), &param10, param11.c_str(), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }

                void set_trans_parms(int32_t param1, double param2, int32_t param3, int32_t param4, int32_t param5, double param6, int32_t param7, int32_t param8)
                {
                    SetTransParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                void set_va_index_start(int32_t param1)
                {
                    SetVAIndexStart_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }


            };
            class GXSTRINGS
            {
            private:
                GXSTRINGS();
                ~GXSTRINGS();
            public:


                static void launch_digitization_ui(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchDigitizationUI_STRINGS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXTC
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXTC(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXTCPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXTC>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXTCPtr create(GXIMGPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, int32_t param8, double param9, TC_OPT param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_TC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), &param9, reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTC>(ret);
                }

                static GXTCPtr create_ex(GXIMGPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, int32_t param8, double param9, TC_OPT param10, TC_SURVEYTYPE param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateEx_TC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTC>(ret);
                }

                ~GXTC()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_TC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void grregter(GXIMGPtr param1, GXIMGPtr param2)
                {
                    Grregter_TC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void grterain(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXIMGPtr param6, double param7)
                {
                    Grterain_TC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), &param7);
                    gx_->throw_on_error();
                }

                void grterain2(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXIMGPtr param7, double param8)
                {
                    Grterain2_TC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), &param8);
                    gx_->throw_on_error();
                }

                void g_gterain(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, GG_ELEMENT param7)
                {
                    GGterain_TC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }


            };
            class GXTEST
            {
            private:
                GXTEST();
                ~GXTEST();
            public:


                static void enable_disable_arc_engine_license(bool param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool1 = param1 ? 1 : 0;
                    EnableDisableArcEngineLicense_TEST(
                        gx_->pGeo, &paramBool1);
                    gx_->throw_on_error();
                }

                static int32_t arc_engine_license()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iArcEngineLicense_TEST(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static bool test_mode()
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != iTestMode_TEST(
                                   gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static void wrapper_test(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    WrapperTest_TEST(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void core_class(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CoreClass_TEST(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXTIN
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXTIN(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXTINPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXTIN>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void copy(GXTINPtr param1)
                {
                    Copy_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXTINPtr create(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTIN>(ret);
                }

                static GXTINPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTIN>(ret);
                }

                ~GXTIN()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                static void export_xml(const gx_string_type& param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportXML_TIN(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                void get_convex_hull(GXPLYPtr param1)
                {
                    GetConvexHull_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_joins(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GetJoins_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void get_mesh(GXVVPtr param1)
                {
                    GetMesh_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_nodes(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GetNodes_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void get_triangles(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GetTriangles_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void get_triangle(int32_t param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7)
                {
                    GetTriangle_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }

                void get_voronoi_edges(GXVVPtr param1)
                {
                    GetVoronoiEdges_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                int32_t is_z_valued()
                {
                    int32_t ret = iIsZValued_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t locate_triangle(int32_t param1, double param2, double param3)
                {
                    int32_t ret = iLocateTriangle_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t nodes()
                {
                    int32_t ret = iNodes_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void interp_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    InterpVV_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                int32_t triangles()
                {
                    int32_t ret = iTriangles_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void linear_interp_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    LinearInterpVV_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void nearest_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    NearestVV_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void range_xy(double& param1, double& param2, double& param3, double& param4)
                {
                    RangeXY_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void serial(GXBFPtr param1)
                {
                    Serial_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }


            };
            class GXTRND
            {
            private:
                GXTRND();
                ~GXTRND();
            public:


                static void get_max_min(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, double param7, TRND_NODE param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetMaxMin_TRND(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void get_mesh(GXDBPtr param1, const gx_string_type& param2, double param3, double param4, GXVVPtr param5, TRND_NODE param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetMesh_TRND(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void trnd_db(GXDBPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TrndDB_TRND(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }


            };
            class GXUNC
            {
            private:
                GXUNC();
                ~GXUNC();
            public:


                static bool is_valid_utf16_char(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != iIsValidUTF16Char_UNC(
                                   gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                static bool valid_symbol(const gx_string_type& param1, bool param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool2 = param2 ? 1 : 0;
                    bool ret = 0 != iValidSymbol_UNC(
                                   gx_->pGeo, param1.c_str(), &paramBool2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static void utf16_val_to_str(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = UTF8_MAX_CHAR * STRING_CHAR_SIZE;
                    param2.resize(UTF8_MAX_CHAR);
                    UTF16ValToSTR_UNC(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void validate_symbols(GXVVPtr param1, const gx_string_type& param2, bool param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool3 = param3 ? 1 : 0;
                    ValidateSymbols_UNC(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &paramBool3);
                    gx_->throw_on_error();
                }


            };
            class GXVAU
            {
            private:
                GXVAU();
                ~GXVAU();
            public:


                static void prune(GXVAPtr param1, GXVVPtr param2, VAU_PRUNE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Prune_VAU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void total_vector(GXVAPtr param1, GXVAPtr param2, GXVAPtr param3, GXVAPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TotalVector_VAU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }


            };
            class GXVVEXP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVVEXP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVVEXPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVVEXP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_vv(GXVVPtr param1, const gx_string_type& param2)
                {
                    AddVV_VVEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static GXVVEXPPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VVEXP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVVEXP>(ret);
                }

                ~GXVVEXP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VVEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void do_formula(const gx_string_type& param1, int32_t param2)
                {
                    DoFormula_VVEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }


            };
            class GXVVU
            {
            private:
                GXVVU();
                ~GXVVU();
            public:


                static void average_repeat(GXVVPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AverageRepeat_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void average_repeat_ex(GXVVPtr param1, GXVVPtr param2, VVU_MODE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AverageRepeatEx_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void average_repeat2(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AverageRepeat2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void average_repeat2_ex(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, VVU_MODE param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AverageRepeat2Ex_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void binary_search(GXVVPtr param1, double param2, int32_t& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BinarySearch_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }

                static void box_cox(GXVVPtr param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BoxCox_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }

                static void bp_filt(GXVVPtr param1, GXVVPtr param2, double param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BPFilt_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void clip(GXVVPtr param1, double param2, double param3, VVU_CLIP param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Clip_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void clip_to_detect_limit(GXVVPtr param1, double param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClipToDetectLimit_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void decimate(GXVVPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Decimate_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void deviation(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7, VVU_LINE param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Deviation_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void distance(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Distance_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }

                static void distance_non_cumulative(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DistanceNonCumulative_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }

                static void distance_3d(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Distance3D_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void find_gaps_3d(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FindGaps3D_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void dummy_range(GXVVPtr param1, double param2, double param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DummyRange_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void dummy_range_ex(GXVVPtr param1, double param2, double param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DummyRangeEx_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void dummy_repeat(GXVVPtr param1, VVU_DUMMYREPEAT param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DummyRepeat_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void dup_stats(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DupStats_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void exp_dist(GXVVPtr param1, int32_t param2, double param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExpDist_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void filter(GXVVPtr param1, GXVVPtr param2, GXFLTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Filter_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void find_string_items(GXVVPtr param1, GXVVPtr param2, int32_t param3, int32_t param4, int32_t param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FindStringItems_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void fractal_filter(GXVVPtr param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FractalFilter_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static int32_t close_xy(GXVVPtr param1, GXVVPtr param2, double param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCloseXY_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t close_xym(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCloseXYM_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t close_xyz(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCloseXYZ_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t close_xyzm(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCloseXYZM_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t dummy_back_tracks(GXVVPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDummyBackTracks_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t find_dummy(GXVVPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iFindDummy_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }

                static void interp(GXVVPtr param1, VVU_INTERP param2, VVU_INTERP_EDGE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Interp_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static int32_t qc_fill_gaps(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iQCFillGaps_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t search_text(GXVVPtr param1, const gx_string_type& param2, VVU_CASE param3, VVU_MATCH param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iSearchText_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }

                static void mask(GXVVPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Mask_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void mask_and(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MaskAND_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void mask_or(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MaskOR_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void nl_filt(GXVVPtr param1, GXVVPtr param2, int32_t param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NLFilt_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }

                static void noise_check(GXVVPtr param1, GXVVPtr param2, double param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NoiseCheck_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void noise_check2(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NoiseCheck2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void normal_dist(GXVVPtr param1, int32_t param2, double param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NormalDist_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void offset_circles(GXVVPtr param1, GXVVPtr param2, double param3, double param4, GXVVPtr param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetCircles_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void offset_correct(GXVVPtr param1, GXVVPtr param2, double param3, VVU_OFFSET param4, GXVVPtr param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetCorrect_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void offset_correct2(GXVVPtr param1, GXVVPtr param2, double param3, double param4, GXVVPtr param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetCorrect2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void offset_correct3(GXVVPtr param1, GXVVPtr param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetCorrect3_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void offset_correct_xyz(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetCorrectXYZ_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)));
                    gx_->throw_on_error();
                }

                static void offset_rectangles(GXVVPtr param1, GXVVPtr param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetRectangles_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void pick_peak(GXVVPtr param1, GXVVPtr param2, double param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PickPeak_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void pick_peak2(GXVVPtr param1, GXVVPtr param2, double param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PickPeak2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4);
                    gx_->throw_on_error();
                }

                static void pick_peak3(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PickPeak3_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }

                static void poly_fill(GXVVPtr param1, int32_t param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PolyFill_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void poly_fill2(GXVVPtr param1, GXVVPtr param2, int32_t param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PolyFill2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void polygon_mask(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXPLYPtr param4, VVU_MASK param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PolygonMask_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void prune(GXVVPtr param1, GXVVPtr param2, VVU_PRUNE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Prune_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void qc(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7, QC_CRITERION param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    QC_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void range_vector_mag(GXVVPtr param1, GXVVPtr param2, double& param3, double& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeVectorMag_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4);
                    gx_->throw_on_error();
                }

                static void regress(GXVVPtr param1, GXVVPtr param2, double& param3, double& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Regress_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4);
                    gx_->throw_on_error();
                }

                static void rel_var_dup(GXVVPtr param1, GXVVPtr param2, double& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RelVarDup_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }

                static void remove_dummy(GXVVPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveDummy_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void remove_dummy2(GXVVPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveDummy2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void remove_dummy3(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveDummy3_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void remove_dummy4(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveDummy4_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void remove_dup(GXVVPtr param1, GXVVPtr param2, VV_DUP param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveDup_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void remove_xy_dup(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, VV_XYDUP param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveXYDup_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void remove_xy_dup_index(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveXYDupIndex_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void rolling_stats(GXVVPtr param1, GXVVPtr param2, ST_INFO param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RollingStats_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void search_replace(GXVVPtr param1, double param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SearchReplace_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3);
                    gx_->throw_on_error();
                }

                static void search_replace_text(GXVVPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, const gx_string_type& param5, VVU_SRCHREPL_CASE param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SearchReplaceText_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void search_replace_text_ex(GXVVPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, const gx_string_type& param5, VVU_SRCHREPL_CASE param6, int32_t& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SearchReplaceTextEx_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<long*>(&param7));
                    gx_->throw_on_error();
                }

                static void spline(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, double param5, double param6, double param7, int32_t param8, VVU_SPL param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Spline_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                static void spline2(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, VVU_SPL param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Spline2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static int32_t tokenize_to_values(GXVVPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTokenizeToValues_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void translate(GXVVPtr param1, double param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Translate_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3);
                    gx_->throw_on_error();
                }

                static void trend(GXVVPtr param1, int32_t param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Trend_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void trend2(GXVVPtr param1, GXVVPtr param2, int32_t param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Trend2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void uniform_dist(GXVVPtr param1, int32_t param2, double param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UniformDist_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }


            };
            class GXAGG
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXAGG(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXAGGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXAGG>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void set_model(AGG_MODEL param1)
                {
                    _SetModel_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void change_brightness(double param1)
                {
                    ChangeBrightness_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                static GXAGGPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_AGG(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXAGG>(ret);
                }

                static GXAGGPtr create_map(GXMAPPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateMap_AGG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXAGG>(ret);
                }

                ~GXAGG()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_layer_itr(int32_t param1, GXITRPtr param2)
                {
                    GetLayerITR_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                int32_t list_img(GXVVPtr param1)
                {
                    int32_t ret = iListImg_AGG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t num_layers()
                {
                    int32_t ret = iNumLayers_AGG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void layer_img(const gx_string_type& param1, AGG_LAYER_ZONE param2, const gx_string_type& param3, double param4)
                {
                    LayerIMG_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str(), &param4);
                    gx_->throw_on_error();
                }

                void layer_img_ex(const gx_string_type& param1, AGG_LAYER_ZONE param2, const gx_string_type& param3, double param4, double param5, double param6)
                {
                    LayerIMGEx_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str(), &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void layer_shade_img(const gx_string_type& param1, const gx_string_type& param2, double param3, double param4, double& param5)
                {
                    LayerShadeIMG_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                double get_brightness()
                {
                    double ret = rGetBrightness_AGG(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_layer_itr(int32_t param1, GXITRPtr param2)
                {
                    SetLayerITR_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void set_render_method(AGG_RENDER param1)
                {
                    SetRenderMethod_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }


            };
            class GXBF
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXBF(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXBFPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXBF>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void ch_size(int32_t param1)
                {
                    _ChSize_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void seek(int32_t param1, BF_SEEK param2)
                {
                    _Seek_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void copy(GXBFPtr param1)
                {
                    Copy_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                int32_t crc(int32_t param1, int32_t param2)
                {
                    int32_t ret = CRC_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static GXBFPtr create(const gx_string_type& param1, BF_OPEN_MODE param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_BF(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXBF>(ret);
                }

                static GXBFPtr create_sbf(GXSBFPtr param1, const gx_string_type& param2, BF_OPEN_MODE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateSBF_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXBF>(ret);
                }

                ~GXBF()
                {
                    if (handle_ == 0)
                        return;
                    DestroyEx_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t eof()
                {
                    int32_t ret = iEOF_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t query_write()
                {
                    int32_t ret = iQueryWrite_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void read_binary_string(int32_t param1, BF_ENCODE param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    IReadBinaryString_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                int32_t size()
                {
                    int32_t ret = iSize_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t tell()
                {
                    int32_t ret = iTell_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void read_int(int32_t param1, int32_t& param2)
                {
                    ReadInt_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }

                void read_double(int32_t param1, double& param2)
                {
                    ReadReal_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void read_vv(int32_t param1, GXVVPtr param2)
                {
                    ReadVV_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void set_destroy_status(BF_CLOSE param1)
                {
                    SetDestroyStatus_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void write_binary_string(BF_ENCODE param1, const gx_string_type& param2)
                {
                    WriteBinaryString_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void write_data_null()
                {
                    WriteDataNull_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void write_int(int32_t param1, int32_t param2)
                {
                    WriteInt_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void write_double(int32_t param1, double param2)
                {
                    WriteReal_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void write_vv(int32_t param1, GXVVPtr param2)
                {
                    WriteVV_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }


            };
            class GXDAT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDAT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDATPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDAT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDATPtr create_db(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateDB_DAT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDAT>(ret);
                }

                static GXDATPtr create_xgd(const gx_string_type& param1, DAT_XGD param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXGD_DAT(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDAT>(ret);
                }

                ~GXDAT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                static void get_lst(GXLSTPtr param1, const gx_string_type& param2, DAT_FILE param3, DAT_FILE_FORM param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetLST_DAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void range_xyz(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, int32_t& param7)
                {
                    RangeXYZ_DAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, reinterpret_cast<long*>(&param7));
                    gx_->throw_on_error();
                }


            };
            class GXDATALINKD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDATALINKD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDATALINKDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDATALINKD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDATALINKDPtr create_arc_lyr(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateArcLYR_DATALINKD(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDATALINKD>(ret);
                }

                static GXDATALINKDPtr create_arc_lyr_ex(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateArcLYREx_DATALINKD(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDATALINKD>(ret);
                }

                static GXDATALINKDPtr create_arc_lyr_from_tmp(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateArcLYRFromTMP_DATALINKD(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDATALINKD>(ret);
                }

                static GXDATALINKDPtr create_arc_lyr_from_tmp_ex(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateArcLYRFromTMPEx_DATALINKD(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDATALINKD>(ret);
                }

                static GXDATALINKDPtr create_bing(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateBING_DATALINKD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDATALINKD>(ret);
                }

                ~GXDATALINKD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DATALINKD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_extents(double& param1, double& param2, double& param3, double& param4)
                {
                    GetExtents_DATALINKD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_DATALINKD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }


            };
            class GXDATAMINE
            {
            private:
                GXDATAMINE();
                ~GXDATAMINE();
            public:


                static void create_voxel(const gx_string_type& param1, const gx_string_type& param2, GXIPJPtr param3, GXMETAPtr param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateVoxel_DATAMINE(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str());
                    gx_->throw_on_error();
                }

                static void numeric_field_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NumericFieldLST_DATAMINE(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }


            };
            class GXDB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void create_dup(const gx_string_type& param1)
                {
                    CreateDup_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void create_dup_comp(const gx_string_type& param1, DB_COMP param2)
                {
                    CreateDupComp_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                int32_t dup_symb_across(GXDBPtr param1, int32_t param2)
                {
                    int32_t ret = DupSymbAcross_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void easy_maker_symb(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    EasyMakerSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void get_chan_str(int32_t param1, int32_t param2, int32_t param3, gx_string_type& param4)
                {
                    int32_t paramSize5 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_LONG);
                    GetChanStr_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }

                void get_chan_vv(int32_t param1, int32_t param2, GXVVPtr param3)
                {
                    GetChanVV_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void get_chan_vv_expanded(int32_t param1, int32_t param2, GXVVPtr param3)
                {
                    GetChanVVExpanded_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void get_ipj(int32_t param1, GXIPJPtr param2)
                {
                    GetIPJ_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_itr(int32_t param1, GXITRPtr param2)
                {
                    GetITR_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_reg_symb(int32_t param1, GXREGPtr param2)
                {
                    GetRegSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_reg_symb_setting(int32_t param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT_LONG);
                    GetRegSymbSetting_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                void get_va_chan_vv(int32_t param1, int32_t param2, GXVVPtr param3, int32_t param4, int32_t param5)
                {
                    GetVaChanVV_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                int32_t blobs_max()
                {
                    int32_t ret = iBlobsMax_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t chans_max()
                {
                    int32_t ret = iChansMax_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void format_chan(int32_t param1, double param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT);
                    IFormatChan_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                int32_t get_chan_array_size(int32_t param1)
                {
                    int32_t ret = iGetChanArraySize_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_chan_class(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = DB_GROUP_CLASS_SIZE * STRING_CHAR_SIZE;
                    param2.resize(DB_GROUP_CLASS_SIZE);
                    IGetChanClass_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t get_chan_decimal(int32_t param1)
                {
                    int32_t ret = iGetChanDecimal_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_chan_format(int32_t param1)
                {
                    int32_t ret = iGetChanFormat_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_chan_int(int32_t param1, int32_t param2, int32_t param3)
                {
                    int32_t ret = iGetChanInt_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_chan_label(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetChanLabel_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void get_chan_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    IGetChanName_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                DB_CHAN_PROTECTION get_chan_protect(int32_t param1)
                {
                    DB_CHAN_PROTECTION ret = (DB_CHAN_PROTECTION)iGetChanProtect_DB(
                                                 gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_chan_type(int32_t param1)
                {
                    int32_t ret = iGetChanType_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_chan_unit(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetChanUnit_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t get_chan_width(int32_t param1)
                {
                    int32_t ret = iGetChanWidth_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_name(DB_NAME param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetName_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t get_reg_symb_setting_int(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = iGetRegSymbSetting_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_symb_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    IGetSymbName_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t have_itr(int32_t param1)
                {
                    int32_t ret = iHaveITR_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                DB_COORDPAIR coord_pair(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    DB_COORDPAIR ret = (DB_COORDPAIR)IiCoordPair_DB(
                                           gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }

                int32_t lines_max()
                {
                    int32_t ret = iLinesMax_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t users_max()
                {
                    int32_t ret = iUsersMax_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void maker_symb(int32_t param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    MakerSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                void put_chan_vv(int32_t param1, int32_t param2, GXVVPtr param3)
                {
                    PutChanVV_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void put_va_chan_vv(int32_t param1, int32_t param2, GXVVPtr param3, int32_t param4, int32_t param5)
                {
                    PutVaChanVV_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                void read_blob_bf(int32_t param1, GXBFPtr param2)
                {
                    ReadBlobBF_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                double get_chan_double(int32_t param1, int32_t param2, int32_t param3)
                {
                    double ret = rGetChanReal_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                double get_reg_symb_setting_double(int32_t param1, const gx_string_type& param2)
                {
                    double ret = rGetRegSymbSetting_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void set_all_chan_protect(DB_CHAN_PROTECTION param1)
                {
                    SetAllChanProtect_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_chan_class(int32_t param1, const gx_string_type& param2)
                {
                    SetChanClass_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_chan_decimal(int32_t param1, int32_t param2)
                {
                    SetChanDecimal_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_chan_format(int32_t param1, DB_CHAN_FORMAT param2)
                {
                    SetChanFormat_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_chan_int(int32_t param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    SetChanInt_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void set_chan_label(int32_t param1, const gx_string_type& param2)
                {
                    SetChanLabel_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_chan_name(int32_t param1, const gx_string_type& param2)
                {
                    SetChanName_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_chan_protect(int32_t param1, DB_CHAN_PROTECTION param2)
                {
                    SetChanProtect_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_chan_double(int32_t param1, int32_t param2, int32_t param3, double param4)
                {
                    SetChanReal_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }

                void set_chan_str(int32_t param1, int32_t param2, int32_t param3, const gx_string_type& param4)
                {
                    SetChanStr_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }

                void set_chan_unit(int32_t param1, const gx_string_type& param2)
                {
                    SetChanUnit_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_chan_width(int32_t param1, int32_t param2)
                {
                    SetChanWidth_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_ipj(int32_t param1, int32_t param2, GXIPJPtr param3)
                {
                    SetIPJ_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void set_itr(int32_t param1, GXITRPtr param2)
                {
                    SetITR_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void set_reg_symb(int32_t param1, GXREGPtr param2)
                {
                    SetRegSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void set_reg_symb_setting(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    SetRegSymbSetting_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void write_blob_bf(int32_t param1, GXBFPtr param2)
                {
                    WriteBlobBF_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void commit()
                {
                    Commit_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void compact()
                {
                    Compact_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static void create(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Create_DB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }

                static void create_comp(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, const gx_string_type& param7, const gx_string_type& param8, int32_t param9, DB_COMP param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateComp_DB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str(), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

                static void create_ex(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, const gx_string_type& param7, const gx_string_type& param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateEx_DB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str(), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                void del_line0()
                {
                    DelLine0_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                ~GXDB()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void discard()
                {
                    Discard_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static void grow(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Grow_DB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static bool can_open(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != iCanOpen_DB(
                                   gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static bool can_open_read_only(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != iCanOpenReadOnly_DB(
                                   gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t check()
                {
                    int32_t ret = iCheck_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_empty()
                {
                    int32_t ret = iIsEmpty_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_line_empty(int32_t param1)
                {
                    int32_t ret = iIsLineEmpty_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                static GXDBPtr open(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_DB(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }

                static GXDBPtr open_read_only(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = OpenReadOnly_DB(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }

                static void repair(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Repair_DB(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                void sync()
                {
                    Sync_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void copy_data(int32_t param1, int32_t param2, int32_t param3)
                {
                    CopyData_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                int32_t get_col_va(int32_t param1)
                {
                    int32_t ret = iGetColVA_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_channel_length(int32_t param1, int32_t param2)
                {
                    int32_t ret = iGetChannelLength_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                double get_fid_incr(int32_t param1, int32_t param2)
                {
                    double ret = rGetFidIncr_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                double get_fid_start(int32_t param1, int32_t param2)
                {
                    double ret = rGetFidStart_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_fid(int32_t param1, int32_t param2, double param3, double param4)
                {
                    SetFid_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4);
                    gx_->throw_on_error();
                }

                void window_va_ch(int32_t param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    WindowVACh_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                void window_va_ch2(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WindowVACh2_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void set_line_selection(int32_t param1, DB_LINE_SELECT param2)
                {
                    SetLineSelection_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                DB_LINE_SELECT get_line_selection(int32_t param1)
                {
                    DB_LINE_SELECT ret = (DB_LINE_SELECT)iGetLineSelection_DB(
                                             gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t first_sel_line()
                {
                    int32_t ret = FirstSelLine_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_line_map_fid(int32_t param1, double& param2, double& param3)
                {
                    GetLineMapFid_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }

                int32_t get_select()
                {
                    int32_t ret = GetSelect_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t count_sel_lines()
                {
                    int32_t ret = iCountSelLines_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t is_chan_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsChanName_DB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_chan_valid(int32_t param1)
                {
                    int32_t ret = iIsChanValid_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t is_line_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsLineName_DB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_line_valid(int32_t param1)
                {
                    int32_t ret = iIsLineValid_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                DB_CATEGORY_LINE line_category(int32_t param1)
                {
                    DB_CATEGORY_LINE ret = (DB_CATEGORY_LINE)iLineCategory_DB(
                                               gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t line_flight(int32_t param1)
                {
                    int32_t ret = iLineFlight_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void line_label(int32_t param1, gx_string_type& param2, DB_LINE_LABEL_FORMAT param3)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    ILineLabel_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t line_number(int32_t param1)
                {
                    int32_t ret = iLineNumber_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void line_number2(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    ILineNumber2_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                DB_LINE_TYPE line_type(int32_t param1)
                {
                    DB_LINE_TYPE ret = (DB_LINE_TYPE)iLineType_DB(
                                           gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t line_version(int32_t param1)
                {
                    int32_t ret = iLineVersion_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                static void set_line_name(int32_t param1, int32_t param2, int32_t param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param4.resize(STR_DB_SYMBOL);
                    ISetLineName_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }

                static void set_line_name2(const gx_string_type& param1, int32_t param2, int32_t param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param4.resize(STR_DB_SYMBOL);
                    ISetLineName2_DB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }

                void load_select(const gx_string_type& param1)
                {
                    LoadSelect_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                int32_t next_sel_line(int32_t param1)
                {
                    int32_t ret = NextSelLine_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                double line_bearing(int32_t param1)
                {
                    double ret = rLineBearing_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                double line_date(int32_t param1)
                {
                    double ret = rLineDate_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void save_select(const gx_string_type& param1)
                {
                    SaveSelect_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void select(const gx_string_type& param1, DB_LINE_SELECT param2)
                {
                    Select_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_line_bearing(int32_t param1, double param2)
                {
                    SetLineBearing_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void set_line_date(int32_t param1, double param2)
                {
                    SetLineDate_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void set_line_flight(int32_t param1, int32_t param2)
                {
                    SetLineFlight_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_line_map_fid(int32_t param1, double param2, double param3)
                {
                    SetLineMapFid_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }

                void set_line_num(int32_t param1, int32_t param2)
                {
                    SetLineNum_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_line_type(int32_t param1, DB_LINE_TYPE param2)
                {
                    SetLineType_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_line_ver(int32_t param1, int32_t param2)
                {
                    SetLineVer_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_select(int32_t param1)
                {
                    SetSelect_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void array_lst(GXLSTPtr param1)
                {
                    ArrayLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void array_size_lst(int32_t param1, GXLSTPtr param2)
                {
                    ArraySizeLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void chan_lst(GXLSTPtr param1)
                {
                    ChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void normal_chan_lst(GXLSTPtr param1)
                {
                    NormalChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void class_chan_lst(GXLSTPtr param1, const gx_string_type& param2)
                {
                    ClassChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void class_group_lst(GXLSTPtr param1, const gx_string_type& param2)
                {
                    ClassGroupLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                int32_t create_symb(const gx_string_type& param1, DB_SYMB_TYPE param2, DB_OWN param3, int32_t param4)
                {
                    int32_t ret = CreateSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t create_symb_ex(const gx_string_type& param1, DB_SYMB_TYPE param2, DB_OWN param3, int32_t param4, int32_t param5)
                {
                    int32_t ret = CreateSymbEx_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }

                void csv_chan_lst(GXLSTPtr param1, const gx_string_type& param2)
                {
                    CSVChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void delete_symb(int32_t param1)
                {
                    DeleteSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                int32_t dup_line_symb(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = DupLineSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t dup_symb(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = DupSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t dup_symb_no_lock(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = DupSymbNoLock_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_chan(const gx_string_type& param1)
                {
                    int32_t ret = FindChan_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_symb(const gx_string_type& param1, DB_SYMB_TYPE param2)
                {
                    int32_t ret = FindSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_chan_order_lst(GXLSTPtr param1)
                {
                    GetChanOrderLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                int32_t get_xyz_chan_symb(DB_CHAN_SYMBOL param1)
                {
                    int32_t ret = GetXYZChanSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t class_chan_list(GXVVPtr param1, const gx_string_type& param2)
                {
                    int32_t ret = iClassChanList_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t exist_chan(const gx_string_type& param1)
                {
                    int32_t ret = iExistChan_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t exist_symb(const gx_string_type& param1, DB_SYMB_TYPE param2)
                {
                    int32_t ret = iExistSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t valid_symb(int32_t param1, DB_SYMB_TYPE param2)
                {
                    int32_t ret = iValidSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                DB_LOCK get_symb_lock(int32_t param1)
                {
                    DB_LOCK ret = (DB_LOCK)iGetSymbLock_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_xyz_chan(DB_CHAN_SYMBOL param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    IGetXYZChan_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t symb_list(GXVVPtr param1, DB_SYMB_TYPE param2)
                {
                    int32_t ret = iSymbList_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void line_lst(GXLSTPtr param1)
                {
                    LineLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void lock_symb(int32_t param1, DB_LOCK param2, DB_WAIT param3)
                {
                    LockSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void mask_chan_lst(GXLSTPtr param1)
                {
                    MaskChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void selected_line_lst(GXLSTPtr param1)
                {
                    SelectedLineLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_chan_order_lst(GXLSTPtr param1)
                {
                    SetChanOrderLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_xyz_chan(DB_CHAN_SYMBOL param1, const gx_string_type& param2)
                {
                    SetXYZChan_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void string_chan_lst(GXLSTPtr param1)
                {
                    StringChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void symb_lst(GXLSTPtr param1, DB_SYMB_TYPE param2)
                {
                    SymbLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void un_lock_all_symb()
                {
                    UnLockAllSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void un_lock_symb(int32_t param1)
                {
                    UnLockSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void add_associated_load(int32_t param1, int32_t param2)
                {
                    AddAssociatedLoad_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void add_comment(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    AddComment_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void add_int_comment(const gx_string_type& param1, int32_t param2, bool param3)
                {
                    long paramBool3 = param3 ? 1 : 0;
                    AddIntComment_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), &paramBool3);
                    gx_->throw_on_error();
                }

                void add_double_comment(const gx_string_type& param1, double param2, bool param3)
                {
                    long paramBool3 = param3 ? 1 : 0;
                    AddRealComment_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &paramBool3);
                    gx_->throw_on_error();
                }

                void add_time_comment(const gx_string_type& param1, bool param2)
                {
                    long paramBool2 = param2 ? 1 : 0;
                    AddTimeComment_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &paramBool2);
                    gx_->throw_on_error();
                }

                void associate(int32_t param1, int32_t param2)
                {
                    Associate_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void associate_all(int32_t param1)
                {
                    AssociateAll_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void associate_class(int32_t param1, const gx_string_type& param2)
                {
                    AssociateClass_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                static void gen_valid_chan_symb(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    GenValidChanSymb_DB(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void gen_valid_line_symb(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    GenValidLineSymb_DB(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void get_chan_va(int32_t param1, int32_t param2, GXVAPtr param3)
                {
                    GetChanVA_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void get_va_scaling(int32_t param1, double& param2, double& param3)
                {
                    GetVAScaling_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }

                void get_va_windows(int32_t param1, int32_t& param2, int32_t& param3)
                {
                    GetVAWindows_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }

                void set_va_base_coordinate_info(int32_t param1, DB_ARRAY_BASETYPE param2, double param3, GXVVPtr param4, const gx_string_type& param5, bool param6)
                {
                    long paramBool6 = param6 ? 1 : 0;
                    SetVABaseCoordinateInfo_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), &paramBool6);
                    gx_->throw_on_error();
                }

                void get_va_base_coordinate_info(int32_t param1, DB_ARRAY_BASETYPE& param2, double& param3, GXVVPtr param4, gx_string_type& param5)
                {
                    int32_t paramSize6 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param5.resize(STR_DEFAULT);
                    GetVABaseCoordinateInfo_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2), &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize6 ));
                    gx_->throw_on_error();
                    param5.resize(gx_string_len(param5.c_str()));
                }

                void get_group_class(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = DB_GROUP_CLASS_SIZE * STRING_CHAR_SIZE;
                    param2.resize(DB_GROUP_CLASS_SIZE);
                    IGetGroupClass_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t get_info(DB_INFO param1)
                {
                    int32_t ret = iGetInfo_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_va_prof_color_file(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetVAProfColorFile_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void get_va_prof_sect_option(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetVAProfSectOption_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void get_va_sect_color_file(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetVASectColorFile_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t is_associated(int32_t param1, int32_t param2)
                {
                    int32_t ret = iIsAssociated_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_wholeplot()
                {
                    int32_t ret = iIsWholeplot_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void put_chan_va(int32_t param1, int32_t param2, GXVAPtr param3)
                {
                    PutChanVA_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void set_group_class(int32_t param1, const gx_string_type& param2)
                {
                    SetGroupClass_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_va_prof_color_file(int32_t param1, const gx_string_type& param2)
                {
                    SetVAProfColorFile_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_va_prof_sect_option(int32_t param1, const gx_string_type& param2)
                {
                    SetVAProfSectOption_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_va_scaling(int32_t param1, double param2, double param3)
                {
                    SetVAScaling_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }

                void set_va_sect_color_file(int32_t param1, const gx_string_type& param2)
                {
                    SetVASectColorFile_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_va_windows(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetVAWindows_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }


            };
            class GXDBREAD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDBREAD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDBREADPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDBREAD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDBREADPtr create(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBREAD>(ret);
                }

                static GXDBREADPtr create_xy(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXY_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBREAD>(ret);
                }

                static GXDBREADPtr create_xyz(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXYZ_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBREAD>(ret);
                }

                ~GXDBREAD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DBREAD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t add_channel(int32_t param1)
                {
                    int32_t ret = iAddChannel_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                GXVVPtr get_vv(int32_t param1)
                {
                    int32_t ret = GetVV_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                GXVAPtr get_va(int32_t param1)
                {
                    int32_t ret = GetVA_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVA>(ret);
                }

                GXVVPtr get_v_vx()
                {
                    int32_t ret = GetVVx_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                GXVVPtr get_v_vy()
                {
                    int32_t ret = GetVVy_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                GXVVPtr get_v_vz()
                {
                    int32_t ret = GetVVz_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                int32_t get_chan_array_size(int32_t param1)
                {
                    int32_t ret = iGetChanArraySize_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_number_of_blocks_to_process()
                {
                    int32_t ret = iGetNumberOfBlocksToProcess_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_next_block(int32_t& param1, int32_t& param2, int32_t& param3)
                {
                    int32_t ret = iGetNextBlock_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXDBWRITE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDBWRITE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDBWRITEPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDBWRITE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDBWRITEPtr create(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBWRITE>(ret);
                }

                static GXDBWRITEPtr create_xy(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXY_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBWRITE>(ret);
                }

                static GXDBWRITEPtr create_xyz(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXYZ_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBWRITE>(ret);
                }

                ~GXDBWRITE()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DBWRITE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t add_channel(int32_t param1)
                {
                    int32_t ret = iAddChannel_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                GXDBPtr get_db()
                {
                    int32_t ret = GetDB_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }

                GXVVPtr get_vv(int32_t param1)
                {
                    int32_t ret = GetVV_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                GXVAPtr get_va(int32_t param1)
                {
                    int32_t ret = GetVA_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVA>(ret);
                }

                GXVVPtr get_v_vx()
                {
                    int32_t ret = GetVVx_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                GXVVPtr get_v_vy()
                {
                    int32_t ret = GetVVy_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                GXVVPtr get_v_vz()
                {
                    int32_t ret = GetVVz_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                int32_t get_chan_array_size(int32_t param1)
                {
                    int32_t ret = iGetChanArraySize_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void add_block(int32_t param1)
                {
                    AddBlock_DBWRITE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void commit()
                {
                    Commit_DBWRITE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void test_func(GXRAPtr param1)
                {
                    TestFunc_DBWRITE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }


            };
            class GXDSEL
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDSEL(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDSELPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDSEL>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDSELPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DSEL(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDSEL>(ret);
                }

                void data_significant_figures(double param1)
                {
                    DataSignificantFigures_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                ~GXDSEL()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void meta_query(const gx_string_type& param1)
                {
                    MetaQuery_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void picture_quality(int32_t param1)
                {
                    PictureQuality_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void request_all_info(int32_t param1)
                {
                    RequestAllInfo_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void select_area(GXPLYPtr param1)
                {
                    SelectArea_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void select_rect(double param1, double param2, double param3, double param4)
                {
                    SelectRect_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void select_resolution(double param1, int32_t param2)
                {
                    SelectResolution_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void select_size(int32_t param1, int32_t param2)
                {
                    SelectSize_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_extract_as_document(int32_t param1)
                {
                    SetExtractAsDocument_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_ipj(GXIPJPtr param1, int32_t param2)
                {
                    SetIPJ_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void spatial_accuracy(double param1)
                {
                    SpatialAccuracy_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }


            };
            class GXEXT
            {
            private:
                GXEXT();
                ~GXEXT();
            public:


                static void get_info(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, GXIPJPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetInfo_EXT(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }


            };
            class GXGEO
            {
            private:
                GXGEO();
                ~GXGEO();
            public:



            };
            class GXGEOSTRING
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXGEOSTRING(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXGEOSTRINGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXGEOSTRING>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXGEOSTRINGPtr open(const gx_string_type& param1, GEOSTRING_OPEN param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_GEOSTRING(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXGEOSTRING>(ret);
                }

                ~GXGEOSTRING()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_features(GXLSTPtr param1)
                {
                    GetFeatures_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_sections(GXLSTPtr param1)
                {
                    GetSections_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_all_shapes(GXLSTPtr param1)
                {
                    GetAllShapes_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_shapes_for_feature(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GetShapesForFeature_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_shapes_for_section(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GetShapesForSection_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_shapes_for_feature_and_section(const gx_string_type& param1, const gx_string_type& param2, GXLSTPtr param3)
                {
                    GetShapesForFeatureAndSection_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void get_feature_properties(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, bool& param4, int32_t& param5, double& param6, double& param7, double& param8, int32_t& param9, int32_t& param10, int32_t& param11, double& param12, double& param13, int32_t& param14)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    param3.resize(STR_VERY_LONG);
                    long paramBool4 = param4 ? 1 : 0;
                    GetFeatureProperties_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), &paramBool4, reinterpret_cast<long*>(&param5), &param6, &param7, &param8, reinterpret_cast<long*>(&param9), reinterpret_cast<long*>(&param10), reinterpret_cast<long*>(&param11), &param12, &param13, reinterpret_cast<long*>(&param14));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4 = paramBool4 != 0 ? true : false;
                }

                void get_section_properties(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, SECTION_ORIENTATION& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    GetSectionProperties_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<long*>(&param4), &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13);
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }

                void get_shape_properties(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    int32_t paramSize3 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_SHORT);
                    param3.resize(STR_DEFAULT_SHORT);
                    GetShapeProperties_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }


            };
            class GXGIS
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXGIS(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXGISPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXGIS>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXGISPtr create(const gx_string_type& param1, const gx_string_type& param2, GIS_TYPE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_GIS(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXGIS>(ret);
                }

                void create_map2_d(const gx_string_type& param1, double param2, GXIPJPtr param3, GIS_MAP2D param4)
                {
                    CreateMap2D_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                ~GXGIS()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_bpr_models_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GetBPRModelsLST_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                GXIPJPtr get_ipj()
                {
                    int32_t ret = GetIPJ_GIS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIPJ>(ret);
                }

                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_range(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetRange_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                static int32_t datamine_type(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDatamineType_GIS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_file_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetFileName_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static int32_t is_mi_map_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsMIMapFile_GIS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t is_mi_raster_tab_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsMIRasterTabFile_GIS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t is_mi_rotated_raster_tab_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsMIRotatedRasterTabFile_GIS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_shp_file_3d()
                {
                    int32_t ret = iIsSHPFile3D_GIS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_shp_file_point()
                {
                    int32_t ret = iIsSHPFilePoint_GIS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t num_attribs()
                {
                    int32_t ret = iNumAttribs_GIS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t num_shapes()
                {
                    int32_t ret = iNumShapes_GIS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static void scan_mi_raster_tab_file(const gx_string_type& param1, gx_string_type& param2, GXIPJPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IScanMIRasterTabFile_GIS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void load_ascii(GXWAPtr param1)
                {
                    LoadASCII_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void load_gdb(GXDBPtr param1)
                {
                    LoadGDB_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void load_map(GXMVIEWPtr param1)
                {
                    LoadMAP_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void load_map_ex(GXMAPPtr param1, const gx_string_type& param2)
                {
                    LoadMAPEx_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void load_meta_groups_map(GXMVIEWPtr param1, GXMETAPtr param2, int32_t param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    LoadMetaGroupsMAP_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }

                void load_ply(GXPLYPtr param1)
                {
                    LoadPLY_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void load_shapes_gdb(GXDBPtr param1)
                {
                    LoadShapesGDB_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_dm_wireframe_pt_file(const gx_string_type& param1)
                {
                    SetDmWireframePtFile_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_lst(GXLSTPtr param1)
                {
                    SetLST_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_triangulation_object_index(int32_t param1)
                {
                    SetTriangulationObjectIndex_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }


            };
            class GXHGD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXHGD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXHGDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXHGD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXHGDPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_HGD(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHGD>(ret);
                }

                ~GXHGD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_HGD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void export_img(const gx_string_type& param1)
                {
                    ExportIMG_HGD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_HGD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXHGDPtr h_create_img(GXIMGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hCreateIMG_HGD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHGD>(ret);
                }

                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_HGD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }


            };
            class GXHXYZ
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXHXYZ(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXHXYZPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXHXYZ>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXHXYZPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_HXYZ(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHXYZ>(ret);
                }

                ~GXHXYZ()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_HXYZ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_HXYZ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXHXYZPtr h_create_db(GXDBPtr param1, GXVVPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hCreateDB_HXYZ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHXYZ>(ret);
                }

                static GXHXYZPtr h_create_sql(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, GXIPJPtr param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hCreateSQL_HXYZ(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&gx_->handle(param5)), param6.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHXYZ>(ret);
                }

                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_HXYZ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }


            };
            class GXIMG
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXIMG(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXIMGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXIMG>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static void average2(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Average2_IMG(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void copy(GXIMGPtr param1)
                {
                    Copy_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXIMGPtr create(GS_TYPES param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }

                static GXIMGPtr create_file(GS_TYPES param1, const gx_string_type& param2, IMG_FILE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateFile_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }

                static GXIMGPtr create_mem(GS_TYPES param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateMem_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }

                static GXIMGPtr create_new_file(GS_TYPES param1, int32_t param2, int32_t param3, int32_t param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateNewFile_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }

                static GXIMGPtr create_out_file(GS_TYPES param1, const gx_string_type& param2, GXIMGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateOutFile_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }

                void create_projected(GXIPJPtr param1)
                {
                    CreateProjected_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void create_projected2(GXIPJPtr param1, double param2)
                {
                    CreateProjected2_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }

                void create_projected3(GXIPJPtr param1, double param2, double param3)
                {
                    CreateProjected3_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3);
                    gx_->throw_on_error();
                }

                ~GXIMG()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                GXPGPtr geth_pg()
                {
                    int32_t ret = GethPG_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }

                void get_info(double& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GetInfo_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_pg(GXPGPtr param1)
                {
                    GetPG_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_projected_cell_size(GXIPJPtr param1, double& param2)
                {
                    GetProjectedCellSize_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }

                void get_tr(GXTRPtr param1)
                {
                    GetTR_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                int32_t element_type(int32_t param1)
                {
                    int32_t ret = iElementType_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t e_type()
                {
                    int32_t ret = iEType_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_def_itr(GXITRPtr param1)
                {
                    int32_t ret = iGetDefITR_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                bool is_colour()
                {
                    bool ret = 0 != iIsColour_IMG(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static bool is_valid_img_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != iIsValidIMGFile_IMG(
                                   gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static bool is_valid_img_file_ex(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    bool ret = 0 != iIsValidIMGFileEx_IMG(
                                   gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }

                int32_t ne()
                {
                    int32_t ret = iNE_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void inherit(GXIPJPtr param1, double param2)
                {
                    Inherit_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }

                void inherit_img(GXIMGPtr param1)
                {
                    InheritIMG_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                int32_t nv()
                {
                    int32_t ret = iNV_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t nx()
                {
                    int32_t ret = iNX_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t ny()
                {
                    int32_t ret = iNY_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t query_int(IMG_QUERY param1)
                {
                    int32_t ret = iQuery_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t query_kx()
                {
                    int32_t ret = iQueryKX_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t set_def_itr(GXITRPtr param1)
                {
                    int32_t ret = iSetDefITR_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t user_preference_to_plot_as_colour_shaded_grid()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iUserPreferenceToPlotAsColourShadedGrid_IMG(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                void load_img(GXIMGPtr param1)
                {
                    LoadIMG_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void load_into_pager()
                {
                    LoadIntoPager_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void opt_kx(int32_t param1)
                {
                    OptKX_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void read_v(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    ReadV_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void read_x(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    ReadX_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void read_y(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    ReadY_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void refresh_gi(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RefreshGI_IMG(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                void relocate(double param1, double param2, double param3, double param4, IMG_RELOCATE param5)
                {
                    Relocate_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void report(const gx_string_type& param1, GXWAPtr param2, int32_t param3, int32_t param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Report_IMG(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                }

                static void report_csv(const gx_string_type& param1, GXWAPtr param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReportCSV_IMG(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                double get_z(double param1, double param2)
                {
                    double ret = rGetZ_IMG(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }

                double query_double(IMG_QUERY param1)
                {
                    double ret = rQuery_IMG(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_grid_unchanged()
                {
                    SetGridUnchanged_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void set_info(double param1, double param2, double param3, double param4, double param5)
                {
                    SetInfo_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_pg(GXPGPtr param1)
                {
                    SetPG_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_tr(GXTRPtr param1)
                {
                    SetTR_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void sync(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sync_IMG(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                void write_v(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WriteV_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void write_x(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WriteX_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void write_y(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WriteY_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void set_double_parameter(const gx_string_type& param1, double param2)
                {
                    SetRealParameter_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }

                double get_double_parameter(const gx_string_type& param1)
                {
                    double ret = rGetRealParameter_IMG(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXIMU
            {
            private:
                GXIMU();
                ~GXIMU();
            public:


                static void agg_to_geo_color(GXAGGPtr param1, const gx_string_type& param2, GXIPJPtr param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AggToGeoColor_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4);
                    gx_->throw_on_error();
                }

                static int32_t crc(GXIMGPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRC_IMU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t crc_grid(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRCGrid_IMU(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t crc_grid_inexact(const gx_string_type& param1, int32_t param2, IMU_FLOAT_CRC_BITS param3, IMU_DOUBLE_CRC_BITS param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRCGridInexact_IMU(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t crc_inexact(GXIMGPtr param1, int32_t param2, IMU_FLOAT_CRC_BITS param3, IMU_DOUBLE_CRC_BITS param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRCInexact_IMU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }

                static void export_grid_without_data_section_xml(const gx_string_type& param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportGridWithoutDataSectionXML_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                static void export_grid_xml(const gx_string_type& param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportGridXML_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                static void export_raw_xml(GXIMGPtr param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportRawXML_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                static void export_xml(GXIMGPtr param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportXML_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                static void get_zvv(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetZVV_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void get_z_peaks_vv(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetZPeaksVV_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void grid_add(GXIMGPtr param1, double param2, GXIMGPtr param3, double param4, GXIMGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridAdd_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void grid_agc(GXIMGPtr param1, GXIMGPtr param2, int32_t param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridAGC_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                static void grid_bool(GXIMGPtr param1, GXIMGPtr param2, const gx_string_type& param3, IMU_BOOL_OPT param4, IMU_BOOL_SIZING param5, IMU_BOOL_OLAP param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridBool_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void grid_edge(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridEdge_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void grid_edge_ply(GXIMGPtr param1, GXPLYPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridEdgePLY_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void grid_expand(GXIMGPtr param1, const gx_string_type& param2, double param3, IMU_EXPAND_SHAPE param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridExpand_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void grid_exp_fill(const gx_string_type& param1, const gx_string_type& param2, double param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridExpFill_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void grid_fill(GXIMGPtr param1, GXIMGPtr param2, IMU_FILL_ROLLOPT param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8, double param9, int32_t param10, int32_t param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridFill_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }

                static void grid_filt(GXIMGPtr param1, GXIMGPtr param2, int32_t param3, double param4, IMU_FILT_DUMMY param5, IMU_FILT_HZDRV param6, IMU_FILT_FILE param7, const gx_string_type& param8, GXVVPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridFilt_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), param8.c_str(), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }

                static void grid_head(const gx_string_type& param1, double param2, double param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridHead_IMU(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                static void grid_in_fill(GXIMGPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridInFill_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void grid_mask(const gx_string_type& param1, const gx_string_type& param2, GXPLYPtr param3, IMU_MASK param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridMask_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void grid_peak(const gx_string_type& param1, int32_t param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridPeak_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void grid_ply(GXIMGPtr param1, GXPLYPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridPLY_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void grid_ply_ex(GXIMGPtr param1, GXPLYPtr param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridPLYEx_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void grid_reproject_and_window(const gx_string_type& param1, const gx_string_type& param2, GXIPJPtr param3, double param4, double param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridReprojectAndWindow_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }

                static void grid_resample(const gx_string_type& param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridResample_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void grid_resize(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridResize_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void grid_shad(const gx_string_type& param1, const gx_string_type& param2, double& param3, double& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridShad_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                static void grid_st(const gx_string_type& param1, GXSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridST_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void grid_stat(const gx_string_type& param1, int32_t& param2, int32_t& param3, int32_t& param4, double& param5, double& param6, int32_t& param7, double& param8, double& param9, double& param10, double& param11, double& param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStat_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), &param5, &param6, reinterpret_cast<long*>(&param7), &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }

                static void grid_stat_comp(const gx_string_type& param1, int32_t& param2, int32_t& param3, int32_t& param4, double& param5, double& param6, int32_t& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStatComp_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), &param5, &param6, reinterpret_cast<long*>(&param7), &param8, &param9, &param10, &param11, &param12, &param13);
                    gx_->throw_on_error();
                }

                static void grid_stat_ext(const gx_string_type& param1, IMU_STAT_FORCED param2, int32_t& param3, int32_t& param4, double& param5, double& param6, double& param7, double& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStatExt_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }

                static void grid_stat_trend(const gx_string_type& param1, int32_t& param2, double& param3, double& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStatTrend_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                static void grid_stat_trend_ext(const gx_string_type& param1, int32_t& param2, int32_t& param3, double& param4, double& param5, GXVMPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStatTrendExt_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static double slope_standard_deviation(GXIMGPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rSlopeStandardDeviation_IMU(
                                     gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                static void grid_stitch(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, double param8, int32_t param9, int32_t param10, GXPLYPtr param11, double param12, int32_t param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStitch_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), &param12, reinterpret_cast<const long*>(&param13));
                    gx_->throw_on_error();
                }

                static void grid_stitch_ctl(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStitchCtl_IMU(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void grid_tiff(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, int32_t param5, int32_t param6, double param7, int32_t param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridTiff_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), &param9);
                    gx_->throw_on_error();
                }

                static void grid_trnd(GXIMGPtr param1, GXIMGPtr param2, int32_t param3, IMU_TREND param4, int32_t param5, GXVMPtr param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridTrnd_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void grid_trns(const gx_string_type& param1, IMU_TRANS param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridTrns_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void grid_vd(GXIMGPtr param1, GXIMGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridVD_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void grid_vol(GXIMGPtr param1, double param2, double param3, double& param4, double& param5, double& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridVol_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                static void grid_wind(GXIMGPtr param1, const gx_string_type& param2, IMU_WIND_COORD param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, IMU_WIND_DUMMIES param11, int32_t param12, const gx_string_type& param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridWind_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), param13.c_str());
                    gx_->throw_on_error();
                }

                static void grid_wind2(GXIMGPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, double param7, double param8, IMU_WIND_DUMMIES param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridWind2_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                static void grid_xyz(GXIMGPtr param1, const gx_string_type& param2, IMU_XYZ_INDEX param3, int32_t param4, int32_t param5, IMU_XYZ_LABEL param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridXYZ_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static GS_TYPES grid_type(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GS_TYPES ret = (GS_TYPES)iGridType_IMU(
                                       gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void make_mi_tab_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MakeMITabFile_IMU(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void make_mi_tabfrom_grid(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MakeMITabfromGrid_IMU(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void make_mi_tabfrom_map(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MakeMITabfromMap_IMU(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static GXIMGPtr mosaic(const gx_string_type& param1, const gx_string_type& param2, GXIPJPtr param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Mosaic_IMU(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }

                static void peak_size(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, double param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PeakSize_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void peak_size2(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PeakSize2_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                static void pigeon_hole(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PigeonHole_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }

                static void profile(GXIMGPtr param1, double param2, double param3, double param4, double param5, double param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Profile_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void profile_vv(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProfileVV_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void range_grids(const gx_string_type& param1, GXIPJPtr param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeGrids_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                static void range_ll(GXIMGPtr param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeLL_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                static void stat_window(GXIMGPtr param1, double param2, double param3, double param4, double param5, int32_t param6, GXSTPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    StatWindow_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void update_ply(GXIMGPtr param1, GXPLYPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UpdatePLY_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }


            };
            class GXIPJ
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXIPJ(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXIPJPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXIPJ>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear_warp()
                {
                    _ClearWarp_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void make_geographic()
                {
                    _MakeGeographic_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void make_wgs84()
                {
                    _MakeWGS84_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void set_units(double param1, const gx_string_type& param2)
                {
                    _SetUnits_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, param2.c_str());
                    gx_->throw_on_error();
                }

                void add_exagg_warp(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    AddExaggWarp_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void add_log_warp(int32_t param1, int32_t param2)
                {
                    AddLogWarp_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void add_matrix_warp(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, double param15, double param16)
                {
                    AddMatrixWarp_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16);
                    gx_->throw_on_error();
                }

                void add_warp(IPJ_TYPE param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    AddWarp_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                void clear_coordinate_system()
                {
                    ClearCoordinateSystem_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void clear_orientation()
                {
                    ClearOrientation_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void convert_orientation_warp_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4)
                {
                    ConvertOrientationWarpVV_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void copy(GXIPJPtr param1)
                {
                    Copy_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void copy_projection(GXIPJPtr param1)
                {
                    CopyProjection_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXIPJPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_IPJ(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIPJ>(ret);
                }

                static GXIPJPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIPJ>(ret);
                }

                static GXIPJPtr create_xml(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXML_IPJ(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIPJ>(ret);
                }

                ~GXIPJ()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_3d_view(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9)
                {
                    Get3DView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                void get_3d_view_ex(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, IPJ_3D_ROTATE& param10, IPJ_3D_FLAG& param11)
                {
                    Get3DViewEx_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, reinterpret_cast<long*>(&param10), reinterpret_cast<long*>(&param11));
                    gx_->throw_on_error();
                }

                void get_crooked_section_view_v_vs(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t& param4)
                {
                    GetCrookedSectionViewVVs_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }

                static void get_list(IPJ_PARM_LST param1, const gx_string_type& param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetList_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void get_orientation_info(double& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GetOrientationInfo_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void get_plane_equation(double param1, double param2, double param3, double param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13)
                {
                    GetPlaneEquation_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13);
                    gx_->throw_on_error();
                }

                void get_plane_equation2(GXIPJPtr param1, double param2, double param3, double param4, double param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13, double& param14)
                {
                    GetPlaneEquation2_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14);
                    gx_->throw_on_error();
                }

                int32_t compare_datums(GXIPJPtr param1)
                {
                    int32_t ret = iCompareDatums_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t convert_warp(double& param1, double& param2, double& param3, int32_t param4)
                {
                    int32_t ret = iConvertWarp_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t convert_warp_vv(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    int32_t ret = iConvertWarpVV_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t coordinate_systems_are_the_same(GXIPJPtr param1)
                {
                    int32_t ret = iCoordinateSystemsAreTheSame_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t coordinate_systems_are_the_same_within_a_small_tolerance(GXIPJPtr param1)
                {
                    int32_t ret = iCoordinateSystemsAreTheSameWithinASmallTolerance_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_display_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetDisplayName_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_esri(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IGetESRI_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_gxf(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, gx_string_type& param5)
                {
                    int32_t paramSize6 = STR_GXF * STRING_CHAR_SIZE;
                    param1.resize(STR_GXF);
                    param2.resize(STR_GXF);
                    param3.resize(STR_GXF);
                    param4.resize(STR_GXF);
                    param5.resize(STR_GXF);
                    IGetGXF_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), (gx_string_char_type*)param2.data(), (gx_string_char_type*)param3.data(), (gx_string_char_type*)param4.data(), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize6 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param5.resize(gx_string_len(param5.c_str()));
                }

                void get_mi_coord_sys(gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    param2.resize(STR_DEFAULT_LONG);
                    IGetMICoordSys_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void get_name(IPJ_NAME param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    IGetName_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                IPJ_ORIENT get_orientation()
                {
                    IPJ_ORIENT ret = (IPJ_ORIENT)iGetOrientation_IPJ(
                                         gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_orientation_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetOrientationName_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_units(double& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetUnits_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void get_xml(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IGetXML_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                int32_t has_projection()
                {
                    int32_t ret = iHasProjection_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_3d_inverted()
                {
                    int32_t ret = iIs3DInverted_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_3d_inverted_angles()
                {
                    int32_t ret = iIs3DInvertedAngles_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_geographic()
                {
                    int32_t ret = iIsGeographic_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t orientations_are_the_same(GXIPJPtr param1)
                {
                    int32_t ret = iOrientationsAreTheSame_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t orientations_are_the_same_within_a_small_tolerance(GXIPJPtr param1)
                {
                    int32_t ret = iOrientationsAreTheSameWithinASmallTolerance_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t has_section_orientation()
                {
                    int32_t ret = iHasSectionOrientation_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t projection_type_is_fully_supported()
                {
                    int32_t ret = iProjectionTypeIsFullySupported_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t set_gxf_safe(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    int32_t ret = iSetGXF_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                IPJ_TYPE source_type()
                {
                    IPJ_TYPE ret = (IPJ_TYPE)iSourceType_IPJ(
                                       gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t support_datum_transform(GXIPJPtr param1)
                {
                    int32_t ret = iSupportDatumTransform_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                static void unit_name(double param1, IPJ_UNIT param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT);
                    IUnitName_IPJ(
                        gx_->pGeo, &param1, reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                bool warped()
                {
                    bool ret = 0 != iWarped_IPJ(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t warps_are_the_same(GXIPJPtr param1)
                {
                    int32_t ret = iWarpsAreTheSame_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t warps_are_the_same_within_a_small_tolerance(GXIPJPtr param1)
                {
                    int32_t ret = iWarpsAreTheSameWithinASmallTolerance_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                IPJ_WARP warp_type()
                {
                    IPJ_WARP ret = (IPJ_WARP)iWarpType_IPJ(
                                       gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void make_projected(double param1, double param2, double param3, double param4)
                {
                    MakeProjected_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void new_box_resolution(GXIPJPtr param1, double param2, double param3, double param4, double param5, double param6, double& param7, double& param8, double& param9)
                {
                    NewBoxResolution_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                void read(IPJ_TYPE param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    Read_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                double get_method_parm(IPJ_CSP param1)
                {
                    double ret = rGetMethodParm_IPJ(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                double get_north_azimuth(double param1, double param2)
                {
                    double ret = rGetNorthAzimuth_IPJ(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }

                static double unit_scale(const gx_string_type& param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUnitScale_IPJ(
                                     gx_->pGeo, param1.c_str(), &param2);
                    gx_->throw_on_error();
                    return ret;
                }

                void serial(GXBFPtr param1)
                {
                    Serial_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void serial_fgdcxml(const gx_string_type& param1)
                {
                    SerialFGDCXML_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void serial_isoxml(const gx_string_type& param1)
                {
                    SerialISOXML_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void serial_xml(const gx_string_type& param1)
                {
                    SerialXML_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_3d_inverted(int32_t param1)
                {
                    Set3DInverted_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_3d_inverted_angles(int32_t param1)
                {
                    Set3DInvertedAngles_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_3d_view(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9)
                {
                    Set3DView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                void set_3d_view_ex(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, IPJ_3D_ROTATE param10, IPJ_3D_FLAG param11)
                {
                    Set3DViewEx_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }

                void set_3d_view_from_axes(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12)
                {
                    Set3DViewFromAxes_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }

                void set_crooked_section_view(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4)
                {
                    SetCrookedSectionView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void set_depth_section_view(double param1)
                {
                    SetDepthSectionView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_esri(const gx_string_type& param1)
                {
                    SetESRI_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_gxf(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    SetGXF_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }

                void set_method_parm(IPJ_CSP param1, double param2)
                {
                    SetMethodParm_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void set_mi_coord_sys(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SetMICoordSys_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_normal_section_view(double param1, double param2, double param3, double param4, double param5)
                {
                    SetNormalSectionView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void set_plan_view(double param1, double param2, double param3, double param4)
                {
                    SetPlanView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void set_section_view(double param1, double param2, double param3, double param4, double param5)
                {
                    SetSectionView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void set_wms_coord_sys(const gx_string_type& param1, double param2, double param3, double param4, double param5)
                {
                    SetWMSCoordSys_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void set_xml(const gx_string_type& param1)
                {
                    SetXML_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void get_3d_matrix_orientation(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13, double& param14, double& param15, double& param16)
                {
                    Get3DMatrixOrientation_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16);
                    gx_->throw_on_error();
                }

                void set_3d_matrix_orientation(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, double param15, double param16)
                {
                    Set3DMatrixOrientation_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16);
                    gx_->throw_on_error();
                }

                void reproject_section_grid(GXIPJPtr param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    ReprojectSectionGrid_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }


            };
            class GXITR
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXITR(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXITRPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXITR>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void change_brightness(double param1)
                {
                    ChangeBrightness_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void color_vv(GXVVPtr param1, GXVVPtr param2)
                {
                    ColorVV_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void copy(GXITRPtr param1)
                {
                    Copy_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXITRPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_ITR(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXITR>(ret);
                }

                static GXITRPtr create_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateFile_ITR(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXITR>(ret);
                }

                static GXITRPtr create_img(GXIMGPtr param1, const gx_string_type& param2, ITR_ZONE param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateIMG_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXITR>(ret);
                }

                static GXITRPtr create_map(GXMAPPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateMap_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXITR>(ret);
                }

                static GXITRPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXITR>(ret);
                }

                ~GXITR()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void equal_area(GXSTPtr param1, double param2)
                {
                    EqualArea_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }

                void get_data_limits(double& param1, double& param2)
                {
                    GetDataLimits_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                GXREGPtr get_reg()
                {
                    int32_t ret = GetREG_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }

                void get_zone_color(int32_t param1, MVIEW_COLOR& param2)
                {
                    GetZoneColor_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }

                MVIEW_COLOR color_value(double param1)
                {
                    MVIEW_COLOR ret = (MVIEW_COLOR)iColorValue_ITR(
                                          gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_size()
                {
                    int32_t ret = iGetSize_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                ITR_ZONE_MODEL get_zone_model_type()
                {
                    ITR_ZONE_MODEL ret = (ITR_ZONE_MODEL)iGetZoneModelType_ITR(
                                             gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void linear(double param1, double param2, double param3)
                {
                    Linear_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                void load_a(const gx_string_type& param1)
                {
                    LoadA_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void log_linear(double param1, double param2, double param3)
                {
                    LogLinear_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                void normal(double param1, double param2, double param3, double param4)
                {
                    Normal_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void power_zone(ITR_POWER param1)
                {
                    PowerZone_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                double get_brightness()
                {
                    double ret = rGetBrightness_ITR(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double get_zone_value(int32_t param1)
                {
                    double ret = rGetZoneValue_ITR(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void save_a(const gx_string_type& param1)
                {
                    SaveA_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void save_file(const gx_string_type& param1)
                {
                    SaveFile_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void serial(GXBFPtr param1)
                {
                    Serial_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void set_agg_map(GXMAPPtr param1, const gx_string_type& param2, GXITRPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetAggMap_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void set_bright_contrast(double param1, double param2)
                {
                    SetBrightContrast_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void set_color_model(ITR_COLOR_MODEL param1)
                {
                    SetColorModel_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_data_limits(double param1, double param2)
                {
                    SetDataLimits_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void set_size(int32_t param1)
                {
                    SetSize_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_zone_color(int32_t param1, MVIEW_COLOR param2)
                {
                    SetZoneColor_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_zone_value(int32_t param1, double param2)
                {
                    SetZoneValue_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }


            };
            class GXLAYOUT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXLAYOUT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXLAYOUTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXLAYOUT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void calculate_rects(double& param1, double& param2, double& param3, double& param4)
                {
                    CalculateRects_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void clear_all()
                {
                    ClearAll_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void clear_constraints()
                {
                    ClearConstraints_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static GXLAYOUTPtr create(int32_t param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_LAYOUT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLAYOUT>(ret);
                }

                ~GXLAYOUT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_rectangle(int32_t param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GetRectangle_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void get_rect_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    GetRectName_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t add_constraint(int32_t param1, LAYOUT_CONSTR param2, int32_t param3, LAYOUT_CONSTR param4, double param5, double param6)
                {
                    int32_t ret = iAddConstraint_LAYOUT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t add_rectangle(double param1, double param2, double param3, double param4)
                {
                    int32_t ret = iAddRectangle_LAYOUT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t num_rectangles()
                {
                    int32_t ret = iNumRectangles_LAYOUT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_rectangle(int32_t param1, double param2, double param3, double param4, double param5)
                {
                    SetRectangle_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void set_rectangle_name(int32_t param1, const gx_string_type& param2)
                {
                    SetRectangleName_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXLL2
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXLL2(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXLL2Ptr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXLL2>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXLL2Ptr create(double param1, double param2, double param3, double param4, int32_t param5, int32_t param6, GXIPJPtr param7, GXIPJPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_LL2(
                                      gx_->pGeo, &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLL2>(ret);
                }

                ~GXLL2()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_LL2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void save(const gx_string_type& param1)
                {
                    Save_LL2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_row(int32_t param1, GXVVPtr param2, GXVVPtr param3)
                {
                    SetRow_LL2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }


            };
            class GXLPT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXLPT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXLPTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXLPT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXLPTPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_LPT(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLPT>(ret);
                }

                ~GXLPT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_LPT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_lst(GXLSTPtr param1)
                {
                    GetLST_LPT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_standard_lst(GXLSTPtr param1)
                {
                    GetStandardLST_LPT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }


            };
            class GXLST
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXLST(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXLSTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXLST>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_item(const gx_string_type& param1, const gx_string_type& param2)
                {
                    AddItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void add_symb_item(const gx_string_type& param1, int32_t param2)
                {
                    AddSymbItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void add_unique_item(const gx_string_type& param1, const gx_string_type& param2)
                {
                    AddUniqueItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void append(GXLSTPtr param1)
                {
                    Append_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXLSTPtr assay_channel()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = AssayChannel_LST(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }

                void clear()
                {
                    Clear_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void convert_from_csv_string(const gx_string_type& param1)
                {
                    ConvertFromCSVString_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void copy(GXLSTPtr param1)
                {
                    Copy_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXLSTPtr create(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }

                static GXLSTPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }

                void del_item(int32_t param1)
                {
                    DelItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                ~GXLST()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void find_items(LST_ITEM param1, GXLSTPtr param2, GXVVPtr param3)
                {
                    FindItems_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void gt_item(LST_ITEM param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    GtItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                void gt_symb_item(int32_t param1, gx_string_type& param2, int32_t& param3)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    GtSymbItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void convert_to_csv_string(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IConvertToCSVString_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                int32_t find_item(LST_ITEM param1, const gx_string_type& param2)
                {
                    int32_t ret = iFindItem_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_item_mask(LST_ITEM param1, const gx_string_type& param2)
                {
                    int32_t ret = iFindItemMask_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_int(LST_ITEM param1, int32_t param2)
                {
                    int32_t ret = iGetInt_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void insert_item(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    InsertItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                int32_t size()
                {
                    int32_t ret = iSize_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void load_csv(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    LoadCSV_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                void load_file(const gx_string_type& param1)
                {
                    LoadFile_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void resource(const gx_string_type& param1)
                {
                    Resource_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                double get_double(LST_ITEM param1, int32_t param2)
                {
                    double ret = rGetReal_LST(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void save_file(const gx_string_type& param1)
                {
                    SaveFile_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void select_csv_string_items(const gx_string_type& param1, GXLSTPtr param2)
                {
                    SelectCSVStringItems_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void serial(GXBFPtr param1)
                {
                    Serial_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_item(LST_ITEM param1, int32_t param2, const gx_string_type& param3)
                {
                    SetItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                void sort(LST_ITEM param1, int32_t param2)
                {
                    Sort_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }


            };
            class GXLTB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXLTB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXLTBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXLTB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_record(const gx_string_type& param1, int32_t& param2)
                {
                    AddRecord_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }

                GXLTBPtr contract(GXLTBPtr param1)
                {
                    int32_t ret = Contract_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }

                static GXLTBPtr create(const gx_string_type& param1, LTB_TYPE param2, LTB_DELIM param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_LTB(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }

                static GXLTBPtr create_crypt(const gx_string_type& param1, LTB_TYPE param2, LTB_DELIM param3, LTB_CASE param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateCrypt_LTB(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }

                static GXLTBPtr create_ex(const gx_string_type& param1, LTB_TYPE param2, LTB_DELIM param3, LTB_CASE param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateEx_LTB(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }

                void delete_record(int32_t param1)
                {
                    DeleteRecord_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                ~GXLTB()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_con_lst(int32_t param1, const gx_string_type& param2, LTB_CONLST param3, GXLSTPtr param4)
                {
                    GetConLST_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void get_lst(int32_t param1, GXLSTPtr param2)
                {
                    GetLST_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_lst2(int32_t param1, int32_t param2, GXLSTPtr param3)
                {
                    GetLST2_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                int32_t fields()
                {
                    int32_t ret = iFields_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_field(const gx_string_type& param1)
                {
                    int32_t ret = iFindField_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_key(const gx_string_type& param1)
                {
                    int32_t ret = iFindKey_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_field(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    IGetField_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t get_int(int32_t param1, int32_t param2)
                {
                    int32_t ret = iGetInt_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_string(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    IGetString_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                void get_english_string(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    IGetEnglishString_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                int32_t records()
                {
                    int32_t ret = iRecords_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t search(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    int32_t ret = iSearch_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                GXLTBPtr merge(GXLTBPtr param1)
                {
                    int32_t ret = Merge_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }

                double get_double(int32_t param1, int32_t param2)
                {
                    double ret = rGetReal_LTB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void save(const gx_string_type& param1)
                {
                    Save_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void save_crypt(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SaveCrypt_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_int(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetInt_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void set_double(int32_t param1, int32_t param2, double param3)
                {
                    SetReal_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }

                void set_string(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    SetString_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXMAP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMAP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMAPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMAP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void export_all_in_view(const gx_string_type& param1, const gx_string_type& param2, double param3, double param4, MAP_EXPORT_BITS param5, MAP_EXPORT_METHOD param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    ExportAllInView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }

                void export_all_raster(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4, double param5, MAP_EXPORT_BITS param6, MAP_EXPORT_METHOD param7, const gx_string_type& param8, const gx_string_type& param9)
                {
                    ExportAllRaster_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), param8.c_str(), param9.c_str());
                    gx_->throw_on_error();
                }

                void export_area_in_view(const gx_string_type& param1, const gx_string_type& param2, double param3, double param4, MAP_EXPORT_BITS param5, MAP_EXPORT_METHOD param6, double param7, double param8, double param9, double param10, const gx_string_type& param11, const gx_string_type& param12)
                {
                    ExportAreaInView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, &param10, param11.c_str(), param12.c_str());
                    gx_->throw_on_error();
                }

                void export_area_raster(const gx_string_type& param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, int32_t param7, int32_t param8, double param9, MAP_EXPORT_BITS param10, MAP_EXPORT_METHOD param11, const gx_string_type& param12, const gx_string_type& param13)
                {
                    ExportAreaRaster_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), param12.c_str(), param13.c_str());
                    gx_->throw_on_error();
                }

                void render_bitmap(const gx_string_type& param1, double param2, double param3, double param4, double param5, const gx_string_type& param6, int32_t param7)
                {
                    RenderBitmap_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, param6.c_str(), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                void agg_list(GXLSTPtr param1, int32_t param2)
                {
                    AGGList_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void agg_list_ex(GXLSTPtr param1, int32_t param2, MAP_LIST_MODE param3)
                {
                    AGGListEx_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void clean()
                {
                    Clean_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void commit()
                {
                    Commit_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void copy_map_to_view(const gx_string_type& param1, const gx_string_type& param2)
                {
                    CopyMapToView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void crc_map(int32_t& param1, const gx_string_type& param2)
                {
                    CRCMap_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                static GXMAPPtr create(const gx_string_type& param1, MAP_OPEN param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MAP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAP>(ret);
                }

                static GXMAPPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Current_MAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAP>(ret);
                }

                void delete_view(const gx_string_type& param1)
                {
                    DeleteView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                ~GXMAP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void discard()
                {
                    Discard_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void dup_map(GXMAPPtr param1, DUPMAP param2)
                {
                    DupMap_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                GXLPTPtr get_lpt()
                {
                    int32_t ret = GetLPT_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLPT>(ret);
                }

                void get_map_size(double& param1, double& param2, double& param3, double& param4)
                {
                    GetMapSize_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                GXMETAPtr get_meta()
                {
                    int32_t ret = GetMETA_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMETA>(ret);
                }

                GXREGPtr get_reg()
                {
                    int32_t ret = GetREG_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }

                void group_list(GXLSTPtr param1)
                {
                    GroupList_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void group_list_ex(GXLSTPtr param1, MAP_LIST_MODE param2)
                {
                    GroupListEx_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void duplicate_view(const gx_string_type& param1, gx_string_type& param2, bool param3)
                {
                    int32_t paramSize3 = STR_VIEW * STRING_CHAR_SIZE;
                    param2.resize(STR_VIEW);
                    long paramBool3 = param3 ? 1 : 0;
                    IDuplicateView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), &paramBool3);
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t exist_view(const gx_string_type& param1)
                {
                    int32_t ret = iExistView_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_class_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetClassName_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void get_file_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetFileName_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_map_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetMapName_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                int32_t packed_files()
                {
                    int32_t ret = iPackedFiles_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void un_pack_files_ex(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_MULTI_FILE);
                    IUnPackFilesEx_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void un_pack_files_to_folder(int32_t param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_MULTI_FILE);
                    IUnPackFilesToFolder_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                void pack_files()
                {
                    PackFiles_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void render(const gx_string_type& param1)
                {
                    Render_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void resize_all()
                {
                    ResizeAll_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void resize_all_ex(MVIEW_EXTENT param1)
                {
                    ResizeAllEx_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                double get_map_scale()
                {
                    double ret = rGetMapScale_MAP(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void save_as_mxd(const gx_string_type& param1)
                {
                    SaveAsMXD_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_class_name(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SetClassName_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_current()
                {
                    App_SetCurrent_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void set_map_name(const gx_string_type& param1)
                {
                    SetMapName_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_map_scale(double param1)
                {
                    SetMapScale_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_map_size(double param1, double param2, double param3, double param4)
                {
                    SetMapSize_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_reg(GXREGPtr param1)
                {
                    SetREG_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void sync(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sync_MAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                void un_pack_files()
                {
                    UnPackFiles_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void view_list(GXLSTPtr param1)
                {
                    ViewList_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void view_list_ex(GXLSTPtr param1, MAP_LIST_MODE param2)
                {
                    ViewListEx_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                int32_t get_data_proj()
                {
                    int32_t ret = GetDataProj_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXMAPL
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMAPL(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMAPLPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMAPL>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXMAPLPtr create(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MAPL(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAPL>(ret);
                }

                static GXMAPLPtr create_reg(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, GXREGPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateREG_MAPL(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAPL>(ret);
                }

                ~GXMAPL()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MAPL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void process(GXMAPPtr param1)
                {
                    Process_MAPL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void replace_string(const gx_string_type& param1, const gx_string_type& param2)
                {
                    ReplaceString_MAPL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXMAPTEMPLATE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMAPTEMPLATE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMAPTEMPLATEPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMAPTEMPLATE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void get_tmp_copy(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    GetTmpCopy_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void update_from_tmp_copy(const gx_string_type& param1)
                {
                    UpdateFromTmpCopy_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void commit()
                {
                    Commit_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                static GXMAPTEMPLATEPtr create(const gx_string_type& param1, const gx_string_type& param2, MAPTEMPLATE_OPEN param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MAPTEMPLATE(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAPTEMPLATE>(ret);
                }

                ~GXMAPTEMPLATE()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void discard()
                {
                    Discard_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void get_file_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    GetFileName_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void create_map(const gx_string_type& param1, const gx_string_type& param2)
                {
                    CreateMap_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void refresh()
                {
                    Refresh_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void render_preview(HDC param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    RenderPreview_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1, reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                void render_preview_map_production(HDC param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5)
                {
                    RenderPreviewMapProduction_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1, reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                }


            };
            class GXMATH
            {
            private:
                GXMATH();
                ~GXMATH();
            public:


                static void cross_product_(double param1, double param2, double param3, double param4, double param5, double param6, double& param7, double& param8, double& param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CrossProduct_MATH(
                        gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                static int32_t abs_int_(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iAbs_MATH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t and_(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iAnd_MATH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t mod_int_(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iMod_MATH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t or_(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iOr_MATH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t round_int_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRound_MATH(
                                      gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t xor_(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iXor_MATH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static void nicer_log_scale_(double& param1, double& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NicerLogScale_MATH(
                        gx_->pGeo, &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void nicer_scale_(double& param1, double& param2, double& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NicerScale_MATH(
                        gx_->pGeo, &param1, &param2, &param3, reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }

                static void normalise_3d_(double& param1, double& param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Normalise3D_MATH(
                        gx_->pGeo, &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                static double abs_double_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rAbs_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double arc_cos_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rArcCos_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double arc_sin_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rArcSin_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double arc_tan_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rArcTan_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double arc_tan2_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rArcTan2_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }

                static double ceil_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rCeil_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double cos_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rCos_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double dot_product_3d_(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rDotProduct3D_MATH(
                                     gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                    return ret;
                }

                static double exp_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rExp_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double floor_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rFloor_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double hypot_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rHypot_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }

                static double lambda_trans_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLambdaTrans_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }

                static double lambda_trans_rev_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLambdaTransRev_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }

                static double log_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLog_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double log10_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLog10_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double log_z_(double param1, int32_t param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLogZ_MATH(
                                     gx_->pGeo, &param1, reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                    return ret;
                }

                static double mod_double_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rMod_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }

                static void rotate_vector_(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double& param8, double& param9, double& param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RotateVector_MATH(
                        gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }

                static double pow_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rPow_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }

                static double rand_()
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rRand_MATH(
                                     gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static double round_double_(double param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rRound_MATH(
                                     gx_->pGeo, &param1, reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static double sign_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rSign_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }

                static double sin_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rSin_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double sqrt_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rSqrt_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double tan_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rTan_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double un_log_z_(double param1, int32_t param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUnLogZ_MATH(
                                     gx_->pGeo, &param1, reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                    return ret;
                }

                static void s_rand_()
                {
                    GXContextPtr gx_ = GXContext::current();
                    SRand_MATH(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }


            };
            class GXMETA
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMETA(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMETAPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMETA>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                int32_t create_attrib(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    int32_t ret = CreateAttrib_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                void delete_attrib(int32_t param1)
                {
                    DeleteAttrib_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_attribute_editable(int32_t param1, int32_t param2)
                {
                    SetAttributeEditable_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_attribute_visible(int32_t param1, int32_t param2)
                {
                    SetAttributeVisible_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                int32_t create_class(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = CreateClass_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void delete_class(int32_t param1)
                {
                    DeleteClass_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void copy(GXMETAPtr param1)
                {
                    Copy_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXMETAPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_META(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMETA>(ret);
                }

                static GXMETAPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMETA>(ret);
                }

                ~GXMETA()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void serial(GXBFPtr param1)
                {
                    Serial_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                int32_t find_data(int32_t param1, int32_t param2)
                {
                    int32_t ret = FindData_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_attrib_bool(int32_t param1, int32_t param2, int32_t& param3)
                {
                    GetAttribBool_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }

                void get_attrib_enum(int32_t param1, int32_t param2, int32_t& param3)
                {
                    GetAttribEnum_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }

                void get_attrib_int(int32_t param1, int32_t param2, int32_t& param3)
                {
                    GetAttribInt_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }

                void get_attrib_double(int32_t param1, int32_t param2, double& param3)
                {
                    GetAttribReal_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }

                void get_attrib_string(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    IGetAttribString_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                bool has_value(int32_t param1, int32_t param2)
                {
                    bool ret = 0 != iHasValue_META(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void export_table_csv(int32_t param1, const gx_string_type& param2)
                {
                    ExportTableCSV_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void import_table_csv(int32_t param1, const gx_string_type& param2)
                {
                    ImportTableCSV_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void write_text(GXWAPtr param1)
                {
                    WriteText_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void delete_all_items(int32_t param1)
                {
                    DeleteAllItems_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void delete_item(int32_t param1)
                {
                    DeleteItem_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                int32_t h_creat_item(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = hCreatItem_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t h_get_next_item(int32_t param1, int32_t param2)
                {
                    int32_t ret = hGetNextItem_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_attrib_obj(int32_t param1, int32_t param2, int32_t param3)
                {
                    GetAttribOBJ_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void set_attrib_obj(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetAttribOBJ_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void set_attrib_bool(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetAttribBool_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void set_attrib_enum(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetAttribEnum_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void set_attrib_int(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetAttribInt_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void set_attrib_double(int32_t param1, int32_t param2, double param3)
                {
                    SetAttribReal_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }

                void set_attrib_string(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    SetAttribString_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                void set_empty_attrib(int32_t param1, int32_t param2)
                {
                    SetEmptyAttrib_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                int32_t h_copy_across_attribute(GXMETAPtr param1, int32_t param2)
                {
                    int32_t ret = hCopyAcrossAttribute_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t h_copy_across_class(GXMETAPtr param1, int32_t param2)
                {
                    int32_t ret = hCopyAcrossClass_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t h_copy_across_data(GXMETAPtr param1, int32_t param2)
                {
                    int32_t ret = hCopyAcrossData_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t h_copy_across_item(GXMETAPtr param1, int32_t param2)
                {
                    int32_t ret = hCopyAcrossItem_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t h_copy_across_type(GXMETAPtr param1, int32_t param2)
                {
                    int32_t ret = hCopyAcrossType_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void move_datas_across(GXMETAPtr param1, int32_t param2, int32_t param3)
                {
                    MoveDatasAcross_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                int32_t create_type(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    int32_t ret = CreateType_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                void delete_data(int32_t param1)
                {
                    DeleteData_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void delete_type(int32_t param1)
                {
                    DeleteType_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void get_obj_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    IGetObjName_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t resolve_umn(const gx_string_type& param1)
                {
                    int32_t ret = ResolveUMN_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXMVIEW
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMVIEW(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMVIEWPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMVIEW>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void box_3d(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    Box3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void crc_view(int32_t& param1, const gx_string_type& param2)
                {
                    CRCView_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void crc_view_group(const gx_string_type& param1, int32_t& param2, const gx_string_type& param3)
                {
                    CRCViewGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                void cylinder_3d(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, MVIEW_CYLINDER3D param9)
                {
                    Cylinder3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                void draw_object_3d(MVIEW_DRAWOBJ3D_ENTITY param1, MVIEW_DRAWOBJ3D_MODE param2, int32_t param3, int32_t param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, GXVVPtr param13)
                {
                    DrawObject3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)));
                    gx_->throw_on_error();
                }

                void draw_surface_3d_ex(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, int32_t param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, GXIPJPtr param13)
                {
                    DrawSurface3DEx_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)));
                    gx_->throw_on_error();
                }

                void draw_surface_3d_from_file(const gx_string_type& param1, const gx_string_type& param2)
                {
                    DrawSurface3DFromFile_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void font_weight_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FontWeightLST_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_agg_file_names(const gx_string_type& param1, GXVVPtr param2)
                {
                    GetAGGFileNames_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                GXMETAPtr get_meta(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    int32_t ret = IGetMeta_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return gx_->createPtr<GXMETA>(ret);
                }

                void measure_text(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    MeasureText_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void point_3d(double param1, double param2, double param3)
                {
                    Point3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                void poly_line_3d(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    PolyLine3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void relocate_group(const gx_string_type& param1, double param2, double param3, double param4, double param5, MVIEW_RELOCATE param6)
                {
                    RelocateGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                void set_meta(const gx_string_type& param1, GXMETAPtr param2, const gx_string_type& param3)
                {
                    SetMeta_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }

                void sphere_3d(double param1, double param2, double param3, double param4)
                {
                    Sphere3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void update_met_afrom_group(const gx_string_type& param1, GXMETAPtr param2)
                {
                    UpdateMETAfromGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void delete_plane(int32_t param1, int32_t param2)
                {
                    DeletePlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void get_plane_clip_ply(int32_t param1, GXPLYPtr param2)
                {
                    GetPlaneClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_plane_equation(int32_t param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10)
                {
                    GetPlaneEquation_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }

                void get_view_plane_equation(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9)
                {
                    GetViewPlaneEquation_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                int32_t create_plane(const gx_string_type& param1)
                {
                    int32_t ret = iCreatePlane_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_plane(const gx_string_type& param1)
                {
                    int32_t ret = iFindPlane_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_def_plane(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetDefPlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                int32_t is_view_3d()
                {
                    int32_t ret = iIsView3D_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_section()
                {
                    int32_t ret = iIsSection_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void list_plane_groups(int32_t param1, GXLSTPtr param2)
                {
                    ListPlaneGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void list_planes(GXLSTPtr param1)
                {
                    ListPlanes_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_all_groups_to_plane(int32_t param1)
                {
                    SetAllGroupsToPlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_all_new_groups_to_plane(int32_t param1)
                {
                    SetAllNewGroupsToPlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_def_plane(const gx_string_type& param1)
                {
                    SetDefPlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_group_to_plane(int32_t param1, const gx_string_type& param2)
                {
                    SetGroupToPlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_h_3dn(GX3DNPtr param1)
                {
                    SetH3DN_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_plane_clip_ply(int32_t param1, GXPLYPtr param2)
                {
                    SetPlaneClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void set_plane_equation(int32_t param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10)
                {
                    SetPlaneEquation_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }

                void set_plane_surface(int32_t param1, const gx_string_type& param2)
                {
                    SetPlaneSurface_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_plane_surf_info(int32_t param1, int32_t param2, double param3, double param4, double param5, double param6)
                {
                    SetPlaneSurfInfo_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void define_plane_3d(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9)
                {
                    DefinePlane3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                void define_viewer_axis_3d(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    DefineViewerAxis3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void define_viewer_plane_3d(double param1, double param2, double param3)
                {
                    DefineViewerPlane3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                void clip_poly_ex(GXVVPtr param1, GXVVPtr param2, MVIEW_UNIT param3, int32_t param4)
                {
                    _ClipPolyEx_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void clip_rect_ex(double param1, double param2, double param3, double param4, MVIEW_UNIT param5, int32_t param6)
                {
                    _ClipRectEx_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                void clip_clear()
                {
                    ClipClear_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void clip_groups(MVIEW_CLIP param1)
                {
                    ClipGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void clip_marked_groups(MVIEW_CLIP param1)
                {
                    ClipMarkedGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void clip_poly(GXVVPtr param1, GXVVPtr param2, MVIEW_UNIT param3)
                {
                    ClipPoly_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void clip_rect(double param1, double param2, double param3, double param4, MVIEW_UNIT param5)
                {
                    ClipRect_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                void delete_ext_clip_ply(int32_t param1)
                {
                    DeleteExtClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void ext_clip_ply_list(GXLSTPtr param1)
                {
                    ExtClipPLYList_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_clip_ply(GXPLYPtr param1)
                {
                    GetClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_ext_clip_ply(int32_t param1, GXPLYPtr param2)
                {
                    GetExtClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_group_ext_clip_ply(const gx_string_type& param1, int32_t& param2)
                {
                    GetGroupExtClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }

                void get_ply(GXPLYPtr param1)
                {
                    GetPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void group_clip_mode(MVIEW_CLIP param1)
                {
                    GroupClipMode_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void get_name_ext_clip_ply(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetNameExtClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t num_ext_clip_ply()
                {
                    int32_t ret = iNumExtClipPLY_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t set_ext_clip_ply(int32_t param1, const gx_string_type& param2, GXPLYPtr param3)
                {
                    int32_t ret = iSetExtClipPLY_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_clip_ply(GXPLYPtr param1)
                {
                    SetClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_group_ext_clip_ply(const gx_string_type& param1, int32_t param2)
                {
                    SetGroupExtClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void color2_rgb(int32_t param1, int32_t& param2, int32_t& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Color2RGB_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }

                static void color_descr(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    ColorDescr_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static int32_t color(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iColor_MVIEW(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t color_cmy(int32_t param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iColorCMY_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t color_hsv(int32_t param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iColorHSV_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t color_rgb(int32_t param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iColorRGB_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                void clip_mode(MVIEW_CLIP param1)
                {
                    ClipMode_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void fill_color(int32_t param1)
                {
                    FillColor_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void line_color(int32_t param1)
                {
                    LineColor_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void line_smooth(MVIEW_SMOOTH param1)
                {
                    LineSmooth_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void line_style(int32_t param1, double param2)
                {
                    LineStyle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void line_thick(double param1)
                {
                    LineThick_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void pat_angle(double param1)
                {
                    PatAngle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void pat_density(double param1)
                {
                    PatDensity_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void pat_number(int32_t param1)
                {
                    PatNumber_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void pat_size(double param1)
                {
                    PatSize_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void pat_style(MVIEW_TILE param1)
                {
                    PatStyle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void pat_thick(double param1)
                {
                    PatThick_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void symb_angle(double param1)
                {
                    SymbAngle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void symb_color(int32_t param1)
                {
                    SymbColor_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void symb_fill_color(int32_t param1)
                {
                    SymbFillColor_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void symb_font(const gx_string_type& param1, bool param2, MVIEW_FONT_WEIGHT param3, bool param4)
                {
                    long paramBool2 = param2 ? 1 : 0;
                    long paramBool4 = param4 ? 1 : 0;
                    SymbFont_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &paramBool2, reinterpret_cast<const long*>(&param3), &paramBool4);
                    gx_->throw_on_error();
                }

                void symb_number(int32_t param1)
                {
                    SymbNumber_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void symb_size(double param1)
                {
                    SymbSize_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void text_angle(double param1)
                {
                    TextAngle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void text_color(int32_t param1)
                {
                    TextColor_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void text_font(const gx_string_type& param1, int32_t param2, MVIEW_FONT_WEIGHT param3, int32_t param4)
                {
                    TextFont_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void text_ref(TEXT_REF param1)
                {
                    TextRef_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void text_size(double param1)
                {
                    TextSize_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void transparency(double param1)
                {
                    Transparency_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void z_value(double param1)
                {
                    ZValue_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void arc(double param1, double param2, double param3, double param4, double param5, double param6, double param7)
                {
                    Arc_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }

                void chord(double param1, double param2, double param3, double param4, double param5, double param6, double param7)
                {
                    Chord_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }

                void classified_symbols(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    ClassifiedSymbols_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, param6.c_str(), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }

                void complex_polygon(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    ComplexPolygon_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void ellipse(double param1, double param2, double param3, double param4, double param5)
                {
                    Ellipse_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void line(double param1, double param2, double param3, double param4)
                {
                    Line_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void line_vv(GXVVPtr param1)
                {
                    LineVV_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void polygon_dm(GXVVPtr param1, GXVVPtr param2)
                {
                    PolygonDm_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void polygon_ply(GXPLYPtr param1)
                {
                    PolygonPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void poly_line(MVIEW_DRAW param1, GXVVPtr param2, GXVVPtr param3)
                {
                    PolyLine_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void poly_line_dm(GXVVPtr param1, GXVVPtr param2)
                {
                    PolyLineDm_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void poly_wrap(GXVVPtr param1, GXVVPtr param2)
                {
                    PolyWrap_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void rectangle(double param1, double param2, double param3, double param4)
                {
                    Rectangle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void segment(double param1, double param2, double param3, double param4, double param5, double param6, double param7)
                {
                    Segment_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }

                void size_symbols(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    SizeSymbols_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void symbol(double param1, double param2)
                {
                    Symbol_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void symbols(GXVVPtr param1, GXVVPtr param2)
                {
                    Symbols_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void symbols_itr(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    SymbolsITR_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void text(const gx_string_type& param1, double param2, double param3)
                {
                    Text_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                }

                void aggregate(GXAGGPtr param1, const gx_string_type& param2)
                {
                    Aggregate_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void change_line_message(const gx_string_type& param1)
                {
                    ChangeLineMessage_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void col_symbol(const gx_string_type& param1, GXCSYMBPtr param2)
                {
                    ColSymbol_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void datalinkd(GXDATALINKDPtr param1, const gx_string_type& param2)
                {
                    DATALINKD_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void easy_maker(const gx_string_type& param1, const gx_string_type& param2)
                {
                    EasyMaker_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void emf_object(double param1, double param2, double param3, double param4, const gx_string_type& param5)
                {
                    EMFObject_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, param5.c_str());
                    gx_->throw_on_error();
                }

                void external_string_object(double param1, double param2, double param3, double param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7)
                {
                    ExternalStringObject_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, param5.c_str(), param6.c_str(), param7.c_str());
                    gx_->throw_on_error();
                }

                void link(GXDBPtr param1, const gx_string_type& param2)
                {
                    Link_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void maker(int32_t param1, int32_t param2, const gx_string_type& param3, MAKER param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    Maker_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }

                void meta(GXMETAPtr param1, const gx_string_type& param2)
                {
                    Meta_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void voxd(GXVOXDPtr param1, const gx_string_type& param2)
                {
                    VOXD_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                GXVOXDPtr get_voxd(int32_t param1)
                {
                    int32_t ret = GetVOXD_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOXD>(ret);
                }

                void draw_vector_voxel_vectors(GXVOXPtr param1, const gx_string_type& param2, GXITRPtr param3, double param4, double param5, double param6, double param7, int32_t param8)
                {
                    DrawVectorVoxelVectors_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                void draw_vectors_3d(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXITRPtr param8, double param9, double param10, double param11)
                {
                    DrawVectors3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), &param9, &param10, &param11);
                    gx_->throw_on_error();
                }

                void copy_marked_groups(GXMVIEWPtr param1)
                {
                    CopyMarkedGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void copy_raw_marked_groups(GXMVIEWPtr param1)
                {
                    CopyRawMarkedGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                int32_t crc_group(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = CRCGroup_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void delete_group(const gx_string_type& param1)
                {
                    DeleteGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void del_marked_groups()
                {
                    DelMarkedGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void get_group_extent(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, MVIEW_UNIT param6)
                {
                    GetGroupExtent_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                void get_group_transparency(const gx_string_type& param1, double& param2)
                {
                    GetGroupTransparency_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }

                void group_to_ply(const gx_string_type& param1, GXPLYPtr param2)
                {
                    GroupToPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void hide_marked_groups(MVIEW_HIDE param1)
                {
                    HideMarkedGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void hide_shadow2_d_interpretations(MVIEW_HIDE param1)
                {
                    HideShadow2DInterpretations_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                int32_t exist_group(const gx_string_type& param1)
                {
                    int32_t ret = iExistGroup_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void gen_new_group_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_GROUP * STRING_CHAR_SIZE;
                    param2.resize(STR_GROUP);
                    IGenNewGroupName_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t is_group(const gx_string_type& param1, MVIEW_IS param2)
                {
                    int32_t ret = iIsGroup_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_group_empty(const gx_string_type& param1)
                {
                    int32_t ret = iIsGroupEmpty_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                bool is_movable()
                {
                    bool ret = 0 != iIsMovable_MVIEW(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                bool is_visible()
                {
                    bool ret = 0 != iIsVisible_MVIEW(
                                   gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t list_groups(GXLSTPtr param1, MVIEW_GROUP_LIST param2)
                {
                    int32_t ret = iListGroups_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t render_order()
                {
                    int32_t ret = iRenderOrder_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void mark_all_groups(int32_t param1)
                {
                    MarkAllGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void mark_empty_groups(int32_t param1)
                {
                    MarkEmptyGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void mark_group(const gx_string_type& param1, int32_t param2)
                {
                    MarkGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void move_group_backward(const gx_string_type& param1)
                {
                    MoveGroupBackward_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void move_group_forward(const gx_string_type& param1)
                {
                    MoveGroupForward_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void move_group_to_back(const gx_string_type& param1)
                {
                    MoveGroupToBack_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void move_group_to_front(const gx_string_type& param1)
                {
                    MoveGroupToFront_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void rename_group(const gx_string_type& param1, const gx_string_type& param2)
                {
                    RenameGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_group_moveable(const gx_string_type& param1, int32_t param2)
                {
                    SetGroupMoveable_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_group_transparency(const gx_string_type& param1, double param2)
                {
                    SetGroupTransparency_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }

                void set_mark_moveable(int32_t param1)
                {
                    SetMarkMoveable_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_movability(bool param1)
                {
                    long paramBool1 = param1 ? 1 : 0;
                    SetMovability_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &paramBool1);
                    gx_->throw_on_error();
                }

                void set_render_order(int32_t param1)
                {
                    SetRenderOrder_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_visibility(bool param1)
                {
                    long paramBool1 = param1 ? 1 : 0;
                    SetVisibility_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &paramBool1);
                    gx_->throw_on_error();
                }

                void start_group(const gx_string_type& param1, MVIEW_GROUP param2)
                {
                    StartGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_working_ipj(GXIPJPtr param1)
                {
                    _SetWorkingIPJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void clear_esrild_ts()
                {
                    ClearESRILDTs_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                int32_t is_projection_empty()
                {
                    int32_t ret = iIsProjectionEmpty_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_user_ipj(GXIPJPtr param1)
                {
                    GetUserIPJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void mode_pj(MVIEW_PJ param1)
                {
                    ModePJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                double north()
                {
                    double ret = rNorth_MVIEW(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_user_ipj(GXIPJPtr param1)
                {
                    SetUserIPJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                MVIEW_3D_RENDER get_3d_group_flags(int32_t param1)
                {
                    MVIEW_3D_RENDER ret = (MVIEW_3D_RENDER)iGet3DGroupFlags_MVIEW(
                                              gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_3d_group_flags(int32_t param1, MVIEW_3D_RENDER param2)
                {
                    Set3DGroupFlags_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void get_group_freeze_scale(int32_t param1, double& param2)
                {
                    _GetGroupFreezeScale_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void set_freeze_scale(double param1)
                {
                    _SetFreezeScale_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_group_freeze_scale(int32_t param1, double param2)
                {
                    _SetGroupFreezeScale_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                int32_t find_group(const gx_string_type& param1)
                {
                    int32_t ret = iFindGroup_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void group_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGroupName_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void render(HDC param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7, double param8, double param9)
                {
                    Render_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1, reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                void set_u_fac(double param1)
                {
                    _SetUFac_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void axis_x(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    AxisX_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void axis_y(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    AxisY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void grid(double param1, double param2, double param3, double param4, MVIEW_GRID param5)
                {
                    Grid_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                void label_fid(GXVVPtr param1, double param2, double param3, double param4, double param5, double param6)
                {
                    LabelFid_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void label_x(double param1, double param2, double param3, double param4, MVIEW_LABEL_JUST param5, MVIEW_LABEL_BOUND param6, MVIEW_LABEL_ORIENT param7)
                {
                    LabelX_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                void label_y(double param1, double param2, double param3, double param4, MVIEW_LABEL_JUST param5, MVIEW_LABEL_BOUND param6, MVIEW_LABEL_ORIENT param7)
                {
                    LabelY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void optimum_tick(double param1, double param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OptimumTick_MVIEW(
                        gx_->pGeo, &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                static GXMVIEWPtr create(GXMAPPtr param1, const gx_string_type& param2, MVIEW_OPEN param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }

                static GXMVIEWPtr create_crooked_section(GXMAPPtr param1, GXIPJPtr param2, const gx_string_type& param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateCrookedSection_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }

                static GXMVIEWPtr create_crooked_section_data_profile(GXMAPPtr param1, GXIPJPtr param2, const gx_string_type& param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, int32_t param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateCrookedSectionDataProfile_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }

                ~GXMVIEW()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void extent(MVIEW_EXTENT param1, MVIEW_EXTENT_UNIT param2, double& param3, double& param4, double& param5, double& param6)
                {
                    Extent_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                GXMAPPtr get_map()
                {
                    int32_t ret = GetMAP_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAP>(ret);
                }

                GXREGPtr get_reg()
                {
                    int32_t ret = GetREG_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }

                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VIEW * STRING_CHAR_SIZE;
                    param1.resize(STR_VIEW);
                    IGetName_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void plot_to_view(double& param1, double& param2)
                {
                    _PlotToView_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void set_thin_res(double param1)
                {
                    _SetThinRes_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void view_to_plot(double& param1, double& param2)
                {
                    _ViewToPlot_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void best_fit_window(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, MVIEW_FIT param9)
                {
                    BestFitWindow_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                void fit_map_window_3d(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8)
                {
                    FitMapWindow3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }

                void fit_window(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8)
                {
                    FitWindow_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }

                void get_class_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetClassName_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void map_origin(double& param1, double& param2)
                {
                    MapOrigin_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void re_scale(double param1)
                {
                    ReScale_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                double get_map_scale()
                {
                    double ret = rGetMapScale_MVIEW(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double scale_mm()
                {
                    double ret = rScaleMM_MVIEW(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double scale_pj_mm()
                {
                    double ret = rScalePjMM_MVIEW(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double scale_ymm()
                {
                    double ret = rScaleYMM_MVIEW(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void scale_all_group(double param1, double param2)
                {
                    ScaleAllGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void scale_window(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8)
                {
                    ScaleWindow_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }

                void set_class_name(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SetClassName_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_window(double param1, double param2, double param3, double param4, MVIEW_UNIT param5)
                {
                    SetWindow_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                void tran_scale(double param1, double param2, double param3, double param4)
                {
                    TranScale_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void user_to_view(double& param1, double& param2)
                {
                    UserToView_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void view_to_user(double& param1, double& param2)
                {
                    ViewToUser_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }


            };
            class GXMVU
            {
            private:
                GXMVU();
                ~GXMVU();
            public:


                static void arrow(GXMVIEWPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, MVU_ARROW param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Arrow_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void arrow_vector_vv(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, double param6, MVU_VPOS param7, MVU_VSIZE param8, MVU_VSTYLE param9, MVU_VPOINT param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ArrowVectorVV_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11);
                    gx_->throw_on_error();
                }

                static void bar_chart(GXMVIEWPtr param1, const gx_string_type& param2, GXDBPtr param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, double param8, const gx_string_type& param9, double param10, const gx_string_type& param11, double param12, double param13, int32_t param14, BARCHART_LABEL param15, int32_t param16, int32_t param17, int32_t param18, int32_t param19, int32_t param20, double param21, double param22, double param23, double param24, double param25, double param26, double param27, double param28)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BarChart_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), param7.c_str(), &param8, param9.c_str(), &param10, param11.c_str(), &param12, &param13, reinterpret_cast<const long*>(&param14), reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20), &param21, &param22, &param23, &param24, &param25, &param26, &param27, &param28);
                    gx_->throw_on_error();
                }

                static void cdi_pixel_plot(GXMVIEWPtr param1, const gx_string_type& param2, GXVAPtr param3, GXVAPtr param4, GXVVPtr param5, GXITRPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CDIPixelPlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                static void cdi_pixel_plot_3d(GXMVIEWPtr param1, const gx_string_type& param2, GXVAPtr param3, GXVAPtr param4, GXVVPtr param5, GXVVPtr param6, GXITRPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CDIPixelPlot3D_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void color_bar(GXMVIEWPtr param1, GXITRPtr param2, int32_t param3, double param4, double param5, double param6, double param7, double param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBar_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }

                static void color_bar2(GXMVIEWPtr param1, GXITRPtr param2, GXITRPtr param3, int32_t param4, double param5, double param6, double param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBar2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                static void color_bar2_style(GXMVIEWPtr param1, GXITRPtr param2, GXITRPtr param3, int32_t param4, double param5, double param6, double param7, double param8, double param9, COLORBAR_STYLE param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBar2Style_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

                static void color_bar_hor(GXMVIEWPtr param1, GXITRPtr param2, int32_t param3, double param4, double param5, double param6, double param7, double param8, COLORBAR_LABEL param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarHor_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                static void color_bar_hor2(GXMVIEWPtr param1, GXITRPtr param2, GXITRPtr param3, int32_t param4, double param5, double param6, double param7, double param8, double param9, COLORBAR_LABEL param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarHor2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

                static void color_bar_hor2_style(GXMVIEWPtr param1, GXITRPtr param2, GXITRPtr param3, int32_t param4, double param5, double param6, double param7, double param8, double param9, COLORBAR_STYLE param10, COLORBAR_LABEL param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarHor2Style_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }

                static void color_bar_hor_style(GXMVIEWPtr param1, GXITRPtr param2, int32_t param3, double param4, double param5, double param6, double param7, double param8, COLORBAR_STYLE param9, COLORBAR_LABEL param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarHorStyle_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

                static void color_bar_style(GXMVIEWPtr param1, GXITRPtr param2, int32_t param3, double param4, double param5, double param6, double param7, double param8, COLORBAR_STYLE param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarStyle_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                static void color_bar_reg(GXMVIEWPtr param1, GXITRPtr param2, GXITRPtr param3, GXREGPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarREG_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void contour(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Contour_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void contour_ply(GXMVIEWPtr param1, GXPLYPtr param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ContourPLY_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                static void c_symb_legend(GXMVIEWPtr param1, double param2, double param3, double param4, double param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CSymbLegend_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, param6.c_str(), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }

                static void decay_curve(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVAPtr param4, GXVAPtr param5, int32_t param6, double param7, double param8, int32_t param9, int32_t param10, double param11, double param12, double param13, double param14, double param15, double param16, double param17, double param18, double param19, int32_t param20, const gx_string_type& param21)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DecayCurve_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, &param19, reinterpret_cast<const long*>(&param20), param21.c_str());
                    gx_->throw_on_error();
                }

                static void direction_plot(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, ARROW_ALIGNMENT param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectionPlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void em_forward(GXMVIEWPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, EMLAY_GEOMETRY param8, double param9, double param10, double param11, double param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15, GXVVPtr param16, int32_t param17, int32_t param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EMForward_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), &param9, &param10, &param11, &param12, reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&gx_->handle(param16)), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18));
                    gx_->throw_on_error();
                }

                static void export_datamine_string(GXMVIEWPtr param1, GXLSTPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportDatamineString_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }

                static void export_dxf_3d(GXMVIEWPtr param1, GXLSTPtr param2, GXWAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportDXF3D_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void export_surpac_str(GXMVIEWPtr param1, GXLSTPtr param2, GXWAPtr param3, GXWAPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportSurpacSTR_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static void flight_plot(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, const gx_string_type& param4, MVU_FLIGHT_LOCATE param5, double param6, int32_t param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FlightPlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&param7), &param8, &param9);
                    gx_->throw_on_error();
                }

                static void gen_areas(GXMVIEWPtr param1, const gx_string_type& param2, GXVVPtr param3, GXVVPtr param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenAreas_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5);
                    gx_->throw_on_error();
                }

                static void get_range_gocad_surface(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetRangeGOCADSurface_MVU(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }

                static void histogram(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, int32_t param15, int32_t param16, int32_t param17, GXSTPtr param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Histogram_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&gx_->handle(param18)));
                    gx_->throw_on_error();
                }

                static void histogram2(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, double param6, const gx_string_type& param7, double param8, const gx_string_type& param9, double param10, double param11, double param12, double param13, double param14, double param15, double param16, double param17, double param18, int32_t param19, int32_t param20, int32_t param21, GXSTPtr param22, double param23)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Histogram2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), &param6, param7.c_str(), &param8, param9.c_str(), &param10, &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20), reinterpret_cast<const long*>(&param21), reinterpret_cast<const long*>(&gx_->handle(param22)), &param23);
                    gx_->throw_on_error();
                }

                static void histogram3(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, int32_t param15, int32_t param16, int32_t param17, int32_t param18, int32_t param19, GXSTPtr param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Histogram3_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&gx_->handle(param20)));
                    gx_->throw_on_error();
                }

                static void histogram4(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, int32_t param15, int32_t param16, int32_t param17, int32_t param18, int32_t param19, int32_t param20, GXSTPtr param21)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Histogram4_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20), reinterpret_cast<const long*>(&gx_->handle(param21)));
                    gx_->throw_on_error();
                }

                static void histogram5(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, double param15, int32_t param16, int32_t param17, int32_t param18, int32_t param19, int32_t param20, int32_t param21, GXSTPtr param22, GXITRPtr param23)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Histogram5_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20), reinterpret_cast<const long*>(&param21), reinterpret_cast<const long*>(&gx_->handle(param22)), reinterpret_cast<const long*>(&gx_->handle(param23)));
                    gx_->throw_on_error();
                }

                static int32_t exportable_dxf_3d_groups_lst(GXMVIEWPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iExportableDXF3DGroupsLST_MVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }

                static bool mapset_test(double param1, double param2, double param3, double param4, const gx_string_type& param5, int32_t param6, int32_t param7, double& param8, double param9, double param10, double param11, double param12, double param13, double param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != iMapsetTest_MVU(
                                   gx_->pGeo, &param1, &param2, &param3, &param4, param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, &param9, &param10, &param11, &param12, &param13, &param14);
                    gx_->throw_on_error();
                    return ret;
                }

                static bool mapset2_test(double param1, double param2, double param3, double param4, const gx_string_type& param5, int32_t param6, int32_t param7, double& param8, double param9, double param10, double param11, double param12, double param13, double param14, double param15)
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != iMapset2Test_MVU(
                                   gx_->pGeo, &param1, &param2, &param3, &param4, param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15);
                    gx_->throw_on_error();
                    return ret;
                }

                static void import_gocad_surface(GXMVIEWPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportGOCADSurface_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void load_plot(GXMAPPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadPlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void map_from_plt(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MapFromPLT_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), &param5, &param6);
                    gx_->throw_on_error();
                }

                static void map_mdf(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MapMDF_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void mapset(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, double param4, double param5, double param6, double param7, const gx_string_type& param8, int32_t param9, int32_t param10, double param11, double param12, double param13, double param14, double param15, double param16, double param17)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Mapset_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), &param4, &param5, &param6, &param7, param8.c_str(), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17);
                    gx_->throw_on_error();
                }

                static void mapset2(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, double param4, double param5, double param6, double param7, const gx_string_type& param8, int32_t param9, int32_t param10, double param11, double param12, double param13, double param14, double param15, double param16, double param17, double param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Mapset2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), &param4, &param5, &param6, &param7, param8.c_str(), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18);
                    gx_->throw_on_error();
                }

                static void mdf(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MDF_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                static void path_plot(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, const gx_string_type& param4, MVU_FLIGHT_LOCATE param5, double param6, int32_t param7, double param8, double param9, double param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PathPlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&param7), &param8, &param9, &param10);
                    gx_->throw_on_error();
                }

                static void path_plot_ex(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, const gx_string_type& param4, MVU_FLIGHT_LOCATE param5, MVU_FLIGHT_COMPASS param6, double param7, int32_t param8, double param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PathPlotEx_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), &param9, &param10, &param11);
                    gx_->throw_on_error();
                }

                static void path_plot_ex2(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, const gx_string_type& param4, MVU_FLIGHT_LOCATE param5, MVU_FLIGHT_COMPASS param6, double param7, int32_t param8, double param9, double param10, double param11, MVU_FLIGHT_DUMMIES param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PathPlotEx2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), &param9, &param10, &param11, reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }

                static void plot_voxel_surface(GXMVIEWPtr param1, GXVOXPtr param2, double param3, int32_t param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PlotVoxelSurface_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4), &param5);
                    gx_->throw_on_error();
                }

                static void plot_voxel_surface2(GXMVIEWPtr param1, GXVOXPtr param2, double param3, int32_t param4, double param5, double param6, const gx_string_type& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PlotVoxelSurface2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4), &param5, &param6, param7.c_str());
                    gx_->throw_on_error();
                }

                static void generate_surface_from_voxel(GXMVIEWPtr param1, GXVOXPtr param2, MVU_VOX_SURFACE_METHOD param3, MVU_VOX_SURFACE_OPTION param4, double param5, double param6, int32_t param7, double param8, double param9, const gx_string_type& param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenerateSurfaceFromVoxel_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, reinterpret_cast<const long*>(&param7), &param8, &param9, param10.c_str());
                    gx_->throw_on_error();
                }

                static void post(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, bool param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9, double param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool5 = param5 ? 1 : 0;
                    Post_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &paramBool5, reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10);
                    gx_->throw_on_error();
                }

                static void post_ex(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, bool param6, double param7, double param8, int32_t param9, int32_t param10, int32_t param11, double param12, double param13, int32_t param14, double param15, int32_t param16, double param17, int32_t param18, double param19, int32_t param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool6 = param6 ? 1 : 0;
                    PostEx_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), &paramBool6, &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), &param12, &param13, reinterpret_cast<const long*>(&param14), &param15, reinterpret_cast<const long*>(&param16), &param17, reinterpret_cast<const long*>(&param18), &param19, reinterpret_cast<const long*>(&param20));
                    gx_->throw_on_error();
                }

                static void probability(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, int32_t param15, int32_t param16, int32_t param17, GXITRPtr param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Probability_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&gx_->handle(param18)));
                    gx_->throw_on_error();
                }

                static void profile_plot(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, int32_t param6, double param7, double param8, double param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProfilePlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

                static void profile_plot_ex(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, int32_t param6, double param7, double param8, double param9, int32_t param10, int32_t param11, double param12, int32_t param13, const gx_string_type& param14, const gx_string_type& param15)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProfilePlotEx_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), &param12, reinterpret_cast<const long*>(&param13), param14.c_str(), param15.c_str());
                    gx_->throw_on_error();
                }

                static void prop_symb_legend(GXMVIEWPtr param1, double param2, double param3, double param4, double param5, double param6, int32_t param7, double param8, double param9, const gx_string_type& param10, const gx_string_type& param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PropSymbLegend_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7), &param8, &param9, param10.c_str(), param11.c_str());
                    gx_->throw_on_error();
                }

                static void re_gen_areas(GXMVIEWPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReGenAreas_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void symb_off(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SymbOff_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6);
                    gx_->throw_on_error();
                }

                static void text_box(GXMVIEWPtr param1, double param2, double param3, double param4, double param5, const gx_string_type& param6, double param7, MVU_TEXTBOX param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TextBox_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, param6.c_str(), &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void tick(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Tick_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }

                static void tick_ex(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TickEx_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }

                static void trnd_path(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TrndPath_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5);
                    gx_->throw_on_error();
                }


            };
            class GXMXD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMXD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMXDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMXD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static void create_metadata(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateMetadata_MXD(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void convert_to_map(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertToMap_MXD(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void sync(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sync_MXD(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXPAT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXPAT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXPATPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXPAT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXPATPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_PAT(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPAT>(ret);
                }

                ~GXPAT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_PAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GetLST_PAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }


            };
            class GXPG
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXPG(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXPGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXPG>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void copy(GXPGPtr param1)
                {
                    Copy_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void copy_subset(GXPGPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    CopySubset_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static GXPGPtr create(int32_t param1, int32_t param2, GS_TYPES param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }

                static GXPGPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }

                ~GXPG()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void dummy()
                {
                    Dummy_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                GS_TYPES e_type()
                {
                    GS_TYPES ret = (GS_TYPES)iEType_PG(
                                       gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t n_cols()
                {
                    int32_t ret = iNCols_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t n_rows()
                {
                    int32_t ret = iNRows_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t n_slices()
                {
                    int32_t ret = iNSlices_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void range(double& param1, double& param2)
                {
                    Range_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                double get(int32_t param1, int32_t param2)
                {
                    double ret = rGet_PG(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void read_col(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    ReadCol_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void read_row(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    ReadRow_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void re_allocate(int32_t param1, int32_t param2)
                {
                    ReAllocate_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void serial(GXBFPtr param1)
                {
                    Serial_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void statistics(GXSTPtr param1)
                {
                    Statistics_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void write_col(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WriteCol_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void write_row(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WriteRow_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void copy_subset_3d(GXPGPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9, int32_t param10)
                {
                    CopySubset3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

                static GXPGPtr create_3d(int32_t param1, int32_t param2, int32_t param3, GS_TYPES param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create3D_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }

                void read_col_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    ReadCol3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                void read_row_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    ReadRow3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                void read_trace_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    ReadTrace3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                void re_allocate_3d(int32_t param1, int32_t param2, int32_t param3)
                {
                    ReAllocate3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void write_col_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    WriteCol3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                void write_row_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    WriteRow3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                void write_trace_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    WriteTrace3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                void read_bf(GXBFPtr param1, PG_3D_DIR param2, PG_BF_CONV param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    ReadBF_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                void read_ra(GXRAPtr param1, PG_3D_DIR param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6)
                {
                    ReadRA_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str());
                    gx_->throw_on_error();
                }

                void write_bf(GXBFPtr param1, PG_3D_DIR param2, PG_BF_CONV param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    WriteBF_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                void write_wa(GXWAPtr param1, PG_3D_DIR param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6)
                {
                    WriteWA_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXPJ
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXPJ(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXPJPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXPJ>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clip_ply(double param1, double param2, double param3, double param4, double param5, GXPLYPtr param6)
                {
                    ClipPLY_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                void convert_vv(GXVVPtr param1, GXVVPtr param2)
                {
                    ConvertVV_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void convert_vv3(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    ConvertVV3_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void convert_xy(double& param1, double& param2)
                {
                    ConvertXY_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void convert_xy_from_xyz(double& param1, double& param2, double param3)
                {
                    ConvertXYFromXYZ_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                void convert_xyz(double& param1, double& param2, double& param3)
                {
                    ConvertXYZ_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                static GXPJPtr create(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_PJ(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPJ>(ret);
                }

                static GXPJPtr create_ipj(GXIPJPtr param1, GXIPJPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateIPJ_PJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPJ>(ret);
                }

                static GXPJPtr create_rectified(double param1, double param2, double param3, double param4, double param5, double param6, PJ_RECT param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateRectified_PJ(
                                      gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPJ>(ret);
                }

                ~GXPJ()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                PJ_ELEVATION elevation()
                {
                    PJ_ELEVATION ret = (PJ_ELEVATION)iElevation_PJ(
                                           gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_input_ll()
                {
                    int32_t ret = iIsInputLL_PJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_output_ll()
                {
                    int32_t ret = iIsOutputLL_PJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void project_bounding_rectangle(double& param1, double& param2, double& param3, double& param4)
                {
                    ProjectBoundingRectangle_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void project_bounding_rectangle2(double& param1, double& param2, double& param3, double& param4, double param5)
                {
                    ProjectBoundingRectangle2_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void project_bounding_rectangle_res(double& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    ProjectBoundingRectangleRes_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

                void project_bounding_rectangle_res2(double& param1, double& param2, double& param3, double& param4, double& param5, double param6)
                {
                    ProjectBoundingRectangleRes2_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void project_limited_bounding_rectangle(double param1, double param2, double param3, double param4, double& param5, double& param6, double& param7, double& param8)
                {
                    ProjectLimitedBoundingRectangle_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }

                void setup_ldt()
                {
                    SetupLDT_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }


            };
            class GXPLY
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXPLY(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXPLYPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXPLY>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_polygon(GXVVPtr param1, GXVVPtr param2)
                {
                    AddPolygon_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void add_polygon_ex(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    AddPolygonEx_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void change_ipj(GXIPJPtr param1)
                {
                    ChangeIPJ_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void clear()
                {
                    Clear_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void copy(GXPLYPtr param1)
                {
                    Copy_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXPLYPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_PLY(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPLY>(ret);
                }

                static GXPLYPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_PLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPLY>(ret);
                }

                ~GXPLY()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void extent(double& param1, double& param2, double& param3, double& param4)
                {
                    Extent_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_polygon(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    GetPolygon_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void get_polygon_ex(GXVVPtr param1, GXVVPtr param2, int32_t param3, int32_t& param4)
                {
                    GetPolygonEx_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }

                PLY_CLIP clip_area(double param1, double param2, double param3, double param4)
                {
                    PLY_CLIP ret = (PLY_CLIP)iClipArea_PLY(
                                       gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t clip_line_int(double param1, double param2, double param3, double param4, GXVVPtr param5, double param6, PLY_LINE_CLIP& param7)
                {
                    int32_t ret = iClipLineInt_PLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)), &param6, reinterpret_cast<long*>(&param7));
                    gx_->throw_on_error();
                    return ret;
                }

                PLY_CLIP clip_ply(GXPLYPtr param1, GXPLYPtr param2)
                {
                    PLY_CLIP ret = (PLY_CLIP)iClipPLY_PLY(
                                       gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_description(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IGetDescription_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                int32_t num_poly()
                {
                    int32_t ret = iNumPoly_PLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void load_table(const gx_string_type& param1)
                {
                    LoadTable_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                double area()
                {
                    double ret = rArea_PLY(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void rectangle(double param1, double param2, double param3, double param4)
                {
                    Rectangle_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void rotate(double param1, double param2, double param3)
                {
                    Rotate_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                void save_table(const gx_string_type& param1)
                {
                    SaveTable_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void serial(GXBFPtr param1)
                {
                    Serial_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_description(const gx_string_type& param1)
                {
                    SetDescription_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void thin(double param1)
                {
                    Thin_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }


            };
            class GXRA
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXRA(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXRAPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXRA>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXRAPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_RA(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXRA>(ret);
                }

                static GXRAPtr create_sbf(GXSBFPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateSBF_RA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXRA>(ret);
                }

                ~GXRA()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_RA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t gets(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    int32_t ret = IiGets_RA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }

                int32_t len()
                {
                    int32_t ret = iLen_RA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t line()
                {
                    int32_t ret = iLine_RA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t seek(int32_t param1)
                {
                    int32_t ret = iSeek_RA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXREG
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXREG(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXREGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXREG>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear()
                {
                    Clear_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void copy(GXREGPtr param1)
                {
                    Copy_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXREGPtr create(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_REG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }

                static GXREGPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_REG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }

                ~GXREG()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    Get_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void get_int(const gx_string_type& param1, int32_t& param2)
                {
                    GetInt_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }

                void get_one(int32_t param1, gx_string_type& param2, gx_string_type& param3)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    param3.resize(STR_VERY_LONG);
                    GetOne_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }

                void get_double(const gx_string_type& param1, double& param2)
                {
                    GetReal_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }

                int32_t entries()
                {
                    int32_t ret = iEntries_REG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void load_ini(const gx_string_type& param1)
                {
                    LoadINI_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void match_string(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    MatchString_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                void merge(GXREGPtr param1, REG_MERGE param2)
                {
                    Merge_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void save_ini(const gx_string_type& param1)
                {
                    SaveINI_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void serial(GXBFPtr param1)
                {
                    Serial_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set(const gx_string_type& param1, const gx_string_type& param2)
                {
                    Set_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_int(const gx_string_type& param1, int32_t param2)
                {
                    SetInt_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_double(const gx_string_type& param1, double param2)
                {
                    SetReal_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }


            };
            class GXSBF
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSBF(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSBFPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSBF>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                GXSBFPtr create(const gx_string_type& param1, SBF_OPEN param2)
                {
                    int32_t ret = Create_SBF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSBF>(ret);
                }

                void create_obj_list(GXLSTPtr param1, SBF_TYPE param2)
                {
                    CreateObjList_SBF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void del_dir(const gx_string_type& param1)
                {
                    DelDir_SBF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void del_file(const gx_string_type& param1)
                {
                    DelFile_SBF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                ~GXSBF()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_SBF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                static GXSBFPtr h_get_db(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hGetDB_SBF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSBF>(ret);
                }

                static GXSBFPtr h_get_map(GXMAPPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hGetMAP_SBF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSBF>(ret);
                }

                static GXSBFPtr h_get_sys()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hGetSYS_SBF(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSBF>(ret);
                }

                int32_t exist_dir(const gx_string_type& param1)
                {
                    int32_t ret = iExistDir_SBF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t exist_file(const gx_string_type& param1)
                {
                    int32_t ret = iExistFile_SBF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void save_log(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    SaveLog_SBF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }


            };
            class GXST
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXST(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXST>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXSTPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_ST(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXST>(ret);
                }

                static GXSTPtr create_exact()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateExact_ST(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXST>(ret);
                }

                void data(double param1)
                {
                    Data_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void data_vv(GXVVPtr param1)
                {
                    DataVV_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                ~GXST()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_histogram_bins(GXVVPtr param1)
                {
                    GetHistogramBins_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_histogram_info(int32_t& param1, double& param2, double& param3)
                {
                    GetHistogramInfo_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }

                void histogram(int32_t param1)
                {
                    Histogram_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void histogram2(int32_t param1, double param2, double param3)
                {
                    Histogram2_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }

                double equivalent_percentile(double param1)
                {
                    double ret = rEquivalentPercentile_ST(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                double equivalent_value(double param1)
                {
                    double ret = rEquivalentValue_ST(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                void reset()
                {
                    Reset_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                double get_info(ST_INFO param1)
                {
                    double ret = rGetInfo_ST(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                static double get_norm_prob(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rGetNormProb_ST(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double get_norm_prob_x(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rGetNormProbX_ST(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                double normal_test()
                {
                    double ret = rNormalTest_ST(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXST2
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXST2(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXST2Ptr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXST2>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXST2Ptr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_ST2(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXST2>(ret);
                }

                void data_vv(GXVVPtr param1, GXVVPtr param2)
                {
                    DataVV_ST2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                ~GXST2()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_ST2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t items()
                {
                    int32_t ret = iItems_ST2(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void reset()
                {
                    Reset_ST2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                double get(ST2_CORRELATION param1)
                {
                    double ret = rGet_ST2(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXSTR
            {
            private:
                GXSTR();
                ~GXSTR();
            public:


                static int32_t scan_i(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iScanI_STR(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static double scan_date(const gx_string_type& param1, DATE_FORMAT param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rScanDate_STR(
                                     gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static double scan_form(const gx_string_type& param1, GS_FORMATS param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rScanForm_STR(
                                     gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static double scan_r(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rScanR_STR(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static double scan_time(const gx_string_type& param1, TIME_FORMAT param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rScanTime_STR(
                                     gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static void file_combine_parts(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize6 = STR_FILE * STRING_CHAR_SIZE;
                    param6.resize(STR_FILE);
                    IFileCombineParts_STR(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), (gx_string_char_type*)param6.data(), reinterpret_cast<const long*>(&paramSize6 ));
                    gx_->throw_on_error();
                    param6.resize(gx_string_len(param6.c_str()));
                }

                static void file_ext(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, FILE_EXT param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    IFileExt_STR(
                        gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                static void file_name_part(const gx_string_type& param1, gx_string_type& param2, STR_FILE_PART param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IFileNamePart_STR(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void get_m_file(const gx_string_type& param1, gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetMFile_STR(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void remove_qualifiers(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IRemoveQualifiers_STR(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void format_crc(int32_t param1, gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatCRC_STR(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void format_date(double param1, gx_string_type& param2, int32_t param3, DATE_FORMAT param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatDate_STR(
                        gx_->pGeo, &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void format_i(int32_t param1, gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatI_STR(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void format_r(double param1, gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatR_STR(
                        gx_->pGeo, &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void format_r2(double param1, gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatR2_STR(
                        gx_->pGeo, &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void format_double(double param1, gx_string_type& param2, GS_FORMATS param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatReal_STR(
                        gx_->pGeo, &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void format_time(double param1, gx_string_type& param2, int32_t param3, int32_t param4, TIME_FORMAT param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatTime_STR(
                        gx_->pGeo, &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void escape(gx_string_type& param1, STR_ESCAPE param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    _Escape_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static int32_t get_char(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iChar_STR(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t char_n(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = IiCharN_STR(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static void justify(const gx_string_type& param1, gx_string_type& param2, int32_t param3, STR_JUSTIFY param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IJustify_STR(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void replacei_match_string(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IReplaceiMatchString_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void replace_match_string(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IReplaceMatchString_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void set_char_n(gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    ISetCharN_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void split_string(gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    ISplitString_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                static void strcat(gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IStrcat_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static int32_t strcmp(const gx_string_type& param1, const gx_string_type& param2, STR_CASE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrcmp_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static void strcpy(gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IStrcpy_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static int32_t stri_mask(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStriMask_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void strins(gx_string_type& param1, int32_t param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IStrins_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static int32_t strlen(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrlen_STR(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t str_mask(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrMask_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t str_min(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrMin_STR(
                                      gx_->pGeo, (gx_string_char_type*)param1.data());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t str_min2(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrMin2_STR(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t strncmp(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, STR_CASE param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrncmp_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t str_str(const gx_string_type& param1, const gx_string_type& param2, STR_CASE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrStr_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static void substr(gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    ISubstr_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void to_lower(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IToLower_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void to_upper(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IToUpper_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void xyz_line(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    IXYZLine_STR(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void make_alpha(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MakeAlpha_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data());
                    gx_->throw_on_error();
                }

                static void printf(gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    Printf_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), param2.c_str());
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void replace_char(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReplaceChar_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void replace_char2(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReplaceChar2_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void replace_multi_char(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReplaceMultiChar_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void replace_non_ascii(gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReplaceNonASCII_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void set_char(gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetChar_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void trim_quotes(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TrimQuotes_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data());
                    gx_->throw_on_error();
                }

                static void trim_space(gx_string_type& param1, STR_TRIM param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TrimSpace_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void un_quote(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UnQuote_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data());
                    gx_->throw_on_error();
                }

                static void gen_group_name(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_GROUP * STRING_CHAR_SIZE;
                    param4.resize(STR_GROUP);
                    IGenGroupName_STR(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }

                static int32_t count_tokens(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCountTokens_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_token(gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IGetToken_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static int32_t tokenize(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTokenize_STR(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t tokens(gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTokens_STR(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t tokens2(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTokens2_STR(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void parse_list(const gx_string_type& param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ParseList_STR(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }


            };
            class GXSURFACE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSURFACE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSURFACEPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSURFACE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXSURFACEPtr create(const gx_string_type& param1, GXIPJPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_SURFACE(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSURFACE>(ret);
                }

                static GXSURFACEPtr open(const gx_string_type& param1, SURFACE_OPEN param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_SURFACE(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSURFACE>(ret);
                }

                ~GXSURFACE()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_surface_items(GXLSTPtr param1)
                {
                    GetSurfaceItems_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                GXSURFACEITEMPtr get_surface_item(const gx_string_type& param1)
                {
                    int32_t ret = GetSurfaceItem_SURFACE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSURFACEITEM>(ret);
                }

                void add_surface_item(GXSURFACEITEMPtr param1)
                {
                    AddSurfaceItem_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void get_surface_names(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetSurfaceNames_SURFACE(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                static void get_closed_surface_names(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetClosedSurfaceNames_SURFACE(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void get_extents(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetExtents_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                static int32_t crc(const gx_string_type& param1, const gx_string_type& param2, int32_t& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRC_SURFACE(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static void sync(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sync_SURFACE(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void create_from_dxf(GXIPJPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateFromDXF_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void create_from_vulcan_triangulation(const gx_string_type& param1, GXIPJPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateFromVulcanTriangulation_SURFACE(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }

                static void append_vulcan_triangulation(const gx_string_type& param1, GXIPJPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AppendVulcanTriangulation_SURFACE(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXSURFACEITEM
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSURFACEITEM(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSURFACEITEMPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSURFACEITEM>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXSURFACEITEMPtr create(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_SURFACEITEM(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSURFACEITEM>(ret);
                }

                ~GXSURFACEITEM()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_guid(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    GetGUID_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void set_properties(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double param5, const gx_string_type& param6, const gx_string_type& param7, double param8)
                {
                    SetProperties_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), &param5, param6.c_str(), param7.c_str(), &param8);
                    gx_->throw_on_error();
                }

                void set_properties_ex(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double param5, const gx_string_type& param6, const gx_string_type& param7, int32_t param8, double param9, double param10)
                {
                    SetPropertiesEx_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), &param5, param6.c_str(), param7.c_str(), reinterpret_cast<const long*>(&param8), &param9, &param10);
                    gx_->throw_on_error();
                }

                void get_properties(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, double& param5, gx_string_type& param6, gx_string_type& param7, double& param8)
                {
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize11 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize13 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    param2.resize(STR_FILE);
                    param3.resize(STR_DEFAULT_SHORT);
                    param4.resize(STR_FILE);
                    param6.resize(STR_DEFAULT_SHORT);
                    param7.resize(STR_FILE);
                    GetProperties_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize6 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize8 ), &param5, (gx_string_char_type*)param6.data(), reinterpret_cast<const long*>(&paramSize11 ), (gx_string_char_type*)param7.data(), reinterpret_cast<const long*>(&paramSize13 ), &param8);
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param6.resize(gx_string_len(param6.c_str()));
                    param7.resize(gx_string_len(param7.c_str()));
                }

                void get_properties_ex(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, double& param5, gx_string_type& param6, gx_string_type& param7, int32_t& param8, double& param9, double& param10)
                {
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize11 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize13 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    param2.resize(STR_FILE);
                    param3.resize(STR_DEFAULT_SHORT);
                    param4.resize(STR_FILE);
                    param6.resize(STR_DEFAULT_SHORT);
                    param7.resize(STR_FILE);
                    GetPropertiesEx_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize6 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize8 ), &param5, (gx_string_char_type*)param6.data(), reinterpret_cast<const long*>(&paramSize11 ), (gx_string_char_type*)param7.data(), reinterpret_cast<const long*>(&paramSize13 ), reinterpret_cast<long*>(&param8), &param9, &param10);
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param6.resize(gx_string_len(param6.c_str()));
                    param7.resize(gx_string_len(param7.c_str()));
                }

                void set_default_render_properties(int32_t param1, double param2, SURFACERENDER_MODE param3)
                {
                    SetDefaultRenderProperties_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void get_default_render_properties(int32_t& param1, double& param2, SURFACERENDER_MODE& param3)
                {
                    GetDefaultRenderProperties_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }

                int32_t num_components()
                {
                    int32_t ret = iNumComponents_SURFACEITEM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t add_mesh(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    int32_t ret = iAddMesh_SURFACEITEM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_mesh(int32_t param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7)
                {
                    GetMesh_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                void get_extents(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetExtents_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void get_mesh_info(int32_t param1, bool& param2, int32_t& param3, double& param4, double& param5, double& param6)
                {
                    long paramBool2 = param2 ? 1 : 0;
                    GetMeshInfo_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &paramBool2, reinterpret_cast<long*>(&param3), &param4, &param5, &param6);
                    gx_->throw_on_error();
                    param2 = paramBool2 != 0 ? true : false;
                }

                void get_info(bool& param1, double& param2, double& param3, double& param4)
                {
                    long paramBool1 = param1 ? 1 : 0;
                    GetInfo_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &paramBool1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                    param1 = paramBool1 != 0 ? true : false;
                }

                void get_geometry_info(int32_t& param1, int32_t& param2)
                {
                    GetGeometryInfo_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }

                void compute_extended_info(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6, int32_t& param7)
                {
                    ComputeExtendedInfo_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7));
                    gx_->throw_on_error();
                }


            };
            class GXSYS
            {
            private:
                GXSYS();
                ~GXSYS();
            public:


                static void break_date(double param1, int32_t& param2, int32_t& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BreakDate_SYS(
                        gx_->pGeo, &param1, reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }

                static int32_t dateto_long(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDatetoLong_SYS(
                                      gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t timeto_long(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTimetoLong_SYS(
                                      gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double date()
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rDate_SYS(
                                     gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static double longto_date(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLongtoDate_SYS(
                                     gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                static double longto_time(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLongtoTime_SYS(
                                     gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                static double make_date(int32_t param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rMakeDate_SYS(
                                     gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static double secondsto_time(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rSecondstoTime_SYS(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double time()
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rTime_SYS(
                                     gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static double timeto_seconds(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rTimetoSeconds_SYS(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static double utc_date()
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUTCDate_SYS(
                                     gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static double utc_time()
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUTCTime_SYS(
                                     gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t exist_env(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iExistEnv_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_env(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IGetEnv_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void set_env(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetEnv_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static int32_t clear_err_ap()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iClearErrAP_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t get_top_error_ap()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetTopErrorAP_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_error_message_ap(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IGetErrorMessageAP_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static int32_t num_errors_ap()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iNumErrorsAP_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static void set_server_messages_ap(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetServerMessagesAP_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static int32_t run(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRun_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t run_gs(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRunGS_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t run_gx(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRunGX_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t run_gx_ex(const gx_string_type& param1, int32_t& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRunGXEx_SYS(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t run_pdf(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iRunPDF_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t shell_execute(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, SHELL_EXECUTE param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iShellExecute_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }

                static void set_return(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetReturn_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void do_command(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DoCommand_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void error(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Error_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void error_tag(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ErrorTag_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static int32_t _assert_gx(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iAssertGX_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t ole_automation(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iOLEAutomation_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static void save_log(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SaveLog_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void show_error()
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ShowError_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void terminate(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Terminate_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static int32_t crc_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRCFile_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t crc_file_offset(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRCFileOffset_SYS(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                static void file_ren(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FileRen_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void find_files_vv(GXVVPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FindFilesVV_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void absolute_file_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IAbsoluteFileName_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static int32_t copy_file(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCopyFile_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t delete_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDeleteFile_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t delete_gi_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDeleteGIFile_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t delete_grid_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDeleteGridFile_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t dir_exist(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDirExist_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t file_exist(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iFileExist_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t file_size(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iFileSize_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static bool file_writable(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    bool ret = 0 != iFileWritable_SYS(
                                   gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t find_path(const gx_string_type& param1, SYS_SEARCH_PATH param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = iFindPath_SYS(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }

                static int32_t find_path_ex(const gx_string_type& param1, SYS_SEARCH_PATH param2, GEO_DIRECTORY param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    int32_t ret = iFindPathEx_SYS(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }

                static void get_directory(SYS_DIR param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetDirectory_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void get_path(SYS_PATH param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetPath_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void get_windows_dir(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetWindowsDir_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static int32_t make_dir(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iMakeDir_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t make_file_readonly(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iMakeFileReadonly_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t make_file_writable(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iMakeFileWritable_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void relative_file_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IRelativeFileName_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void short_path_file_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IShortPathFileName_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void temp_file_ext(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    ITempFileExt_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void temp_file_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    ITempFileName_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void transfer_path(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    ITransferPath_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static int32_t valid_file_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iValidFileName_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t write_in_dir(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iWriteInDir_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static double file_date(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rFileDate_SYS(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static double file_time(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rFileTime_SYS(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static double utc_file_date(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUTCFileDate_SYS(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static double utc_file_time(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUTCFileTime_SYS(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_settings_meta(GXMETAPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetSettingsMETA_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void global_reset(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GlobalReset_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void global_set(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GlobalSet_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void global_write(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GlobalWrite_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static int32_t global(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    int32_t ret = IiGlobal_SYS(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }

                static void reset_settings()
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ResetSettings_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void set_settings_meta(GXMETAPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetSettingsMETA_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static int32_t check_arc_license()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCheckArcLicense_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static ARC_LICENSE check_arc_license_ex(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    ARC_LICENSE ret = (ARC_LICENSE)iCheckArcLicenseEx_SYS(
                                          gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }

                static int32_t check_intrinsic(int32_t param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCheckIntrinsic_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t get_geodist()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetGeodist_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static void get_license_class(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    IGetLicenseClass_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void get_licensed_user(gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    param2.resize(STR_DEFAULT_LONG);
                    IGetLicensedUser_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void add_lineage_parameter(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AddLineageParameter_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void add_lineage_source(SYS_LINEAGE_SOURCE param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AddLineageSource_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                static void clear_lineage_parameters()
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClearLineageParameters_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void clear_lineage_sources()
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClearLineageSources_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void copy_geo_file(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CopyGeoFile_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void backup_geo_file(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IBackupGeoFile_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void remove_lineage_output(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveLineageOutput_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void remove_lineage_parameter(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveLineageParameter_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void remove_lineage_source(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveLineageSource_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void restore_geo_file(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RestoreGeoFile_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void set_lineage_description(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetLineageDescription_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void set_lineage_display_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetLineageDisplayName_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void set_lineage_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetLineageName_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void clear_menus(SYS_MENU_CLEAR param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ClearMenus_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void get_loaded_menus(GXLSTPtr param1, GXLSTPtr param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_GetLoadedMenus_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void set_loaded_menus(GXLSTPtr param1, GXLSTPtr param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetLoadedMenus_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void get_entitlement_rights(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetEntitlementRights_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void generate_guid(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    GenerateGUID_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                static void clipboard_to_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClipboardToFile_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static GXRAPtr create_clipboard_ra()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateClipboardRA_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXRA>(ret);
                }

                static GXWAPtr create_clipboard_wa()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateClipboardWA_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXWA>(ret);
                }

                static void emf_object_size(const gx_string_type& param1, double& param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EMFObjectSize_SYS(
                        gx_->pGeo, param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                }

                static void file_to_clipboard(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FileToClipboard_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void font_lst(GXLSTPtr param1, SYS_FONT param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FontLST_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static int32_t get_dot_net_gx_entries(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    int32_t ret = IiGetDotNetGXEntries_SYS(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }

                static void send_general_message(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SendGeneralMessage_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void write_debug_log(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    WriteDebugLog_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static int32_t get_thread_id()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetThreadID_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static void run_multi_user_script(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RunMultiUserScript_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                static void clear_group(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClearGroup_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void clear_group_parm(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClearGroupParm_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void clear_parm()
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClearParm_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void default_int(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DefaultInt_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void default_double(const gx_string_type& param1, const gx_string_type& param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DefaultReal_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3);
                    gx_->throw_on_error();
                }

                static void default_string(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DefaultString_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static void get_pattern(const gx_string_type& param1, int32_t& param2, double& param3, int32_t& param4, double& param5, int32_t& param6, int32_t& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetPattern_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), &param3, reinterpret_cast<long*>(&param4), &param5, reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7));
                    gx_->throw_on_error();
                }

                static void get_reg(GXREGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetREG_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                static void gt_string(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    GtString_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                static int32_t exist_int(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iExistInt_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t exist_double(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iExistReal_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t exist_string(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iExistString_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t get_int(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetInt_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t get_yes_no(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetYesNo_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void replace_string(const gx_string_type& param1, gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IReplaceString_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), param3.c_str());
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void load_parm(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadParm_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static double get_double(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rGetReal_SYS(
                                     gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void save_parm(const gx_string_type& param1, int32_t param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SaveParm_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                static void filter_parm_group(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FilterParmGroup_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void set_int(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetInt_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void set_pattern(const gx_string_type& param1, int32_t param2, double param3, int32_t param4, double param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetPattern_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), &param3, reinterpret_cast<const long*>(&param4), &param5, reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void set_double(const gx_string_type& param1, const gx_string_type& param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetReal_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3);
                    gx_->throw_on_error();
                }

                static void set_reg(GXREGPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetREG_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void set_string(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetString_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

                static int32_t check_stop()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCheckStop_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t prog_state()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iProgState_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static void prog_name(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProgName_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void progress(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Progress_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void prog_update(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProgUpdate_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void prog_update_l(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProgUpdateL_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void get_sys_info(SYS_INFO param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    IGetSysInfo_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static int32_t registry_get_val(REG_DOMAIN param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param4.resize(STR_VERY_LONG);
                    int32_t ret = IiRegistryGetVal_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }

                static int32_t registry_delete_key(REG_DOMAIN param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRegistryDeleteKey_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t registry_delete_val(REG_DOMAIN param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRegistryDeleteVal_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void registry_set_val(REG_DOMAIN param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RegistrySetVal_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }

                static void destroy_ptmp(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DestroyPTMP_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void get_ptmp(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetPTMP_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static int32_t save_ptmp(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = SavePTMP_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void _abort(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _Abort_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void _assert(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _Assert_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void _exit()
                {
                    GXContextPtr gx_ = GXContext::current();
                    _Exit_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void _cancel()
                {
                    GXContextPtr gx_ = GXContext::current();
                    Cancel_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static int32_t delay(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDelay_SYS(
                                      gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t get_timer(int32_t param1, double& param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetTimer_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }

                static void display_help(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DisplayHelp_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void display_help_topic(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DisplayHelpTopic_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void display_int(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DisplayInt_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                static void display_message(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DisplayMessage_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void display_double(const gx_string_type& param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DisplayReal_SYS(
                        gx_->pGeo, param1.c_str(), &param2);
                    gx_->throw_on_error();
                }

                static int32_t display_question(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iDisplayQuestion_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t display_question_with_cancel(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iDisplayQuestionWithCancel_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t interactive()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iInteractive_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t prompt(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    int32_t ret = App_IiPrompt_SYS(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }

                static int32_t script()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iScript_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t script_record()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iScriptRecord_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

                static void set_cursor(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetCursor_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void set_info_line(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetInfoLine_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                static void set_interactive(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetInteractive_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static void get_workspace_reg(GXREGPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetWorkspaceREG_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void set_workspace_reg(GXREGPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetWorkspaceREG_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static void encrypt_string(const gx_string_type& param1, gx_string_type& param2, SYS_ENCRYPTION_KEY param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    EncryptString_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static void decrypt_string(const gx_string_type& param1, gx_string_type& param2, SYS_ENCRYPTION_KEY param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    DecryptString_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                static int32_t is_encrypted_string(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = IsEncryptedString_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void disable_gx_debugger()
                {
                    GXContextPtr gx_ = GXContext::current();
                    DisableGXDebugger_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

                static void enable_gx_debugger(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EnableGXDebugger_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXTB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXTB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXTBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXTB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void set_search_mode(TB_SEARCH param1)
                {
                    _SetSearchMode_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                static GXTBPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_TB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTB>(ret);
                }

                static GXTBPtr create_db(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateDB_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTB>(ret);
                }

                static GXTBPtr create_ltb(GXLTBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateLTB_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTB>(ret);
                }

                ~GXTB()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t field(const gx_string_type& param1)
                {
                    int32_t ret = Field_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_string(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    GetString_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                DB_CATEGORY_CHAN data_type(int32_t param1)
                {
                    DB_CATEGORY_CHAN ret = (DB_CATEGORY_CHAN)iDataType_TB(
                                               gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void find_col_by_index(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    IFindColByIndex_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t find_col_by_name(const gx_string_type& param1)
                {
                    int32_t ret = iFindColByName_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                DB_CHAN_FORMAT format(int32_t param1)
                {
                    DB_CHAN_FORMAT ret = (DB_CHAN_FORMAT)iFormat_TB(
                                             gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_int(int32_t param1, int32_t param2)
                {
                    int32_t ret = iGetInt_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t num_columns()
                {
                    int32_t ret = iNumColumns_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t num_rows()
                {
                    int32_t ret = iNumRows_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void load_db(GXDBPtr param1, int32_t param2)
                {
                    LoadDB_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                double get_double(int32_t param1, int32_t param2)
                {
                    double ret = rGetReal_TB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void save(const gx_string_type& param1)
                {
                    Save_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void save_db(GXDBPtr param1, int32_t param2)
                {
                    SaveDB_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void save_to_ascii(const gx_string_type& param1)
                {
                    SaveToAscii_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_int(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetInt_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void set_double(int32_t param1, int32_t param2, double param3)
                {
                    SetReal_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }

                void set_string(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    SetString_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                void sort(int32_t param1)
                {
                    Sort_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }


            };
            class GXTPAT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXTPAT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXTPATPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXTPAT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_color(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    AddColor_TPAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static GXTPATPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_TPAT(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTPAT>(ret);
                }

                ~GXTPAT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_TPAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t code(const gx_string_type& param1)
                {
                    int32_t ret = iCode_TPAT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_solid_pattern(int32_t param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, int32_t& param5)
                {
                    int32_t paramSize3 = TPAT_CODE_SIZE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = TPAT_LABEL_SIZE * STRING_CHAR_SIZE;
                    int32_t paramSize7 = TPAT_DESC_SIZE * STRING_CHAR_SIZE;
                    param2.resize(TPAT_CODE_SIZE);
                    param3.resize(TPAT_LABEL_SIZE);
                    param4.resize(TPAT_DESC_SIZE);
                    IGetSolidPattern_TPAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize7 ), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }

                int32_t size()
                {
                    int32_t ret = iSize_TPAT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void load_csv(const gx_string_type& param1)
                {
                    LoadCSV_TPAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void setup_translation_vv(GXLTBPtr param1, int32_t param2, GXVVPtr param3)
                {
                    SetupTranslationVV_TPAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }


            };
            class GXTR
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXTR(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXTRPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXTR>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXTRPtr create(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_TR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTR>(ret);
                }

                ~GXTR()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_TR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void copy(GXTRPtr param1)
                {
                    Copy_TR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }


            };
            class GXUSERMETA
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXUSERMETA(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXUSERMETAPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXUSERMETA>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXUSERMETAPtr create(USERMETA_FORMAT param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_USERMETA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXUSERMETA>(ret);
                }

                static GXUSERMETAPtr create_s(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_USERMETA(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXUSERMETA>(ret);
                }

                ~GXUSERMETA()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_data_creation_date(double& param1)
                {
                    GetDataCreationDate_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void get_extents2d(double& param1, double& param2, double& param3, double& param4)
                {
                    GetExtents2d_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void get_extents3d(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetExtents3d_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_meta_creation_date(double& param1)
                {
                    GetMetaCreationDate_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void get_xml_format(USERMETA_FORMAT& param1)
                {
                    GetXMLFormat_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1));
                    gx_->throw_on_error();
                }

                int32_t compare(GXUSERMETAPtr param1)
                {
                    int32_t ret = iCompare_USERMETA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_data_creator(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetDataCreator_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_format(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetFormat_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_meta_creator(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetMetaCreator_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_project(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetProject_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_title(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetTitle_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void serial(bool param1, const gx_string_type& param2)
                {
                    long paramBool1 = param1 ? 1 : 0;
                    Serial_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &paramBool1, param2.c_str());
                    gx_->throw_on_error();
                }

                void set_data_creation_date(double param1)
                {
                    SetDataCreationDate_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_data_creator(const gx_string_type& param1)
                {
                    SetDataCreator_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_extents2d(double param1, double param2, double param3, double param4)
                {
                    SetExtents2d_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void set_extents3d(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    SetExtents3d_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void set_format(const gx_string_type& param1)
                {
                    SetFormat_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_meta_creation_date(double param1)
                {
                    SetMetaCreationDate_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_meta_creator(const gx_string_type& param1)
                {
                    SetMetaCreator_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_project(const gx_string_type& param1)
                {
                    SetProject_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void set_title(const gx_string_type& param1)
                {
                    SetTitle_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                static void update_extents2_d(const gx_string_type& param1, GXIPJPtr param2, double param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UpdateExtents2D_USERMETA(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                static void update_file_type(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UpdateFileType_USERMETA(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                static void save_file_lineage(const gx_string_type& param1, bool param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool2 = param2 ? 1 : 0;
                    SaveFileLineage_USERMETA(
                        gx_->pGeo, param1.c_str(), &paramBool2);
                    gx_->throw_on_error();
                }


            };
            class GXVA
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVA(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVAPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVA>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }





#ifdef GXPYTHON
                np::ndarray get_array_np(int32_t start_row, int32_t start_column, int32_t num_rows, int32_t num_columns, bp::object dtype)
#else
                template <typename T>
                std::vector<T> get_array(int32_t start_row, int32_t start_column, int32_t num_rows, int32_t num_columns)
#endif

                {


#ifdef GXPYTHON
                    int32_t gs_type;
                    size_t total_size;
                    auto np_array = make_ndarray(num_rows*num_columns, dtype, gs_type, total_size);
                    iGetArray_VA(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start_row, start_column, num_rows, num_columns, np_array.get_data(), gs_type);
                    gx_->throw_on_error();
                    return np_array;
#else
                    std::vector<T> data(num_rows*num_columns);
                    iGetArray_VA(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start_row, start_column, num_rows, num_columns, data.data(), gs_cpp_type<T>::type());
                    gx_->throw_on_error();
                    return data;
#endif

                }



#ifdef GXPYTHON
                void set_array_np(int32_t start_row, int32_t start_column, np::ndarray np_array)
#else
                template <typename T>
                void set_array(int32_t start_row, int32_t start_column, int32_t num_rows, int32_t num_columns, const std::vector<T>& data)
#endif

                {


#ifdef GXPYTHON
                    int32_t gs_type;
                    size_t num_rows, num_columns, total_size;
                    auto contig_np_array = validate_and_make_2d_contiguous_ndarray(np_array, num_rows, num_columns, gs_type, total_size);
                    iSetArray_VA(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start_row, start_column, (long)num_rows, (long)num_columns, contig_np_array.get_data(), gs_type);
                    gx_->throw_on_error();
#else
                    if (data.size() != num_rows*num_columns)
                        throw GXAPIError(gx_string_literal("data size is not equal to num_rows*num_columns"));
                    iSetArray_VA(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start_row, start_column, num_rows, num_columns, data.data(), gs_cpp_type<T>::type());
                    gx_->throw_on_error();
#endif

                }

                void add_elevations_vv_to_depths(GXVVPtr param1, int32_t param2)
                {
                    AddElevationsVVToDepths_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void append(GXVAPtr param1)
                {
                    Append_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void average(GXVVPtr param1, VA_AVERAGE param2)
                {
                    Average_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void copy(GXVAPtr param1)
                {
                    Copy_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void copy2(int32_t param1, int32_t param2, GXVAPtr param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    Copy2_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static GXVAPtr create(GEO_VAR param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVA>(ret);
                }

                static GXVAPtr create_ext(GS_TYPES param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateExt_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVA>(ret);
                }

                static GXVAPtr create_vv(GXVVPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateVV_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVA>(ret);
                }

                ~GXVA()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                GXVVPtr get_full_vv()
                {
                    int32_t ret = GetFullVV_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                void get_vv(int32_t param1, VA_OBJECT param2, GXVVPtr param3)
                {
                    GetVV_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                int32_t col()
                {
                    int32_t ret = iCol_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_int(int32_t param1, int32_t param2)
                {
                    int32_t ret = iGetInt_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_string(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    IGetString_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }

                int32_t len()
                {
                    int32_t ret = iLen_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                static void index_order(GXVVPtr param1, GXVAPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IndexOrder_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void lookup_index(GXVVPtr param1, GXVAPtr param2)
                {
                    LookupIndex_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void range_double(double& param1, double& param2)
                {
                    RangeDouble_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void re_fid(double param1, double param2, int32_t param3)
                {
                    ReFid_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void reverse()
                {
                    Reverse_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                double get_fid_incr()
                {
                    double ret = rGetFidIncr_VA(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double get_fid_start()
                {
                    double ret = rGetFidStart_VA(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double get_double(int32_t param1, int32_t param2)
                {
                    double ret = rGetReal_VA(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_fid_incr(double param1)
                {
                    SetFidIncr_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_fid_start(double param1)
                {
                    SetFidStart_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_int(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetInt_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void set_ln(int32_t param1)
                {
                    SetLn_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_double(int32_t param1, int32_t param2, double param3)
                {
                    SetReal_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }

                void set_string(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    SetString_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                void set_vv(int32_t param1, VA_OBJECT param2, GXVVPtr param3)
                {
                    SetVV_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void trans(double param1, double param2)
                {
                    Trans_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void window(int32_t param1, int32_t param2, GXVVPtr param3)
                {
                    Window_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void window2(double param1, double param2, GXVVPtr param3)
                {
                    Window2_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                int32_t check_for_repeating(GXVVPtr param1, int32_t param2, GXVVPtr param3, double param4)
                {
                    int32_t ret = iCheckForRepeating_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t check_for_repeating2(GXVVPtr param1, int32_t param2, GXVVPtr param3, double param4, int32_t& param5, int32_t& param6)
                {
                    int32_t ret = iCheckForRepeating2_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }


            };
            class GXVM
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVM(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVMPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVM>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXVMPtr create(GEO_VAR param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVM>(ret);
                }

                static GXVMPtr create_ext(GS_TYPES param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateExt_VM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVM>(ret);
                }

                ~GXVM()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                int32_t get_int(int32_t param1)
                {
                    int32_t ret = iGetInt_VM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_string(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IGetString_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t length()
                {
                    int32_t ret = iLength_VM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void re_size(int32_t param1)
                {
                    ReSize_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                double get_double(int32_t param1)
                {
                    double ret = rGetReal_VM(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_int(int32_t param1, int32_t param2)
                {
                    SetInt_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_double(int32_t param1, double param2)
                {
                    SetReal_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void set_string(int32_t param1, const gx_string_type& param2)
                {
                    SetString_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXVOX
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVOX(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVOXPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVOX>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void calc_stats(GXSTPtr param1)
                {
                    CalcStats_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXVOXPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VOX(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                GXPGPtr create_pg()
                {
                    int32_t ret = CreatePG_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }

                GXPGPtr create_type_pg(GS_TYPES param1)
                {
                    int32_t ret = CreateTypePG_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }

                ~GXVOX()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void dump(const gx_string_type& param1)
                {
                    Dump_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void export_db(GXDBPtr param1, const gx_string_type& param2, VOX_DIRECTION param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    ExportDB_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                void export_img(const gx_string_type& param1, VOX_DIR param2)
                {
                    ExportIMG_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void export_to_grids(const gx_string_type& param1, VOX_DIR param2, int32_t param3, int32_t param4, int32_t param5, double param6, VOX_SLICE_MODE param7)
                {
                    ExportToGrids_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

                static void export_xml(const gx_string_type& param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportXML_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                void export_seg_y(const gx_string_type& param1, double param2)
                {
                    ExportSegY_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }

                static void export_ji_gs_xml(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportJIGsXML_VOX(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

                void export_xyz(const gx_string_type& param1, VOX_DIRECTION param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    ExportXYZ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                void filter(VOX_FILTER3D param1, const gx_string_type& param2, int32_t param3, int32_t param4, const gx_string_type& param5)
                {
                    Filter_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                }

                static void generate_db(const gx_string_type& param1, GXDBPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenerateDB_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                static void generate_vector_voxel_from_db(const gx_string_type& param1, GXDBPtr param2, VOX_VECTORVOX_IMPORT param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenerateVectorVoxelFromDB_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8);
                    gx_->throw_on_error();
                }

                static GXVOXPtr generate_gocad(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, GXIPJPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GenerateGOCAD_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static GXVOXPtr generate_oriented_gocad(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, GXIPJPtr param4, VOX_GOCAD_ORIENTATION param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GenerateOrientedGOCAD_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static GXVOXPtr generate_pg(const gx_string_type& param1, GXPGPtr param2, double param3, double param4, double param5, double param6, double param7, double param8, GXIPJPtr param9, GXMETAPtr param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GeneratePG_VOX(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static GXVOXPtr generate_constant_value(const gx_string_type& param1, double param2, GS_TYPES param3, double param4, double param5, double param6, double param7, double param8, double param9, int32_t param10, int32_t param11, int32_t param12, GXIPJPtr param13, GXMETAPtr param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GenerateConstantValue_VOX(
                                      gx_->pGeo, param1.c_str(), &param2, reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static GXVOXPtr generate_pgvv(const gx_string_type& param1, GXPGPtr param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXIPJPtr param9, GXMETAPtr param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GeneratePGVV_VOX(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static GXVOXPtr generate_constant_value_vv(const gx_string_type& param1, double param2, GS_TYPES param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXIPJPtr param10, GXMETAPtr param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GenerateConstantValueVV_VOX(
                                      gx_->pGeo, param1.c_str(), &param2, reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static GXVOXPtr generate_ubc(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, double param4, GXIPJPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GenerateUBC_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static void generate_xyz(const gx_string_type& param1, GXRAPtr param2, GS_TYPES param3, GXIPJPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenerateXYZ_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                static GXVOXPtr init_generate_by_subset_pg(GS_TYPES param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = InitGenerateBySubsetPG_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                void add_generate_by_subset_pg(GXPGPtr param1, VOX_DIR param2, int32_t param3)
                {
                    AddGenerateBySubsetPG_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void end_generate_by_subset_pg(const gx_string_type& param1, double param2, double param3, double param4, double param5, double param6, double param7, GXIPJPtr param8, GXMETAPtr param9)
                {
                    EndGenerateBySubsetPG_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }

                void get_area(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetArea_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void get_gocad_location(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12)
                {
                    GetGOCADLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }

                void get_grid_section_cell_sizes(double param1, double& param2, double& param3)
                {
                    GetGridSectionCellSizes_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }

                void get_info(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5)
                {
                    GetInfo_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                }

                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_limits(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6)
                {
                    GetLimits_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }

                void get_limits_xyz(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetLimitsXYZ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void get_location(double& param1, double& param2, double& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    GetLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                void get_location_points(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GetLocationPoints_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_double_location(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12)
                {
                    GetRealLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }

                void get_simple_location(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetSimpleLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                GXSTPtr get_stats()
                {
                    int32_t ret = GetStats_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXST>(ret);
                }

                void get_tpat(GXTPATPtr param1)
                {
                    GetTPAT_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                static GXVOXPtr grid_points(const gx_string_type& param1, const gx_string_type& param2, double param3, int32_t param4, double param5, double param6, int32_t param7, int32_t param8, int32_t param9, double param10, double param11, double param12, double param13, double param14, GS_TYPES param15, GXVVPtr param16, GXVVPtr param17, GXVVPtr param18, GXVVPtr param19, GXIPJPtr param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GridPoints_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4), &param5, &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&gx_->handle(param16)), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), reinterpret_cast<const long*>(&gx_->handle(param20)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static GXVOXPtr grid_points_z(const gx_string_type& param1, const gx_string_type& param2, double param3, const gx_string_type& param4, int32_t param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double param12, double param13, double param14, double param15, GS_TYPES param16, GXVVPtr param17, GXVVPtr param18, GXVVPtr param19, GXVVPtr param20, GXIPJPtr param21)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GridPointsZ_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), reinterpret_cast<const long*>(&gx_->handle(param20)), reinterpret_cast<const long*>(&gx_->handle(param21)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static GXVOXPtr grid_points_z_ex(const gx_string_type& param1, const gx_string_type& param2, double param3, const gx_string_type& param4, int32_t param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double& param12, double& param13, double param14, double& param15, double param16, double param17, double param18, double param19, double param20, GS_TYPES param21, GXVVPtr param22, GXVVPtr param23, GXVVPtr param24, GXVVPtr param25, GXIPJPtr param26)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GridPointsZEx_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, &param19, &param20, reinterpret_cast<const long*>(&param21), reinterpret_cast<const long*>(&gx_->handle(param22)), reinterpret_cast<const long*>(&gx_->handle(param23)), reinterpret_cast<const long*>(&gx_->handle(param24)), reinterpret_cast<const long*>(&gx_->handle(param25)), reinterpret_cast<const long*>(&gx_->handle(param26)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                int32_t can_append_to(const gx_string_type& param1)
                {
                    int32_t ret = iCanAppendTo_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                void get_cell_size_strings(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, double param4, double param5, double param6)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    param2.resize(STR_VERY_LONG);
                    param3.resize(STR_VERY_LONG);
                    IGetCellSizeStrings_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize6 ), &param4, &param5, &param6);
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }

                int32_t is_thematic()
                {
                    int32_t ret = iIsThematic_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t is_vector_voxel()
                {
                    int32_t ret = iIsVectorVoxel_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t set_cell_size_strings(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    int32_t ret = iSetCellSizeStrings_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static GXVOXPtr list_gocad_properties(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ListGOCADProperties_VOX(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static GXVOXPtr log_grid_points_z_ex(const gx_string_type& param1, const gx_string_type& param2, double param3, const gx_string_type& param4, int32_t param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double& param12, double& param13, double param14, double& param15, double param16, double param17, double param18, double param19, double param20, VOX_GRID_LOGOPT param21, double param22, GS_TYPES param23, GXVVPtr param24, GXVVPtr param25, GXVVPtr param26, GXVVPtr param27, GXIPJPtr param28)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = LogGridPointsZEx_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, &param19, &param20, reinterpret_cast<const long*>(&param21), &param22, reinterpret_cast<const long*>(&param23), reinterpret_cast<const long*>(&gx_->handle(param24)), reinterpret_cast<const long*>(&gx_->handle(param25)), reinterpret_cast<const long*>(&gx_->handle(param26)), reinterpret_cast<const long*>(&gx_->handle(param27)), reinterpret_cast<const long*>(&gx_->handle(param28)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static GXVOXPtr krig(const gx_string_type& param1, double param2, GS_TYPES param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXIPJPtr param8, GXREGPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Krig_VOX(
                                      gx_->pGeo, param1.c_str(), &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static GXVOXPtr math(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, GXLSTPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Math_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                void merge(GXVOXPtr param1, GXREGPtr param2, const gx_string_type& param3)
                {
                    Merge_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }

                static GXVOXPtr nearest_neighbour_grid(const gx_string_type& param1, double param2, double param3, GS_TYPES param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXIPJPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = NearestNeighbourGrid_VOX(
                                      gx_->pGeo, param1.c_str(), &param2, &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }

                static double compute_cell_size(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rComputeCellSize_VOX(
                                     gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                    return ret;
                }

                void re_grid(GXVOXPtr param1, GXREGPtr param2, const gx_string_type& param3)
                {
                    ReGrid_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }

                GXPGPtr resample_pg(GXIPJPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double param12, VOX_SLICE_MODE param13)
                {
                    int32_t ret = ResamplePG_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, reinterpret_cast<const long*>(&param13));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }

                void rescale_cell_sizes(double param1)
                {
                    RescaleCellSizes_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void sample_cdi(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, const gx_string_type& param9)
                {
                    SampleCDI_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), param9.c_str());
                    gx_->throw_on_error();
                }

                void sample_cdi_to_topography(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5, int32_t param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    SampleCDIToTopography_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }

                void sample_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, GXVVPtr param5)
                {
                    SampleVV_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_location(double param1, double param2, double param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    SetLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_origin(VOX_ORIGIN param1, double param2, double param3, double param4)
                {
                    SetOrigin_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

                void set_simple_location(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    SetSimpleLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

                void set_tpat(GXTPATPtr param1)
                {
                    SetTPAT_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void slice_ipj(const gx_string_type& param1, GXIPJPtr param2, VOX_SLICE_MODE param3, double param4, double param5, double param6, double param7, int32_t param8, int32_t param9)
                {
                    SliceIPJ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }

                void slice_multi_layer_ipj(const gx_string_type& param1, GXIPJPtr param2, VOX_SLICE_MODE param3, double param4, double param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double param12)
                {
                    SliceMultiLayerIPJ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12);
                    gx_->throw_on_error();
                }

                void subset_to_double_extents(const gx_string_type& param1)
                {
                    SubsetToRealExtents_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                static void sync(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sync_VOX(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

                void window_ply(GXPLYPtr param1, int32_t param2, double param3, double param4, const gx_string_type& param5, int32_t param6)
                {
                    WindowPLY_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, &param4, param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                void window_xyz(double param1, double param2, double param3, double param4, double param5, double param6, const gx_string_type& param7, int32_t param8)
                {
                    WindowXYZ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, param7.c_str(), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                void write_xml(const gx_string_type& param1)
                {
                    WriteXML_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                void convert_numeric_to_thematic(GXVVPtr param1, const gx_string_type& param2)
                {
                    ConvertNumericToThematic_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void convert_thematic_to_numeric(GXVVPtr param1, const gx_string_type& param2)
                {
                    ConvertThematicToNumeric_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void convert_velocity_to_density(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, const gx_string_type& param9)
                {
                    ConvertVelocityToDensity_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, param9.c_str());
                    gx_->throw_on_error();
                }

                void convert_velocity_in_range_to_density(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, const gx_string_type& param11)
                {
                    ConvertVelocityInRangeToDensity_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, param11.c_str());
                    gx_->throw_on_error();
                }

                void convert_density_to_velocity(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, const gx_string_type& param11)
                {
                    ConvertDensityToVelocity_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, param11.c_str());
                    gx_->throw_on_error();
                }

                void invert_z(const gx_string_type& param1)
                {
                    InvertZ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                static void dw_grid_db(const gx_string_type& param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, GXREGPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGridDB_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }

                static void tin_grid_db(const gx_string_type& param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, GXVVPtr param8, GXREGPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TINGridDB_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }


            };
            class GXVOXD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVOXD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVOXDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVOXD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXVOXDPtr create(GXVOXPtr param1, const gx_string_type& param2, ITR_ZONE param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VOXD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOXD>(ret);
                }

                static GXVOXDPtr create_itr(GXVOXPtr param1, GXITRPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateITR_VOXD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOXD>(ret);
                }

                static GXVOXDPtr create_thematic(GXVOXPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateThematic_VOXD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOXD>(ret);
                }

                ~GXVOXD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void get_draw_controls(int32_t& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8)
                {
                    GetDrawControls_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }

                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetName_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }

                void get_itr(GXITRPtr param1)
                {
                    GetITR_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void get_shell_controls(double& param1, double& param2)
                {
                    GetShellControls_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void set_draw_controls(int32_t param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8)
                {
                    SetDrawControls_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }

                void set_itr(GXITRPtr param1)
                {
                    SetITR_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void set_shell_controls(double param1, double param2)
                {
                    SetShellControls_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }


            };
            class GXVOXE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVOXE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVOXEPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVOXE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXVOXEPtr create(GXVOXPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VOXE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOXE>(ret);
                }

                ~GXVOXE()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VOXE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void profile(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, VOXE_EVAL param5)
                {
                    Profile_VOXE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

                double value(double param1, double param2, double param3, VOXE_EVAL param4)
                {
                    double ret = rValue_VOXE(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }

                void vector(double param1, double param2, double param3, double param4, double param5, double param6, GXVVPtr param7, VOXE_EVAL param8)
                {
                    Vector_VOXE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }


            };
            class GXVULCAN
            {
            private:
                GXVULCAN();
                ~GXVULCAN();
            public:


                static int32_t is_valid_triangulation_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = IsValidTriangulationFile_VULCAN(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static int32_t is_valid_block_model_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = IsValidBlockModelFile_VULCAN(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

                static void triangulation_to_view(const gx_string_type& param1, GXIPJPtr param2, GXMVIEWPtr param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TriangulationToView_VULCAN(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str());
                    gx_->throw_on_error();
                }

                static void get_block_model_variable_info(const gx_string_type& param1, BLOCK_MODEL_VARIABLE_TYPE param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetBlockModelVariableInfo_VULCAN(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void get_block_model_string_variable_values(const gx_string_type& param1, const gx_string_type& param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetBlockModelStringVariableValues_VULCAN(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void block_model_to_voxel(const gx_string_type& param1, GXIPJPtr param2, const gx_string_type& param3, const gx_string_type& param4, bool param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    long paramBool5 = param5 ? 1 : 0;
                    BlockModelToVoxel_VULCAN(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), param4.c_str(), &paramBool5, param6.c_str());
                    gx_->throw_on_error();
                }


            };
            class GXVV
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVV(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVVPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVV>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }





#ifdef GXPYTHON
                np::ndarray get_data_np(int32_t start, int32_t elements, bp::object dtype)
#else
                template <typename T>
                std::vector<T> get_data(int32_t start, int32_t elements)
#endif

                {


#ifdef GXPYTHON
                    int32_t gs_type;
                    size_t total_size;
                    auto np_array = make_ndarray(elements, dtype, gs_type, total_size);
                    iGetData_VV(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start, elements, np_array.get_data(), gs_type);
                    gx_->throw_on_error();
                    return np_array;
#else
                    std::vector<T> data(elements);
                    iGetData_VV(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start, elements, data.data(), gs_cpp_type<T>::type());
                    gx_->throw_on_error();
                    return data;
#endif

                }



#ifdef GXPYTHON
                void set_data_np(int32_t start, np::ndarray np_array)
#else
                template <typename T>
                void set_data(int32_t start, const std::vector<T>& data)
#endif

                {


#ifdef GXPYTHON
                    int32_t gs_type;
                    size_t elements, total_size;
                    auto contig_np_array = validate_and_make_contiguous_ndarray(np_array, elements, gs_type, total_size);
                    iSetData_VV(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start, (long)elements, contig_np_array.get_data(), gs_type);
                    gx_->throw_on_error();
#else
                    iSetData_VV(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start, data.size(), data.data(), gs_cpp_type<T>::type());
                    gx_->throw_on_error();
#endif

                }

                void copy(GXVVPtr param1)
                {
                    _Copy_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void copy2(int32_t param1, GXVVPtr param2, int32_t param3, int32_t param4)
                {
                    _Copy2_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void log(VV_LOG_BASE param1, VV_LOG_NEGATIVE param2, double param3)
                {
                    _Log_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }

                void log_linear(double param1)
                {
                    _LogLinear_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void mask(GXVVPtr param1)
                {
                    _Mask_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void reverse()
                {
                    _Reverse_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void serial(GXBFPtr param1)
                {
                    _Serial_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void trans(double param1, double param2)
                {
                    _Trans_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void abs()
                {
                    Abs_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void add(GXVVPtr param1, GXVVPtr param2)
                {
                    Add_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void add2(double param1, GXVVPtr param2, double param3, GXVVPtr param4)
                {
                    Add2_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void append(GXVVPtr param1)
                {
                    Append_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                int32_t crc(int32_t param1)
                {
                    int32_t ret = CRC_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t crc_inexact(int32_t param1, VV_FLOAT_CRC_BITS param2, VV_DOUBLE_CRC_BITS param3)
                {
                    int32_t ret = CRCInexact_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

                static GXVVPtr create(GEO_VAR param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                static GXVVPtr create_ext(GS_TYPES param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateExt_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                static GXVVPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

                ~GXVV()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void diff(int32_t param1)
                {
                    Diff_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void divide(GXVVPtr param1, GXVVPtr param2)
                {
                    Divide_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void fid_norm(GXVVPtr param1)
                {
                    FidNorm_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void fill_int(int32_t param1)
                {
                    FillInt_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void fill_double(double param1)
                {
                    FillReal_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void fill_string(const gx_string_type& param1)
                {
                    FillString_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                int32_t count_dummies(int32_t param1, int32_t param2)
                {
                    int32_t ret = iCountDummies_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t find_dum(int32_t param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    int32_t ret = iFindDum_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_fid_expansion()
                {
                    int32_t ret = iGetFidExpansion_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t get_int(int32_t param1)
                {
                    int32_t ret = iGetInt_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void get_string(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IGetString_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }

                int32_t index_max(double& param1)
                {
                    int32_t ret = iIndexMax_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                    return ret;
                }

                int32_t length()
                {
                    int32_t ret = iLength_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                void index_insert(GXVVPtr param1, GXVVPtr param2)
                {
                    IndexInsert_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void index_order(GXVVPtr param1)
                {
                    IndexOrder_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void init_index(int32_t param1)
                {
                    InitIndex_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void inv_log(VV_LOG_BASE param1, VV_LOG_NEGATIVE param2, double param3)
                {
                    InvLog_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }

                VV_ORDER order(int32_t& param1)
                {
                    VV_ORDER ret = (VV_ORDER)iOrder_VV(
                                       gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                void lines_to_xy(GXVVPtr param1, GXVVPtr param2)
                {
                    LinesToXY_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void lookup_index(GXVVPtr param1, GXVVPtr param2)
                {
                    LookupIndex_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void make_mem_based()
                {
                    MakeMemBased_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void mask_and(GXVVPtr param1, GXVVPtr param2)
                {
                    MaskAND_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void mask_or(GXVVPtr param1, GXVVPtr param2)
                {
                    MaskOR_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void mask_str(GXVVPtr param1, const gx_string_type& param2)
                {
                    MaskStr_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

                void multiply(GXVVPtr param1, GXVVPtr param2)
                {
                    Multiply_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void amplitude_3d(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    Amplitude3D_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                void polygon_mask(GXVVPtr param1, GXVVPtr param2, GXPLYPtr param3, VV_MASK param4)
                {
                    PolygonMask_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                static void project(GXPJPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Project_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

                static void project_3d(GXPJPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Project3D_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

                void range_double(double& param1, double& param2)
                {
                    RangeDouble_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }

                void re_fid(double param1, double param2, int32_t param3)
                {
                    ReFid_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void re_fid_vv(GXVVPtr param1)
                {
                    ReFidVV_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void re_sample(double param1, double param2, double param3, double param4, int32_t param5, int32_t param6)
                {
                    ReSample_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                double get_fid_incr()
                {
                    double ret = rGetFidIncr_VV(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double get_fid_start()
                {
                    double ret = rGetFidStart_VV(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double get_double(int32_t param1)
                {
                    double ret = rGetReal_VV(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

                double sum()
                {
                    double ret = rSum_VV(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

                double weighted_mean(GXVVPtr param1)
                {
                    double ret = rWeightedMean_VV(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

                void set_fid_expansion(int32_t param1)
                {
                    SetFidExpansion_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_fid_incr(double param1)
                {
                    SetFidIncr_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_fid_start(double param1)
                {
                    SetFidStart_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

                void set_int(int32_t param1, int32_t param2)
                {
                    SetInt_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void set_int_n(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetIntN_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void set_len(int32_t param1)
                {
                    SetLen_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void set_double(int32_t param1, double param2)
                {
                    SetReal_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

                void set_double_n(int32_t param1, int32_t param2, double param3)
                {
                    SetRealN_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }

                void set_string(int32_t param1, const gx_string_type& param2)
                {
                    SetString_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

                void set_string_n(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    SetStringN_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

                void setup_index(GXVVPtr param1, GXVVPtr param2, VV_LOOKUP param3, double param4)
                {
                    SetupIndex_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }

                void sort(VV_SORT param1)
                {
                    Sort_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

                void sort_index(GXVVPtr param1)
                {
                    SortIndex_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

                void sort_index1(GXVVPtr param1, VV_SORT param2)
                {
                    SortIndex1_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

                void sort_index2(GXVVPtr param1, GXVVPtr param2, VV_SORT param3, VV_SORT param4)
                {
                    SortIndex2_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

                void sort_index3(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, VV_SORT param4, VV_SORT param5, VV_SORT param6)
                {
                    SortIndex3_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }

                void sort_index4(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, VV_SORT param5, VV_SORT param6, VV_SORT param7, VV_SORT param8)
                {
                    SortIndex4_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

                static void statistics(GXSTPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Statistics_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void subtract(GXVVPtr param1, GXVVPtr param2)
                {
                    Subtract_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

                void swap()
                {
                    Swap_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

                void window(double param1, double param2, VV_WINDOW param3)
                {
                    Window_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

                void write_xml(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    WriteXML_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }


            };
            class GXWA
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXWA(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXWAPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXWA>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void puts(const gx_string_type& param1)
                {
                    _Puts_WA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

                static GXWAPtr create(const gx_string_type& param1, WA_OPEN param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_WA(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXWA>(ret);
                }

                static GXWAPtr create_ex(const gx_string_type& param1, WA_OPEN param2, WA_ENCODE param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateEx_WA(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXWA>(ret);
                }

                static GXWAPtr create_sbf(GXSBFPtr param1, const gx_string_type& param2, WA_OPEN param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateSBF_WA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXWA>(ret);
                }

                static GXWAPtr create_sbf_ex(GXSBFPtr param1, const gx_string_type& param2, WA_OPEN param3, WA_ENCODE param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateSBFEx_WA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXWA>(ret);
                }

                ~GXWA()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_WA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

                void new_line()
                {
                    NewLine_WA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }


            };

#ifndef GX_EXLUDE_IMPL
            thread_local std::weak_ptr<GXContext> GXContext::currentContext;
#endif // GX_EXLUDE_IMPL

        }
    }
}
